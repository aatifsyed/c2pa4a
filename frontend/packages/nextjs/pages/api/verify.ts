import { ZKEdDSAEventTicketPCDPackage } from "@pcd/zk-eddsa-event-ticket-pcd";
import { NextApiRequest, NextApiResponse } from "next";
import { hexToBigInt } from "viem";
import { createWalletClient, http, isAddress, parseEther } from "viem";
import { hardhat } from "viem/chains";
import { isETHBerlinPublicKey } from "~~/utils/scaffold-eth/pcd";
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

export const config = {
  api: {
    responseLimit: '50mb',
  },
}

const localWalletClient = createWalletClient({
  chain: hardhat,
  transport: http(),
});

const accounts = await localWalletClient.getAddresses();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {

  console.log(req.body)

  const { input, extension, lat, lon, author, proof } = req.body;

  // Parse the PCD string
  const pcd = await ZKEdDSAEventTicketPCDPackage.deserialize(proof);
  const address = author;


  // ## Validations
  if (!isAddress(address)) {
    return res.status(401).send("Invalid address");
  }

  if (!(await ZKEdDSAEventTicketPCDPackage.verify(pcd))) {
    console.error(`[ERROR] ZK ticket PCD is not valid`);

    return res.status(401).send("ZK ticket PCD is not valid");
  }

  if (!isETHBerlinPublicKey(pcd.claim.signer)) {
    console.error(`[ERROR] PCD is not signed by Zupass`);

    return res.status(401).send("PCD is not signed by ETHBerlin");
  }

  // TODO: Use real nonce generated by the server
  if (pcd.claim.watermark.toString() !== hexToBigInt(address as `0x${string}`).toString()) {
    console.error(`[ERROR] PCD watermark doesn't match`);

    res.status(401).send("PCD watermark doesn't match");
    return;
  }

  // TODO: Check that the event id is the one we expect

  // ## Actions
  // Send ETH to the user. This is just for testing purposes, and it could be any backend action.
  // const result = await localWalletClient.sendTransaction({
  //   to: req.body.address,
  //   value: parseEther("1"),
  //   account: accounts[0],
  // });

  try {
    // Extract the base64 video data from the input string
    const base64Video = input.split(',')[1];

    // Create a manifest JSON object
    const manifestJson = {
      // Add your manifest properties here
      // Example:
      assertions: [
        {
          label: 'org.contentauth.test',
          data: {
            latitude: lat,
            longitude: lon,
            author: address,
          },
        },
      ],
    };

    // Sign the video with the manifest using c2patool
    const signedVideoBase64 = await signVideoWithManifest(base64Video, manifestJson);

    // Return the signed video base64 data as the response
    res.status(200).json({ signedVideo: signedVideoBase64 });
  } catch (error) {
    console.error('Error signing video:', error);
    res.status(500).json({ error: 'Failed to sign video' });
  }
}


// Helper function to sign the video with the manifest


function signVideoWithManifest(base64Video, manifestJson) {
  return new Promise((resolve, reject) => {
    // Create a temporary directory
    const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'c2pa-'));

    // Create temporary input and output file paths
    const tempInputPath = path.join(tempDir, 'input.mp4');
    const tempOutputPath = path.join(tempDir, 'signed.mp4');

    // Convert the base64 video to a Buffer
    const videoBuffer = Buffer.from(base64Video, 'base64');

    // Write the video buffer to the temporary input file
    fs.writeFileSync(tempInputPath, videoBuffer);

    // Convert the manifest JSON to a string
    const manifestString = JSON.stringify(manifestJson);

    // Spawn the c2patool process
    const c2patool = spawn('c2patool', [
      tempInputPath,
      '-m', '-', // Use - to read the manifest from stdin
      '-o', tempOutputPath, // Output to the temporary file
    ]);

    // Write the manifest to the c2patool's stdin
    c2patool.stdin.write(manifestString);
    c2patool.stdin.end();

    // Collect the stderr output
    let stderr = '';
    c2patool.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    // Wait for the c2patool process to exit
    c2patool.on('close', (code) => {
      if (code === 0) {
        // Read the signed video file as base64
        const signedVideoBase64 = fs.readFileSync(tempOutputPath, 'base64');

        // Clean up the temporary directory and files
        fs.rmdirSync(tempDir, { recursive: true });

        resolve(signedVideoBase64);
      } else {
        // Clean up the temporary directory and files
        fs.rmdirSync(tempDir, { recursive: true });
        reject(new Error(`c2patool exited with code ${code}. stderr: ${stderr}`));
      }
    });
  });
}