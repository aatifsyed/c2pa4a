var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { GeoPointInOrOutOfPolygonCircuit, GeoPointInOrOutOfPolygonCircuitProof } from "../../zkprogram/private/GeoPointInOrOutOfPolygonCircuit";
import { ZKLocusProof } from "./ZKLocusProof";
import { ZKGeoPoint } from "../models/ZKGeoPoint";
import CachingProofVerificationMiddleware from "./middleware/CachingProofVerificationMiddleware";
import { ZKGeoPointInPolygonProof } from "./ZKGeoPointInPolygonProof";
import { ZKThreePointPolygon } from "../models/ZKThreePointPolygon";
/**
 * Represents a rolled-up ZKGeoPointInPolygonCircuit proof. Currently, it's used as a DTO, but later it should be
 * expanded into a more sophisticated abstraction, which behaves like any other ZKLocusProof.
 */
export class RolledUpZKGeoPointInPolygonCircuitProof {
    /**
     * Creates a new instance of RolledUpZKGeoPointInPolygonCircuitProof.
     * @param _individualZkProofs The individual ZKGeoPointInOrOutOfPolygonCircuit proofs.
     * @param _rolledUpProof The rolled-up ZKGeoPointInOrOutOfPolygonCircuit proof.
     */
    constructor(_individualZkProofs, _rolledUpProof) {
        this._individualZkProofs = _individualZkProofs;
        this._rolledUpProof = _rolledUpProof;
    }
    /**
     * Gets the individual ZKGeoPointInPolygonProof proofs.
     */
    get individualZkProofs() {
        return this._individualZkProofs;
    }
    /**
     * Gets the rolled-up ZKGeoPointInPolygonProof proof.
     */
    get rolledUpProof() {
        return this._rolledUpProof;
    }
    get isInsidePolygon() {
        return this._rolledUpProof.isGeoPointInsidePolygon;
    }
    combinedHashOfPolygons() {
        const polygons = this._individualZkProofs.map((proof) => proof.polygonOrError);
        return ZKThreePointPolygon.combinedHash(polygons);
    }
}
/*
* Authenticated GeoPoint source proof. This is an abstraction over the set of Zero-Knowledge proof that is used to
* prove that a GeoPoint was provided by a trusted source. It can be used to prove that a GeoPoint was provided by
* a trusted source, such as an Oracle.
*
* This class is an abstraction over the GeoPointProviderCircuitProof class, which is the actual zero-knowledge proof.
* The proof is not generated by this class, but rather passed to it in the constructor. In order to generate a proof
* from an Oracle, use the methods of ZKGeoPoint class.
*/
let ZKGeoPointInOrOutOfPolygonCircuitProof = class ZKGeoPointInOrOutOfPolygonCircuitProof extends ZKLocusProof {
    constructor(_zkGeoPoint, _insideProofs, _outsideProofs, _proof) {
        if (!_insideProofs.isInsidePolygon) {
            throw new Error("The provided inside proof rollup is outside of the polygon combination.");
        }
        if (_outsideProofs.isInsidePolygon) {
            throw new Error("The provided outside proof rollup is inside of the polygon combination.");
        }
        super();
        this._zkGeoPoint = _zkGeoPoint;
        this._insideProofs = _insideProofs;
        this._outsideProofs = _outsideProofs;
        this._proof = _proof;
    }
    static fromJSON(jsonProof) {
        return GeoPointInOrOutOfPolygonCircuitProof.fromJSON(jsonProof);
    }
    get zkGeoPoint() {
        this.verify();
        return this._zkGeoPoint;
    }
    get insideProofs() {
        this.verify();
        return this._insideProofs;
    }
    get outsideProofs() {
        this.verify();
        return this._outsideProofs;
    }
    get commitment() {
        this.verify();
        return this._proof.publicOutput;
    }
    assertGeoPointIsTheClaimedOne() {
        const commitment = this._proof.publicOutput;
        const commitedGeoPoint = commitment.coordinatesCommitment;
        const claimedGeoPoint = this._zkGeoPoint.toZKValue();
        const claimedGeoPointCommitment = claimedGeoPoint.hash();
        if (!claimedGeoPointCommitment.equals(claimedGeoPointCommitment)) {
            throw new Error(`GeoPoint Commitment does not match the claimed one. Claimed: ${claimedGeoPointCommitment.toString()}. Actual: ${commitedGeoPoint.toString()}`);
        }
    }
    assertPolygonsAreTheClaimedOnes() {
        // assert that all of the inside proofs are indeed inside polygon proofs
        for (const insideProof of this._insideProofs.individualZkProofs) {
            insideProof.verify();
            if (!insideProof.isGeoPointInsidePolygon) {
                throw new Error("Not all of the inside proofs are proofs of a GeoPoint being inside a polygon. Faulty proof: " + insideProof.toString());
            }
        }
        // assert that all of the outside proofs are indeed outside polygon proofs
        for (const outsideProof of this._outsideProofs.individualZkProofs) {
            outsideProof.verify();
            if (outsideProof.isGeoPointInsidePolygon) {
                throw new Error("Not all of the outside proofs are proofs of a GeoPoint being outside a polygon. Faulty proof: " + outsideProof.toString());
            }
        }
        const commitment = this._proof.publicOutput;
        const commitedInsidePolygon = commitment.insidePolygonCommitment;
        const commitedOutsidePolygon = commitment.outsidePolygonCommitment;
        const claimedInsidePolygonCommitment = this._insideProofs.combinedHashOfPolygons();
        const claimedOutsidePolygonCommitment = this._outsideProofs.combinedHashOfPolygons();
        if (!claimedInsidePolygonCommitment.equals(commitedInsidePolygon)) {
            throw new Error(`Inside Polygon Commitment does not match the claimed one. Claimed: ${claimedInsidePolygonCommitment.toString()}. Actual: ${commitedInsidePolygon.toString()}`);
        }
        if (!claimedOutsidePolygonCommitment.equals(commitedOutsidePolygon)) {
            throw new Error(`Outside Polygon Commitment does not match the claimed one. Claimed: ${claimedOutsidePolygonCommitment.toString()}. Actual: ${commitedOutsidePolygon.toString()}`);
        }
    }
    verify() {
        super.verify();
        this.assertGeoPointIsTheClaimedOne();
        this.assertPolygonsAreTheClaimedOnes();
    }
};
ZKGeoPointInOrOutOfPolygonCircuitProof._circuit = GeoPointInOrOutOfPolygonCircuit;
ZKGeoPointInOrOutOfPolygonCircuitProof._dependentProofs = [
    ZKGeoPointInPolygonProof,
];
ZKGeoPointInOrOutOfPolygonCircuitProof = __decorate([
    CachingProofVerificationMiddleware,
    __metadata("design:paramtypes", [ZKGeoPoint, RolledUpZKGeoPointInPolygonCircuitProof, RolledUpZKGeoPointInPolygonCircuitProof, GeoPointInOrOutOfPolygonCircuitProof])
], ZKGeoPointInOrOutOfPolygonCircuitProof);
export { ZKGeoPointInOrOutOfPolygonCircuitProof };
//# sourceMappingURL=ZKGeoPointInOrOutOfPolygonCircuitProof.js.map