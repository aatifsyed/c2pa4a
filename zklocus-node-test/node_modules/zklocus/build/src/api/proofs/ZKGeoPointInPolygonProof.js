var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ZKGeoPointInPolygonProof_1;
import { Poseidon } from "o1js";
import { GeoPointInPolygonCircuit, GeoPointInPolygonCircuitProof, GeoPointInPolygonCombinerCircuit } from "../../zkprogram/private/GeoPointInPolygonCircuit";
import { ZKLocusProof } from "./ZKLocusProof";
import { ZKGeoPointProviderCircuitProof } from "./ZKGeoPointProviderCircuitProof";
import CachingGeoPointInPolygonProofMiddleware from "./middleware/CachingGeoPointInPolygonProofMiddleware";
export var GeoPointInPolygonCombinationOperator;
(function (GeoPointInPolygonCombinationOperator) {
    GeoPointInPolygonCombinationOperator["NONE"] = "NONE";
    GeoPointInPolygonCombinationOperator["AND"] = "AND";
    GeoPointInPolygonCombinationOperator["OR"] = "OR";
})(GeoPointInPolygonCombinationOperator || (GeoPointInPolygonCombinationOperator = {}));
/**
 * Represents a proof that a ZKGeoPoint is inside a ZKThreePointPolygon in a zero-knowledge circuit.
 * This class allows representation of both a single Point In Polygon Proof, and a combination of such proofs
 * using logical AND and OR operators. It encapsulates the logic for combining and verifying these proofs.
 */
let ZKGeoPointInPolygonProof = ZKGeoPointInPolygonProof_1 = class ZKGeoPointInPolygonProof extends ZKLocusProof {
    get leftZKProof() {
        return this._leftZKProof;
    }
    get rightZKProof() {
        return this._rightZKProof;
    }
    get operator() {
        return this._operator;
    }
    /**
     * Constructs a ZKGeoPointInPolygonProof instance. It can represent a single proof or a combination of proofs using AND and OR operations.
     * @param geoPoint - The geo point for which the proof is constructed.
     * @param polygon - The polygon within which the geo point's presence is being proved.
     * @param proof - The base proof or the primary proof before combining with others.
     * @param andProofs - (Optional) Array of proofs to be combined with the base proof using the AND operator.
     * @param orProofs - (Optional) Array of proofs to be combined with the base proof using the OR operator.
     */
    constructor({ geoPoint, proof, polygon, leftProof, rightProof, operator }) {
        super();
        this._leftZKProof = undefined;
        this._rightZKProof = undefined;
        this._operator = GeoPointInPolygonCombinationOperator.NONE;
        this.geoPoint = geoPoint;
        this._proof = proof;
        this.threePointPolygon = polygon;
        if (polygon === undefined) {
            if (leftProof === undefined || rightProof === undefined) {
                throw new Error('Either the polygon or the left and right proofs must be provided.');
            }
        }
        else {
            if (leftProof !== undefined || rightProof !== undefined) {
                throw new Error('Either the polygon or the left and right proofs must be provided.');
            }
        }
        const commitment = proof.publicOutput;
        this._isInside = commitment.isInPolygon.toBoolean();
        this._leftZKProof = leftProof;
        this._rightZKProof = rightProof;
        this._operator = operator ?? GeoPointInPolygonCombinationOperator.NONE;
        // TODO: this may be refactored to a more elegant solution. For now, there is a need for a non-intrusive
        // way to access the unverified proof data.
        this.UnverifiedProofData = {
            geoPoint: this.geoPoint,
            threePointPolygon: this.threePointPolygon,
            isInside: this._isInside,
            get zkGeoPoint() {
                return this.geoPoint;
            },
            get zkPolygon() {
                return this.threePointPolygon;
            },
            get isGeoPointInsidePolygon() {
                return this.isInside;
            }
        };
    }
    /**
     * Creates a clone of the ZKGeoPointInPolygonProof instance.
     *
     * @returns A new instance of ZKGeoPointInPolygonProof with the same values for the minimal necessary attributes.
     * The cloned proof will be considered identical to the original proof.
     */
    clone() {
        const proof = this.proof;
        const leftProof = this.leftZKProof;
        const rightProof = this.rightZKProof;
        const operator = this.operator;
        const clonedProof = new ZKGeoPointInPolygonProof_1({
            geoPoint: this.geoPoint,
            proof: proof,
            polygon: this.threePointPolygon,
            leftProof: leftProof,
            rightProof: rightProof,
            operator: operator
        });
        return clonedProof;
    }
    setProof(proof) {
        this._proof = proof;
    }
    clearCache() {
        this.setProof(this.proof);
    }
    /**
     * Performs a Zero-Knowledge AND operation between two ZKGeoPointInPolygonProof instances.
     * This is a zkLocus roll-up operations, which compresses two proofs into a single proof.
     * This enabled the creation of an application chain for zkLocus.
     *
     * @param other - The other ZKGeoPointInPolygonProof instance to perform the AND operation with.
     * @returns A new ZKGeoPointInPolygonProof instance representing the combination of the two proofs.
     */
    async AND(other) {
        console.log('In ZKGeoPointInPolygonProof.AND()');
        this.verify();
        other.verify();
        console.log('In ZKGeoPointInPolygonProof.AND() - after verify()');
        const thisProof = this.proof;
        const otherProof = other.proof;
        // Perform a Zero-Knowledge combination of the two proofs with .AND
        const andProof = await GeoPointInPolygonCombinerCircuit.AND(thisProof, otherProof);
        console.log('In ZKGeoPointInPolygonProof.AND() - after GeoPointInPolygonCombinerCircuit AND()');
        const resultingZKProof = new ZKGeoPointInPolygonProof_1({
            geoPoint: this.geoPoint,
            proof: andProof,
            leftProof: this,
            rightProof: other,
            operator: GeoPointInPolygonCombinationOperator.AND
        });
        return resultingZKProof;
    }
    polygonHash() {
        const polygon = this.threePointPolygon;
        if (polygon !== undefined) {
            return polygon.hash();
        }
        // Polygon is undefined, meaning it's a combination of proofs
        const leftProof = this.leftZKProof;
        const rightProof = this.rightZKProof;
        if (leftProof === undefined || rightProof === undefined) {
            throw new Error('[!] INVALID OBJECT STATE: Either the polygon or the left and right proofs must be provided.');
        }
        const leftPolygonHash = leftProof.polygonHash();
        const rightPolygonHash = rightProof.polygonHash();
        return Poseidon.hash([leftPolygonHash, rightPolygonHash]);
    }
    static fromJSON(jsonProof) {
        return GeoPointInPolygonCircuitProof.fromJSON(jsonProof);
    }
    get zkGeoPoint() {
        this.verify();
        return this.geoPoint;
    }
    get zkPolygon() {
        this.verify();
        return this.threePointPolygon;
    }
    get isGeoPointInsidePolygon() {
        this.verify();
        return this._isInside;
    }
    get polygon() {
        this.verify();
        return this.threePointPolygon;
    }
    get polygonOrError() {
        this.verify();
        const polygon = this.threePointPolygon;
        if (polygon === undefined) {
            throw new Error('Polygon is undefined.');
        }
        return polygon;
    }
    /**
     * Asserts that the coordinates and polygon are the claimed ones.
     */
    assertVerifyCoordinatesAndPolygonAreTheClaimedOnes() {
        const commitment = this.proof.publicOutput;
        const commitedPolygonHash = commitment.polygonCommitment;
        const commitedGeoPointHash = commitment.geoPointCommitment;
        const claimedGeoPoint = this.geoPoint;
        const claimedGeoPointHash = claimedGeoPoint.hash();
        const claimedPolygonHash = this.polygonHash();
        if (!claimedGeoPointHash.equals(commitedGeoPointHash)) {
            throw new Error(`GeoPoint Commitment does not match the claimed one. Claimed: ${claimedGeoPointHash.toString()}. Actual: ${commitedGeoPointHash.toString()}`);
        }
        if (!claimedPolygonHash.equals(commitedPolygonHash)) {
            throw new Error(`Polygon Commitment does not match the claimed one. Claimed: ${claimedPolygonHash.toString()}. Actual: ${commitedPolygonHash.toString()}`);
        }
        if (!claimedPolygonHash.equals(commitedPolygonHash)) {
            throw new Error(`Polygon Commitment does not match the claimed one. Claimed: ${claimedPolygonHash.toString()}. Actual: ${commitedPolygonHash.toString()}`);
        }
    }
    verify() {
        this.assertVerifyCoordinatesAndPolygonAreTheClaimedOnes();
        super.verify();
        // NOTE: the left and right leaf verification is omitted on purpose. This is not done *FOR NOW* for performance reasons.
        // Strong-ish assertions are done in .assertVerifyCoordinatesAndPolygonAreTheClaimedOnes(). A more robust caching middleware
        // will be implemented in the future, which will allow for a more robust verification of the proofs.
        // The current version of the middlware does not account for verifications done inside of zkLocus Zero-Knowledge ciruits, only
        // at the API level.
        //
        // if (this.leftZKProof !== undefined) {
        //     this.leftZKProof.verify();
        // }
        // if (this.rightZKProof !== undefined) {
        //     this.rightZKProof.verify();
        // }
    }
    /**
     * Checks if this ZKGeoPointInPolygonProof is equal to another ZKGeoPointInPolygonProof.
     * @param other The other ZKGeoPointInPolygonProof to compare with.
     * @returns True if the two proofs are equal, false otherwise.
     */
    isEquals(other) {
        const thisPolygon = this.threePointPolygon;
        const otherPolygon = other.threePointPolygon;
        let isThreePointPolygonEqual;
        if (thisPolygon !== undefined && otherPolygon !== undefined) {
            isThreePointPolygonEqual = thisPolygon.isEquals(otherPolygon);
        }
        else {
            isThreePointPolygonEqual = thisPolygon === otherPolygon;
        }
        const isGeoPointEqual = this.geoPoint.isEquals(other.geoPoint);
        const isLocationEqual = this._isInside === other._isInside;
        const isPolygonsEqual = this.polygonHash().equals(other.polygonHash()).toBoolean();
        return isGeoPointEqual && isThreePointPolygonEqual && isLocationEqual && isPolygonsEqual;
    }
};
/**
 * The Zero-Knowledge O1JS circuit used for the point in polygon proof.
 */
ZKGeoPointInPolygonProof._circuit = GeoPointInPolygonCircuit;
/**
 * An array of dependent proofs required by this proof.
 */
ZKGeoPointInPolygonProof._dependentProofs = [
    ZKGeoPointProviderCircuitProof,
];
ZKGeoPointInPolygonProof._siblingCircuits = [
    GeoPointInPolygonCombinerCircuit,
];
ZKGeoPointInPolygonProof = ZKGeoPointInPolygonProof_1 = __decorate([
    CachingGeoPointInPolygonProofMiddleware,
    __metadata("design:paramtypes", [Object])
], ZKGeoPointInPolygonProof);
export { ZKGeoPointInPolygonProof };
//# sourceMappingURL=ZKGeoPointInPolygonProof.js.map