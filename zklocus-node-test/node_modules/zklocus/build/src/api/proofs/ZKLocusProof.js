import { Cache } from "o1js";
import { ZKThreePointPolygon } from "../models/ZKThreePointPolygon";
export class ZKCommitment {
}
/**
 * This class represents a commitment to a ZKGeoPoint being inside or outside a ZKThreePointPolygon.
 * It's an abstraction over the GeoPointInPolygonCommitment class, which is the actual zero-knowledge commitment.
 */
export class ZKGeoPointInPolygonCommitment extends ZKCommitment {
    constructor(_geoPoint, polygons, _isInPolygon, _commitment) {
        super();
        this._geoPoint = _geoPoint;
        this._isInPolygon = _isInPolygon;
        this._commitment = _commitment;
        const normalizedPolygons = Array.isArray(polygons) ? polygons : [polygons];
        this._polygons = normalizedPolygons;
    }
    verify() {
        const polygonCommitment = this._commitment.polygonCommitment;
        const geoPointCommitment = this._commitment.geoPointCommitment;
        const isInsidePolygon = this._commitment.isInPolygon.toBoolean();
        const claimedPolygons = this._polygons;
        const claimedGeoPoint = this._geoPoint;
        const claimedPolygonCommitment = ZKThreePointPolygon.combinedHash(claimedPolygons);
        const claimedGeoPointCommitment = claimedGeoPoint.hash();
        const claimedIsInPolygon = this._isInPolygon;
        if (!claimedPolygonCommitment.equals(polygonCommitment)) {
            throw new Error(`Polygon Commitment does not match the claimed one. Claimed: ${claimedPolygonCommitment.toString()}. Actual: ${polygonCommitment.toString()}`);
        }
        if (!claimedGeoPointCommitment.equals(geoPointCommitment)) {
            throw new Error(`GeoPoint Commitment does not match the claimed one. Claimed: ${claimedGeoPointCommitment.toString()}. Actual: ${geoPointCommitment.toString()}`);
        }
        if (claimedIsInPolygon !== isInsidePolygon) {
            throw new Error(`IsInPolygon does not match the claimed one. Claimed: ${claimedIsInPolygon}. Actual: ${isInsidePolygon}`);
        }
    }
}
/**
 * Commitment to a GeoPoint being authenticated by an Oracle.
 * This class represents a commitment to a ZKGeoPoint being signed by a ZKPublicKey.
 */
export class ZKOracleAuthenticatedGeoPointCommitment extends ZKCommitment {
    constructor(geoPoint, publicKey, commitment) {
        super();
        this.zkGeoPoint = geoPoint;
        this.zkkPublicKey = publicKey;
        this._commitment = commitment;
    }
    /**
     * Verify that the commitment corresponds to the claimed GeoPoint and PublicKey.
     * In zkLocus, a commitment to a GeoPoint is the Poseidon hash of the GeoPoint's latitude, longitude and factor,
     * while a commitment to a PublicKey is the Poseidon hash of the PublicKey's field array.
     */
    verify() {
        // Oracle commitment data
        const publicKeyHash = this._commitment.publicKeyHash;
        const geoPointHash = this._commitment.geoPointHash;
        // Claimed data
        const claimedPublicKeyHash = this.zkkPublicKey.hash();
        const claimedGeoPointHash = this.zkGeoPoint.hash();
        // Verify that the claimed data matches the commitment data
        if (!claimedPublicKeyHash.equals(publicKeyHash)) {
            throw new Error(`Public Key Hash does not match the claimed one. Claimed: ${claimedPublicKeyHash.toString()}. Actual: ${publicKeyHash.toString()}`);
        }
        if (!claimedGeoPointHash.equals(geoPointHash)) {
            throw new Error(`GeoPoint Hash does not match the claimed one. Claimed: ${claimedGeoPointHash.toString()}. Actual: ${geoPointHash.toString()}`);
        }
    }
}
/*
    This is the parent abstraction class for all zkLocus proofs. Any zkLocus proof is interpertable and abstractble by
    this type. It can load and convert proofs to JSON, combine proofs together, and verify them.

    Internally, it uses the zkLocus API to perform the operations. It also contains properties based on the
    proof structure.
*/
export class ZKLocusProof {
    verify() {
        return this._proof.verify();
    }
    verifyIf(condition) {
        return this._proof.verifyIf(condition);
    }
    toJSON() {
        return this._proof.toJSON();
    }
    /**
     * Compiles the circuit associated with this proof. A ceche is used to store the compiled circuit & keys, so that it doesn't have to be
     * recompiled every time. Once a circuit has been compiled within the scope of an execution, it does not need to be recompiled again.
     *
     * @param cache - The cache to use for compilation. Defaults to Cache.FileSystemDefault.
     * @param forceRecompile - Whether to force recompilation even if the circuit is already compiled. Defaults to false.
     * @returns A promise that resolves to an object containing the verification key data and hash.
     */
    static async compile(cache = Cache.FileSystemDefault, forceRecompile = false) {
        for (const proof of this._dependentProofs) {
            await proof.compile(cache, forceRecompile);
        }
        if (this.compiledCircuit !== undefined && !forceRecompile) {
            return this.compiledCircuit;
        }
        const result = await this._circuit.compile({
            cache: cache,
            forceRecompile: forceRecompile
        });
        this._compiledCircuit = result;
        for (const siblingCircuit of this._siblingCircuits) {
            const siblingResult = await siblingCircuit.compile({
                cache: cache,
                forceRecompile: forceRecompile
            });
            this._compiledSiblingCircuits.push(siblingResult);
        }
        return result;
    }
    static get isCompiled() {
        if (this.compiledCircuit === undefined) {
            return false;
        }
        return true;
    }
    static get compiledCircuit() {
        return this._compiledCircuit;
    }
    /**
     * The set of dependent proofs that need to be compiled to enable generation and verification of proofs of this type.
     */
    static get dependentProofs() {
        return this._dependentProofs;
    }
    get proof() {
        return this._proof;
    }
}
/**
 * The set of sibling circuits associated with the main circuit. A sibling circuit is a circuit that has the same public output as the main circuit,
 * and extends the main circuit's semanthics and functionality. An example of a sibling circuit is a circuit that provides roll-up functionality
 * for the main circuit.
 *
 * Sibling circuits are compiled alongisde the main circuit.
 */
ZKLocusProof._siblingCircuits = [];
ZKLocusProof._compiledSiblingCircuits = [];
//# sourceMappingURL=ZKLocusProof.js.map