var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ZKGeoPointProviderCircuitProof_1;
import { GeoPointProviderCircuit, GeoPointProviderCircuitProof } from "../../zkprogram/private/Geography";
import { ZKLocusProof } from "./ZKLocusProof";
import { ZKGeoPoint } from "../models/ZKGeoPoint";
import CachingProofVerificationMiddleware from "./middleware/CachingProofVerificationMiddleware";
import { ZKOracleGeoPointProviderCircuitProof } from "./ZKOracleGeoPointProviderCircuitProof";
/*
* Authenticated GeoPoint source proof. This is an abstraction over the set of Zero-Knowledge proof that is used to
* prove that a GeoPoint was provided by a trusted source. It can be used to prove that a GeoPoint was provided by
* a trusted source, such as an Oracle.
*
* This class is an abstraction over the GeoPointProviderCircuitProof class, which is the actual zero-knowledge proof.
* The proof is not generated by this class, but rather passed to it in the constructor. In order to generate a proof
* from an Oracle, use the methods of ZKGeoPoint class.
*/
let ZKGeoPointProviderCircuitProof = ZKGeoPointProviderCircuitProof_1 = class ZKGeoPointProviderCircuitProof extends ZKLocusProof {
    constructor(proof) {
        super();
        this._proof = proof;
    }
    static fromJSON(jsonProof) {
        return GeoPointProviderCircuitProof.fromJSON(jsonProof);
    }
    get zkGeoPoint() {
        this.verify();
        const geoPoint = this._proof.publicOutput;
        return ZKGeoPoint.fromGeoPoint(geoPoint);
    }
    /**
     * Creates a ZKGeoPointProviderCircuitProof from a ZKGeoPointSignatureVerificationCircuitProof and a ZKGeoPoint.
     * @param proof - The ZKGeoPointSignatureVerificationCircuitProof to create the ZKGeoPointProviderCircuitProof from.
     * @param zkGeoPoint - The ZKGeoPoint to use in the creation of the ZKGeoPointProviderCircuitProof.
     * @returns A Promise that resolves to a ZKGeoPointProviderCircuitProof.
     */
    static async fromOracleSignatureProof(proof) {
        proof.verify();
        const zkGeoPoint = proof.zkGeoPoint;
        const sigVerificationProof = proof.proof;
        const geoPoint = zkGeoPoint.toZKValue();
        const geoPointProviderProof = await GeoPointProviderCircuit.fromOracle(sigVerificationProof, geoPoint);
        return new ZKGeoPointProviderCircuitProof_1(geoPointProviderProof);
    }
};
ZKGeoPointProviderCircuitProof._circuit = GeoPointProviderCircuit;
ZKGeoPointProviderCircuitProof._dependentProofs = [
    ZKOracleGeoPointProviderCircuitProof,
];
ZKGeoPointProviderCircuitProof = ZKGeoPointProviderCircuitProof_1 = __decorate([
    CachingProofVerificationMiddleware,
    __metadata("design:paramtypes", [GeoPointProviderCircuitProof])
], ZKGeoPointProviderCircuitProof);
export { ZKGeoPointProviderCircuitProof };
//# sourceMappingURL=ZKGeoPointProviderCircuitProof.js.map