import { Field, JsonProof } from "o1js";
import { GeoPointInOrOutOfPolygonCircuitProof } from "../../zkprogram/private/GeoPointInOrOutOfPolygonCircuit";
import { IO1JSProof } from "./Types";
import { ZKLocusProof } from "./ZKLocusProof";
import { ZKGeoPoint } from "../models/ZKGeoPoint";
import { ZKGeoPointInPolygonProof } from "./ZKGeoPointInPolygonProof";
import { GeoPointInOutPolygonCommitment } from "../../model/private/Commitment";
/**
 * Represents a rolled-up ZKGeoPointInPolygonCircuit proof. Currently, it's used as a DTO, but later it should be
 * expanded into a more sophisticated abstraction, which behaves like any other ZKLocusProof.
 */
export declare class RolledUpZKGeoPointInPolygonCircuitProof {
    protected _individualZkProofs: ZKGeoPointInPolygonProof[];
    protected _rolledUpProof: ZKGeoPointInPolygonProof;
    /**
     * Creates a new instance of RolledUpZKGeoPointInPolygonCircuitProof.
     * @param _individualZkProofs The individual ZKGeoPointInOrOutOfPolygonCircuit proofs.
     * @param _rolledUpProof The rolled-up ZKGeoPointInOrOutOfPolygonCircuit proof.
     */
    constructor(_individualZkProofs: ZKGeoPointInPolygonProof[], _rolledUpProof: ZKGeoPointInPolygonProof);
    /**
     * Gets the individual ZKGeoPointInPolygonProof proofs.
     */
    get individualZkProofs(): ZKGeoPointInPolygonProof[];
    /**
     * Gets the rolled-up ZKGeoPointInPolygonProof proof.
     */
    get rolledUpProof(): ZKGeoPointInPolygonProof;
    get isInsidePolygon(): boolean;
    combinedHashOfPolygons(): Field;
}
export declare class ZKGeoPointInOrOutOfPolygonCircuitProof extends ZKLocusProof<GeoPointInOrOutOfPolygonCircuitProof> {
    protected _zkGeoPoint: ZKGeoPoint;
    protected _insideProofs: RolledUpZKGeoPointInPolygonCircuitProof;
    protected _outsideProofs: RolledUpZKGeoPointInPolygonCircuitProof;
    protected _proof: GeoPointInOrOutOfPolygonCircuitProof;
    protected static _circuit: {
        name: string;
        compile: (options?: {
            cache?: import("o1js/dist/node/lib/proof-system/cache").Cache | undefined;
            forceRecompile?: boolean | undefined;
        } | undefined) => Promise<{
            verificationKey: {
                data: string;
                hash: import("o1js/dist/node/lib/field").Field;
            };
        }>;
        verify: (proof: import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInOutPolygonCommitment>) => Promise<boolean>;
        digest: () => string;
        analyzeMethods: () => {
            fromPointInPolygonProofs: {
                rows: number;
                digest: string;
                result: unknown;
                gates: import("o1js/dist/node/snarky").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
            };
            extendWithPointInPolygonProof: {
                rows: number;
                digest: string;
                result: unknown;
                gates: import("o1js/dist/node/snarky").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
            };
        };
        publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
        publicOutputType: typeof GeoPointInOutPolygonCommitment;
        privateInputTypes: {
            fromPointInPolygonProofs: [typeof import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof, typeof import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof];
            extendWithPointInPolygonProof: [{
                new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
                    proof: unknown;
                    publicInput: undefined;
                    publicOutput: GeoPointInOutPolygonCommitment;
                    maxProofsVerified: 0 | 1 | 2;
                }): import("o1js/dist/node/lib/proof_system").SelfProof<undefined, GeoPointInOutPolygonCommitment>;
                publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                tag: () => {
                    name: string;
                };
                fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
                    prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
                    publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                    publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                    tag: () => {
                        name: string;
                    };
                    fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
                    dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
                } & {
                    prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
                }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
                dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
            }, typeof import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof];
        };
        rawMethods: {
            fromPointInPolygonProofs: (...args: [import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof, import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof] & any[]) => GeoPointInOutPolygonCommitment;
            extendWithPointInPolygonProof: (...args: [import("o1js/dist/node/lib/proof_system").SelfProof<undefined, GeoPointInOutPolygonCommitment>, import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof] & any[]) => GeoPointInOutPolygonCommitment;
        };
    } & {
        fromPointInPolygonProofs: (...args: [import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof, import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInOutPolygonCommitment>>;
        extendWithPointInPolygonProof: (...args: [import("o1js/dist/node/lib/proof_system").SelfProof<undefined, GeoPointInOutPolygonCommitment>, import("../../zkprogram/private/GeoPointInPolygonCircuit").GeoPointInPolygonCircuitProof] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInOutPolygonCommitment>>;
    };
    protected static _dependentProofs: (typeof ZKGeoPointInPolygonProof)[];
    constructor(_zkGeoPoint: ZKGeoPoint, _insideProofs: RolledUpZKGeoPointInPolygonCircuitProof, _outsideProofs: RolledUpZKGeoPointInPolygonCircuitProof, _proof: GeoPointInOrOutOfPolygonCircuitProof);
    static fromJSON(jsonProof: JsonProof): IO1JSProof;
    get zkGeoPoint(): ZKGeoPoint;
    get insideProofs(): RolledUpZKGeoPointInPolygonCircuitProof;
    get outsideProofs(): RolledUpZKGeoPointInPolygonCircuitProof;
    get commitment(): GeoPointInOutPolygonCommitment;
    assertGeoPointIsTheClaimedOne(): void;
    assertPolygonsAreTheClaimedOnes(): void;
    verify(): void;
}
