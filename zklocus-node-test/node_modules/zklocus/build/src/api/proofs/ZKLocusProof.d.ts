import { Bool, JsonProof, ZkProgram, Cache } from "o1js";
import type { ZKPublicKey } from "../models/ZKPublicKey";
import { ZKThreePointPolygon } from "../models/ZKThreePointPolygon";
import type { ZKGeoPoint } from "../models/ZKGeoPoint";
import { GeoPointInPolygonCommitment } from "../../model/private/Commitment";
import { ZKProgramCompileResult } from "./Types";
import { OracleAuthenticatedGeoPointCommitment } from "../../model/private/Oracle";
import { ZKProgramCircuit } from "./Types";
import { ICompilableZKLocusProof } from "./Interfaces";
export declare abstract class ZKCommitment {
    protected _commitment: any;
}
/**
 * This class represents a commitment to a ZKGeoPoint being inside or outside a ZKThreePointPolygon.
 * It's an abstraction over the GeoPointInPolygonCommitment class, which is the actual zero-knowledge commitment.
 */
export declare class ZKGeoPointInPolygonCommitment extends ZKCommitment {
    protected _geoPoint: ZKGeoPoint;
    protected _isInPolygon: boolean;
    protected _commitment: GeoPointInPolygonCommitment;
    protected _polygons: ZKThreePointPolygon[];
    constructor(_geoPoint: ZKGeoPoint, polygons: ZKThreePointPolygon[] | ZKThreePointPolygon, _isInPolygon: boolean, _commitment: GeoPointInPolygonCommitment);
    verify(): void;
}
/**
 * Commitment to a GeoPoint being authenticated by an Oracle.
 * This class represents a commitment to a ZKGeoPoint being signed by a ZKPublicKey.
 */
export declare class ZKOracleAuthenticatedGeoPointCommitment extends ZKCommitment {
    protected _commitment: OracleAuthenticatedGeoPointCommitment;
    protected zkGeoPoint: ZKGeoPoint;
    protected zkkPublicKey: ZKPublicKey;
    constructor(geoPoint: ZKGeoPoint, publicKey: ZKPublicKey, commitment: OracleAuthenticatedGeoPointCommitment);
    /**
     * Verify that the commitment corresponds to the claimed GeoPoint and PublicKey.
     * In zkLocus, a commitment to a GeoPoint is the Poseidon hash of the GeoPoint's latitude, longitude and factor,
     * while a commitment to a PublicKey is the Poseidon hash of the PublicKey's field array.
     */
    verify(): void;
}
export declare abstract class ZKLocusProof<P extends InstanceType<ReturnType<typeof ZkProgram.Proof>>> {
    protected _proof: P;
    protected static _circuit: ZKProgramCircuit;
    protected static _compiledCircuit: ZKProgramCompileResult | undefined;
    /**
     * The set of dependent proofs that need to be compiled to enable generation and verification of proofs of this type.
     */
    protected static _dependentProofs: ICompilableZKLocusProof[];
    /**
     * The set of sibling circuits associated with the main circuit. A sibling circuit is a circuit that has the same public output as the main circuit,
     * and extends the main circuit's semanthics and functionality. An example of a sibling circuit is a circuit that provides roll-up functionality
     * for the main circuit.
     *
     * Sibling circuits are compiled alongisde the main circuit.
     */
    protected static _siblingCircuits: ZKProgramCircuit[];
    protected static _compiledSiblingCircuits: ZKProgramCompileResult[];
    verify(): void;
    verifyIf(condition: Bool): void;
    toJSON(): JsonProof;
    /**
     * Compiles the circuit associated with this proof. A ceche is used to store the compiled circuit & keys, so that it doesn't have to be
     * recompiled every time. Once a circuit has been compiled within the scope of an execution, it does not need to be recompiled again.
     *
     * @param cache - The cache to use for compilation. Defaults to Cache.FileSystemDefault.
     * @param forceRecompile - Whether to force recompilation even if the circuit is already compiled. Defaults to false.
     * @returns A promise that resolves to an object containing the verification key data and hash.
     */
    static compile(cache?: Cache | undefined, forceRecompile?: boolean): Promise<ZKProgramCompileResult>;
    static get isCompiled(): boolean;
    static get compiledCircuit(): ZKProgramCompileResult | undefined;
    /**
     * The set of dependent proofs that need to be compiled to enable generation and verification of proofs of this type.
     */
    static get dependentProofs(): ICompilableZKLocusProof[];
    get proof(): P;
}
