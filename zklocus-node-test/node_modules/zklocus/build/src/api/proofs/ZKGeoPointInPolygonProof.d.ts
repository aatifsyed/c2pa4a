import { Field, JsonProof } from "o1js";
import { GeoPointInPolygonCircuitProof, GeoPointInPolygonCombinerCircuitProof } from "../../zkprogram/private/GeoPointInPolygonCircuit";
import type { ZKThreePointPolygon } from "../models/ZKThreePointPolygon";
import { ZKGeoPoint } from "../models/ZKGeoPoint";
import { GeoPointInPolygonCommitment } from "../../model/private/Commitment";
import { IO1JSProof } from "./Types";
import { ZKLocusProof } from "./ZKLocusProof";
import { ZKProgramCircuit } from "./Types";
import { ZKGeoPointProviderCircuitProof } from "./ZKGeoPointProviderCircuitProof";
import type { ICloneableProof } from "./Interfaces";
export type UnverifiedProofDataType = {
    geoPoint: ZKGeoPoint;
    threePointPolygon: ZKThreePointPolygon | undefined;
    isInside: boolean;
    get zkGeoPoint(): ZKGeoPoint;
    get zkPolygon(): ZKThreePointPolygon | undefined;
    get isGeoPointInsidePolygon(): boolean;
};
export declare enum GeoPointInPolygonCombinationOperator {
    NONE = "NONE",
    AND = "AND",
    OR = "OR"
}
export type CombinedPolygonProof = {
    operator: GeoPointInPolygonCombinationOperator;
    proof: GeoPointInPolygonCircuitProof;
    polygon: ZKThreePointPolygon;
};
/**
 * Represents a proof that a ZKGeoPoint is inside a ZKThreePointPolygon in a zero-knowledge circuit.
 * This class allows representation of both a single Point In Polygon Proof, and a combination of such proofs
 * using logical AND and OR operators. It encapsulates the logic for combining and verifying these proofs.
 */
export declare class ZKGeoPointInPolygonProof extends ZKLocusProof<GeoPointInPolygonCircuitProof | GeoPointInPolygonCombinerCircuitProof> implements ICloneableProof<ZKGeoPointInPolygonProof> {
    /**
     * The geo point for which the proof is constructed.
    */
    protected geoPoint: ZKGeoPoint;
    /**
     * The three-point polygon within which the geo point's presence is being proved. If the proof is a combination of proofs,
     * the polygon is undefined, since the proof represents a combination of multiple polygons.
     *
     * Not the biggest fan of having an optional attribute here, but it allows to iterate quickly.
    */
    protected threePointPolygon: ZKThreePointPolygon | undefined;
    /**
     * Indicates whether the geo point is inside the polygon.
     */
    protected _isInside: boolean;
    protected _leftZKProof: ZKGeoPointInPolygonProof | undefined;
    protected _rightZKProof: ZKGeoPointInPolygonProof | undefined;
    protected _operator: GeoPointInPolygonCombinationOperator;
    get leftZKProof(): ZKGeoPointInPolygonProof | undefined;
    get rightZKProof(): ZKGeoPointInPolygonProof | undefined;
    get operator(): GeoPointInPolygonCombinationOperator;
    /**
     * Provides access to the unverified data used in the proof. This includes the geo point, the polygon, and the result
     * of whether the geo point is inside the polygon.
     */
    readonly UnverifiedProofData: UnverifiedProofDataType;
    /**
     * The Zero-Knowledge O1JS circuit used for the point in polygon proof.
     */
    protected static _circuit: ZKProgramCircuit;
    /**
     * An array of dependent proofs required by this proof.
     */
    protected static _dependentProofs: (typeof ZKGeoPointProviderCircuitProof)[];
    protected static _siblingCircuits: ({
        name: string;
        compile: (options?: {
            cache?: import("o1js/dist/node/lib/proof-system/cache").Cache | undefined;
            forceRecompile?: boolean | undefined;
        } | undefined) => Promise<{
            verificationKey: {
                data: string;
                hash: import("o1js/dist/node/lib/field").Field;
            };
        }>;
        verify: (proof: import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>) => Promise<boolean>;
        digest: () => string;
        analyzeMethods: () => {
            AND: {
                rows: number;
                digest: string;
                result: unknown;
                gates: import("o1js/dist/node/snarky").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
            };
            OR: {
                rows: number;
                digest: string;
                result: unknown;
                gates: import("o1js/dist/node/snarky").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
            };
        };
        publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
        publicOutputType: typeof GeoPointInPolygonCommitment;
        privateInputTypes: {
            AND: [typeof GeoPointInPolygonCircuitProof, typeof GeoPointInPolygonCircuitProof];
            OR: [typeof GeoPointInPolygonCircuitProof, typeof GeoPointInPolygonCircuitProof];
        };
        rawMethods: {
            AND: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => GeoPointInPolygonCommitment;
            OR: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => GeoPointInPolygonCommitment;
        };
    } & {
        AND: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>>;
        OR: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>>;
    })[];
    /**
     * Constructs a ZKGeoPointInPolygonProof instance. It can represent a single proof or a combination of proofs using AND and OR operations.
     * @param geoPoint - The geo point for which the proof is constructed.
     * @param polygon - The polygon within which the geo point's presence is being proved.
     * @param proof - The base proof or the primary proof before combining with others.
     * @param andProofs - (Optional) Array of proofs to be combined with the base proof using the AND operator.
     * @param orProofs - (Optional) Array of proofs to be combined with the base proof using the OR operator.
     */
    constructor({ geoPoint, proof, polygon, leftProof, rightProof, operator }: {
        geoPoint: ZKGeoPoint;
        proof: GeoPointInPolygonCircuitProof;
        polygon?: ZKThreePointPolygon;
        leftProof?: ZKGeoPointInPolygonProof;
        rightProof?: ZKGeoPointInPolygonProof;
        operator?: GeoPointInPolygonCombinationOperator;
    });
    /**
     * Creates a clone of the ZKGeoPointInPolygonProof instance.
     *
     * @returns A new instance of ZKGeoPointInPolygonProof with the same values for the minimal necessary attributes.
     * The cloned proof will be considered identical to the original proof.
     */
    clone(): ZKGeoPointInPolygonProof;
    protected setProof(proof: GeoPointInPolygonCircuitProof): void;
    clearCache(): void;
    /**
     * Performs a Zero-Knowledge AND operation between two ZKGeoPointInPolygonProof instances.
     * This is a zkLocus roll-up operations, which compresses two proofs into a single proof.
     * This enabled the creation of an application chain for zkLocus.
     *
     * @param other - The other ZKGeoPointInPolygonProof instance to perform the AND operation with.
     * @returns A new ZKGeoPointInPolygonProof instance representing the combination of the two proofs.
     */
    AND(other: ZKGeoPointInPolygonProof): Promise<ZKGeoPointInPolygonProof>;
    polygonHash(): Field;
    static fromJSON(jsonProof: JsonProof): IO1JSProof;
    get zkGeoPoint(): ZKGeoPoint;
    get zkPolygon(): ZKThreePointPolygon | undefined;
    get isGeoPointInsidePolygon(): boolean;
    get polygon(): ZKThreePointPolygon | undefined;
    get polygonOrError(): ZKThreePointPolygon;
    /**
     * Asserts that the coordinates and polygon are the claimed ones.
     */
    protected assertVerifyCoordinatesAndPolygonAreTheClaimedOnes(): void;
    verify(): void;
    /**
     * Checks if this ZKGeoPointInPolygonProof is equal to another ZKGeoPointInPolygonProof.
     * @param other The other ZKGeoPointInPolygonProof to compare with.
     * @returns True if the two proofs are equal, false otherwise.
     */
    isEquals(other: ZKGeoPointInPolygonProof): boolean;
}
