var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ZKThreePointPolygon_1;
import ZKThreePointPolygonToThreePointPolygonAdopter from "../adopters/ZKThreePointPolygonToThreePointPolygonAdopter";
import { ZKLatitude } from "./ZKLatitude";
import { ZKLongitude } from "./ZKLongitude";
import { ZKGeoPoint } from "./ZKGeoPoint";
import { Poseidon } from "o1js";
/*
Interface for the ThreePointPolygon zkLocus class. It represents a three point polygon, also refered to as a "geogrpahical area".
*/
let ZKThreePointPolygon = ZKThreePointPolygon_1 = class ZKThreePointPolygon {
    get vertices() {
        return this._vertices;
    }
    constructor(vertex1, vertex2, vertex3) {
        this._vertices = [
            vertex1 instanceof ZKGeoPoint ? vertex1 : new ZKGeoPoint(new ZKLatitude(vertex1.latitude), new ZKLongitude(vertex1.longitude)),
            vertex2 instanceof ZKGeoPoint ? vertex2 : new ZKGeoPoint(new ZKLatitude(vertex2.latitude), new ZKLongitude(vertex2.longitude)),
            vertex3 instanceof ZKGeoPoint ? vertex3 : new ZKGeoPoint(new ZKLatitude(vertex3.latitude), new ZKLongitude(vertex3.longitude))
        ];
        const maximumFactorOfVertices = Math.max(this._vertices[0].factor, this._vertices[1].factor, this._vertices[2].factor);
        for (let i = 0; i < this._vertices.length; i++) {
            this._vertices[i].latitude.increaseFactor(maximumFactorOfVertices);
            this._vertices[i].longitude.increaseFactor(maximumFactorOfVertices);
        }
    }
    /**
     * Gets the maximum factor value among the vertices of the polygon.
     * @returns The maximum factor value.
     */
    get factor() {
        return Math.max(this.vertices[0].factor, this.vertices[1].factor, this.vertices[2].factor);
    }
    isEquals(other) {
        return this.vertices[0].isEquals(other.vertices[0]) &&
            this.vertices[1].isEquals(other.vertices[1]) &&
            this.vertices[2].isEquals(other.vertices[2]);
    }
    hash() {
        return this.toZKValue().hash();
    }
    combinedHash(elements) {
        const allPolygons = [this, ...elements];
        return ZKThreePointPolygon_1.combinedHash(allPolygons);
    }
    static combinedHash(polygons) {
        if (polygons.length === 0) {
            throw new Error('Cannot combine hash of empty array of polygons.');
        }
        const hashes = polygons.map(polygon => polygon.toZKValue().hash());
        if (hashes.length === 1) {
            return hashes[0];
        }
        return Poseidon.hash(hashes);
    }
    static fromThreePointPolygon(threePointPolygon) {
        const vertices = [
            ZKGeoPoint.fromGeoPoint(threePointPolygon.vertice1),
            ZKGeoPoint.fromGeoPoint(threePointPolygon.vertice2),
            ZKGeoPoint.fromGeoPoint(threePointPolygon.vertice3)
        ];
        return new this(vertices[0], vertices[1], vertices[2]);
    }
    toString() {
        return `ZKThreePointPolygon(${this.vertices[0]}, ${this.vertices[1]}, ${this.vertices[2]})`;
    }
};
ZKThreePointPolygon = ZKThreePointPolygon_1 = __decorate([
    ZKThreePointPolygonToThreePointPolygonAdopter,
    __metadata("design:paramtypes", [Object, Object, Object])
], ZKThreePointPolygon);
export { ZKThreePointPolygon };
//# sourceMappingURL=ZKThreePointPolygon.js.map