import { GeoPointProviderCircuit } from "../../zkprogram/private/Geography";
import { GeoPointInPolygonCircuit } from "../../zkprogram/private/GeoPointInPolygonCircuit";
import { OracleGeoPointProviderCircuit } from "../../zkprogram/private/Oracle";
import { ExactGeoPointCircuit } from "../../zkprogram/public/ExactGeoPointCircuit";
import { ExactGeolocationMetadataCircuit } from "../../zkprogram/public/Metadata";
import { SHA3_512 } from "../sha3/SHA3";
import { GeoPointInOrOutOfPolygonCircuit } from "../../zkprogram/private/GeoPointInOrOutOfPolygonCircuit";
/**
 * Enhances a ZKGeoPoint with methods for generating zero-knowledge proofs.
 * @param Base - The ZKGeoPoint class to be augmented.
 * @returns An augmented class with additional zero-knowledge proof capabilities.
 */
export default function (Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.inPolygonProof = {
                insidePolygonProofs: [],
                outsidePolygonProofs: [],
            };
            this.allProfs = [];
            this.Prove = {
                /**
                 * Generates a proof that this point is within a specified polygon.
                 * @param polygon - The polygon within which the point's presence is to be proven.
                 * @returns A promise that resolves to a zero-knowledge proof of the point's presence within the polygon.
                 */
                inPolygon: async (polygon) => {
                    if (this.integrationOracleProof === undefined) {
                        //  TODO: temporary unil we support multiple authentication sources. Let's fail instead of having undefined behaviour with possible security violations
                        throw new Error("Currently, ExactGeoPoint can only be generated for a ZKGeoPoint that has been authenticated from the Oracle. This will be supported in the future.");
                    }
                    const geoPointProof = this.integrationOracleProof.proof;
                    console.log("Proving point in polygon...");
                    const geoPointInPolygonProof = await GeoPointInPolygonCircuit.proveGeoPointIn3PointPolygon(geoPointProof, polygon.toZKValue());
                    console.log("Point in polygon proven!");
                    console.log(geoPointInPolygonProof.publicOutput.toString());
                    console.log(`Provided GeoPoint commitment: ${this.hash()} | Provided Polygon commitment: ${polygon.hash()}`);
                    console.log("Creating ZKGeoPointInPolygonProof...");
                    const { ZKGeoPointInPolygonProof } = await import("../proofs/ZKGeoPointInPolygonProof");
                    const zkPointInPolygonProof = new ZKGeoPointInPolygonProof({
                        geoPoint: this,
                        proof: geoPointInPolygonProof,
                        polygon: polygon,
                    });
                    console.log("ZKGeoPointInPolygonProof created!");
                    console.log("Recording proof...");
                    // record the proof in the appropriate collection, depending on whether the ZKGeoPoint is inside or outside the polygon
                    if (zkPointInPolygonProof.UnverifiedProofData.isInside) {
                        this.inPolygonProof.insidePolygonProofs.push(zkPointInPolygonProof);
                    }
                    else {
                        this.inPolygonProof.outsidePolygonProofs.push(zkPointInPolygonProof);
                    }
                    console.log("Proof recorded!");
                    return zkPointInPolygonProof;
                },
                /**
                 * Combine/compress an arbitrary Point In Polygon proofs into a single one. This exposes the roll-up / application chain functionality of
                 * zkLocus for GeoPoint In Polygon proofs .
                 * @param proofs - The proofs to combine.
                 * @returns A promise that resolves to a single proof that combines all of the provided proofs.
                 */
                combineProofs: async (proofs) => {
                    if (proofs.length < 2) {
                        throw new Error("Cannot combine less than 2 proofs.");
                    }
                    const firstProof = proofs[0];
                    const secondProof = proofs[1];
                    let combinedProof = await firstProof.AND(secondProof);
                    for (const proof of proofs.slice(2)) {
                        combinedProof = await combinedProof.AND(proof);
                    }
                    return combinedProof;
                },
                inPolygons: async (polygons) => {
                    if (polygons.length === 0) {
                        throw new Error("'polygons' must contain at least one polygon.");
                    }
                    const { ZKGeoPointInPolygonProof } = await import("../proofs/ZKGeoPointInPolygonProof");
                    const proofs = [];
                    for (const polygon of polygons) {
                        const proof = await this.Prove.inPolygon(polygon);
                        proofs.push(proof);
                    }
                    return proofs;
                },
                /**
                 * Authenticates the ZKGeoPoint using a signature from an Integration Oracle.
                 * @param publicKey - The public key corresponding to the Oracle's signature.
                 * @param signature - The signature provided by the Integration Oracle.
                 * @returns A promise that resolves to a circuit proof of the point's authentication via the Oracle.
                */
                authenticateFromIntegrationOracle: async (publicKey, signature) => {
                    const plainPublicKey = publicKey.toZKValue();
                    const plainGeoPoint = this.toZKValue();
                    const plainSignature = signature.toZKValue();
                    const oracleSignatureVerificationProof = await OracleGeoPointProviderCircuit.fromSignature(plainPublicKey, plainSignature, plainGeoPoint);
                    const oracleGeoPointProviderProof = await GeoPointProviderCircuit.fromOracle(oracleSignatureVerificationProof, plainGeoPoint);
                    const { ZKGeoPointProviderCircuitProof } = await import("../proofs/ZKGeoPointProviderCircuitProof");
                    this.integrationOracleProof = new ZKGeoPointProviderCircuitProof(oracleGeoPointProviderProof);
                    this.allProfs.push(this.integrationOracleProof);
                    return this.integrationOracleProof;
                },
                /**
                * Generates a zero-knowledge proof of the exact geographical location of the ZKGeoPoint.
                * The behavior changes based on the authentication sources that have been used.
                * @returns A promise that resolves to a zero-knowledge proof of the exact location.
                */
                exactGeoPoint: async () => {
                    // Conditional logic based on the set of authentication sources
                    if (this.integrationOracleProof === null) {
                        //  TODO: temporary unil we support multiple authentication sources. Let's fail instead of having undefined behaviour with possible security violations
                        throw new Error("Currently, ExactGeoPoint can only be generated for a ZKGeoPoint that has been authenticated from exactly one source. This will be supported in the future.");
                    }
                    if (this.integrationOracleProof !== null) {
                        return this.exactGeoPointForIntegrationOracle();
                    }
                    else {
                        throw new Error("Unsupported or unknown authentication source(s) for exactGeoPoint.");
                    }
                },
                /**
                 * Attaches metadata to the ZKGeoPoint. This is only supported for ZKGeoPoints that have been obtained in a supported manner, such
                 * as being provided by an Integration Oracle circuit.
                 *
                 * Metadata is attached to the GeoPoint in the following manner:
                 * 1. [Non-Verifiable] The metadata is hashed using SHA3-512
                 * 2. [Non-Verifiable] The hash is converted into a Field-compatible representation, by using `Bytes64`
                 * 3. [Verifiable] The converted hash is provided as ap private intput to the Zero-Knowledge circuit that will attach it to/commit to a GeoPoint
                 * 4. [Verifiable] The converted hash is hashed again using Poseidon and that value is cyrpotgraphically committed to the GeoPoint.
                 *
                 * Given that a cryptographic commitment is created to a commitment to metadata, a cryptographic commitment is created to the metadata itself.
                 *
                 * As such, attaching an arbitrary string of metadata involves hashing that metadata using SHA3-512, providing that hash to a Zero-Knowledge circuit in
                 * a verifiable manner, and then hashing that hash again inside the circuit using Poseidon, thus committing to it in a verifiable manner.
                 * @param metadata - The metadata to attach to the ZKGeoPoint.
                 * @returns A promise that resolves to a zero-knowledge proof of the exact location and metadata.
                 */
                attachMetadata: async (metadata) => {
                    if (this.integrationOracleProof === undefined) {
                        throw new Error("In order to attach metadata to a ZKGeoPoint, it must be authenticated from an Integration Oracle. Currently, this is the only supported authentication source, but will be expanded in the future.");
                    }
                    const sha3_512 = new SHA3_512(metadata);
                    const sha3_512_digest = sha3_512.digest;
                    const exactGeolocationMetadataProof = await ExactGeolocationMetadataCircuit.attachMetadataToGeoPoint(this.integrationOracleProof.proof, sha3_512_digest);
                    const { ZKExactGeolocationMetadataCircuitProof } = await import("../proofs/ZKExactGeolocationMetadataCircuitProof");
                    this.exactGeolocationMetadataProof = new ZKExactGeolocationMetadataCircuitProof(this, metadata, exactGeolocationMetadataProof);
                    return this.exactGeolocationMetadataProof;
                },
                combinePointInPolygonProofs: async () => {
                    if (this.inPolygonProof.insidePolygonProofs.length === 0) {
                        throw new Error("Cannot combine proofs for a ZKGeoPoint that has not been proven to be inside of any polygons. It's requied to have both, inside and outside polygon proofs. If you only have one set, you can combine them together with .AND and/or .OR methods.");
                    }
                    if (this.inPolygonProof.outsidePolygonProofs.length === 0) {
                        throw new Error("Cannot combine proofs for a ZKGeoPoint that has not been proven to be outside of any polygons. It's requied to have both, inside and outside polygon proofs. If you only have one set, you can combine them together with .AND and/or .OR methods.");
                    }
                    const insidePolygonProofs = this.inPolygonProof.insidePolygonProofs;
                    const outsidePolygonProofs = this.inPolygonProof.outsidePolygonProofs;
                    let rolledUpInsidePolygonProofs;
                    if (insidePolygonProofs.length === 1) {
                        rolledUpInsidePolygonProofs = insidePolygonProofs[0];
                    }
                    else {
                        rolledUpInsidePolygonProofs = await this.Prove.combineProofs(insidePolygonProofs);
                    }
                    let rolledUpOutsidePolygonProofs;
                    if (outsidePolygonProofs.length === 1) {
                        rolledUpOutsidePolygonProofs = outsidePolygonProofs[0];
                    }
                    else {
                        rolledUpOutsidePolygonProofs = await this.Prove.combineProofs(outsidePolygonProofs);
                    }
                    const { RolledUpZKGeoPointInPolygonCircuitProof } = await import("../proofs/ZKGeoPointInOrOutOfPolygonCircuitProof");
                    const insideRollUpDTO = new RolledUpZKGeoPointInPolygonCircuitProof(insidePolygonProofs, rolledUpInsidePolygonProofs);
                    const outsideRollUpDTO = new RolledUpZKGeoPointInPolygonCircuitProof(outsidePolygonProofs, rolledUpOutsidePolygonProofs);
                    const proof = await GeoPointInOrOutOfPolygonCircuit.fromPointInPolygonProofs(rolledUpInsidePolygonProofs.proof, rolledUpOutsidePolygonProofs.proof);
                    const { ZKGeoPointInOrOutOfPolygonCircuitProof } = await import("../proofs/ZKGeoPointInOrOutOfPolygonCircuitProof");
                    const zkProof = new ZKGeoPointInOrOutOfPolygonCircuitProof(this, insideRollUpDTO, outsideRollUpDTO, proof);
                    return zkProof;
                }
            };
        }
        getIntegrationOracleProofOrError() {
            if (this.integrationOracleProof === undefined) {
                throw new Error("Integration Oracle proof is not available. Please call authenticateFromIntegrationOracle first.");
            }
            return this.integrationOracleProof;
        }
        async exactGeoPointForIntegrationOracle() {
            const oracleProof = this.getIntegrationOracleProofOrError();
            const rawProof = oracleProof.proof;
            const rawExactGeoPointProof = await ExactGeoPointCircuit.fromGeoPointProvider(rawProof);
            const { ZKExactGeoPointCircuitProof } = await import("../proofs/ZKExactGeoPointCircuitProof");
            const zkExactGeoPointProof = new ZKExactGeoPointCircuitProof(this, rawExactGeoPointProof);
            return zkExactGeoPointProof;
        }
    };
}
//# sourceMappingURL=ZKGeoPointProver.js.map