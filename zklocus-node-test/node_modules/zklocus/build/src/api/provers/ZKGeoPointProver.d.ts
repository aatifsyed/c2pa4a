import type { ZKSignature } from "../models/ZKSignature";
import type { ZKPublicKey } from "../models/ZKPublicKey";
import type { ZKThreePointPolygon } from "../models/ZKThreePointPolygon";
import type { GeoPoint } from "../../model/Geography";
import type { ZKExactGeoPointCircuitProof } from "../proofs/ZKExactGeoPointCircuitProof";
import type { ZKGeoPointInPolygonProof } from "../proofs/ZKGeoPointInPolygonProof";
import type { ZKGeoPointProviderCircuitProof } from "../proofs/ZKGeoPointProviderCircuitProof";
import type { ZKExactGeolocationMetadataCircuitProof } from "../proofs/ZKExactGeolocationMetadataCircuitProof";
import { ZKGeoPointConstructor } from "./IZKGeoPointProver";
import type { ZKGeoPointInOrOutOfPolygonCircuitProof } from "../proofs/ZKGeoPointInOrOutOfPolygonCircuitProof";
import type { ZKLocusProof } from "../proofs/ZKLocusProof";
type PolygonProofs = {
    insidePolygonProofs: ZKGeoPointInPolygonProof[];
    outsidePolygonProofs: ZKGeoPointInPolygonProof[];
};
/**
 * Enhances a ZKGeoPoint with methods for generating zero-knowledge proofs.
 * @param Base - The ZKGeoPoint class to be augmented.
 * @returns An augmented class with additional zero-knowledge proof capabilities.
 */
export default function <T extends ZKGeoPointConstructor>(Base: T): {
    new (...args: any[]): {
        /**
         * The proof that the point is authenticated by an Integration Oracle. This is set by the authenticateFromIntegrationOracle method.
         * If this is null, then the point has not been authenticated by an Integration Oracle. Once the method is called, this will be set.
         */
        integrationOracleProof: ZKGeoPointProviderCircuitProof | undefined;
        /**
         * The proof that the point is authenticated by an Integration Oracle and has associated metadata. This is set by the attachMetadata method.
         * If this is null, then the point has not been authenticated by an Integration Oracle and has no associated metadata. Once the method is called, this will be set.
         */
        exactGeolocationMetadataProof: ZKExactGeolocationMetadataCircuitProof | undefined;
        inPolygonProof: PolygonProofs;
        allProfs: ZKLocusProof<any>[];
        getIntegrationOracleProofOrError(): ZKGeoPointProviderCircuitProof;
        Prove: {
            /**
             * Generates a proof that this point is within a specified polygon.
             * @param polygon - The polygon within which the point's presence is to be proven.
             * @returns A promise that resolves to a zero-knowledge proof of the point's presence within the polygon.
             */
            inPolygon: (polygon: ZKThreePointPolygon) => Promise<ZKGeoPointInPolygonProof>;
            /**
             * Combine/compress an arbitrary Point In Polygon proofs into a single one. This exposes the roll-up / application chain functionality of
             * zkLocus for GeoPoint In Polygon proofs .
             * @param proofs - The proofs to combine.
             * @returns A promise that resolves to a single proof that combines all of the provided proofs.
             */
            combineProofs: (proofs: ZKGeoPointInPolygonProof[]) => Promise<ZKGeoPointInPolygonProof>;
            inPolygons: (polygons: ZKThreePointPolygon[]) => Promise<ZKGeoPointInPolygonProof[]>;
            /**
             * Authenticates the ZKGeoPoint using a signature from an Integration Oracle.
             * @param publicKey - The public key corresponding to the Oracle's signature.
             * @param signature - The signature provided by the Integration Oracle.
             * @returns A promise that resolves to a circuit proof of the point's authentication via the Oracle.
            */
            authenticateFromIntegrationOracle: (publicKey: ZKPublicKey, signature: ZKSignature) => Promise<ZKGeoPointProviderCircuitProof>;
            /**
            * Generates a zero-knowledge proof of the exact geographical location of the ZKGeoPoint.
            * The behavior changes based on the authentication sources that have been used.
            * @returns A promise that resolves to a zero-knowledge proof of the exact location.
            */
            exactGeoPoint: () => Promise<ZKExactGeoPointCircuitProof>;
            /**
             * Attaches metadata to the ZKGeoPoint. This is only supported for ZKGeoPoints that have been obtained in a supported manner, such
             * as being provided by an Integration Oracle circuit.
             *
             * Metadata is attached to the GeoPoint in the following manner:
             * 1. [Non-Verifiable] The metadata is hashed using SHA3-512
             * 2. [Non-Verifiable] The hash is converted into a Field-compatible representation, by using `Bytes64`
             * 3. [Verifiable] The converted hash is provided as ap private intput to the Zero-Knowledge circuit that will attach it to/commit to a GeoPoint
             * 4. [Verifiable] The converted hash is hashed again using Poseidon and that value is cyrpotgraphically committed to the GeoPoint.
             *
             * Given that a cryptographic commitment is created to a commitment to metadata, a cryptographic commitment is created to the metadata itself.
             *
             * As such, attaching an arbitrary string of metadata involves hashing that metadata using SHA3-512, providing that hash to a Zero-Knowledge circuit in
             * a verifiable manner, and then hashing that hash again inside the circuit using Poseidon, thus committing to it in a verifiable manner.
             * @param metadata - The metadata to attach to the ZKGeoPoint.
             * @returns A promise that resolves to a zero-knowledge proof of the exact location and metadata.
             */
            attachMetadata: (metadata: string) => Promise<ZKExactGeolocationMetadataCircuitProof>;
            combinePointInPolygonProofs: () => Promise<ZKGeoPointInOrOutOfPolygonCircuitProof>;
        };
        exactGeoPointForIntegrationOracle(): Promise<ZKExactGeoPointCircuitProof>;
        _latitude: import("../models/ZKLatitude").ZKLatitude;
        _longitude: import("../models/ZKLongitude").ZKLongitude;
        _rawValue: {
            latitude: import("../Types").InputNumber | import("../models/ZKLatitude").ZKLatitude;
            longitude: import("../Types").InputNumber | import("../models/ZKLongitude").ZKLongitude;
        };
        readonly latitude: import("../models/ZKLatitude").ZKLatitude;
        readonly longitude: import("../models/ZKLongitude").ZKLongitude;
        readonly asRawValue: {
            latitude: import("../Types").InputNumber | import("../models/ZKLatitude").ZKLatitude;
            longitude: import("../Types").InputNumber | import("../models/ZKLongitude").ZKLongitude;
        }; /**
         * The proof that the point is authenticated by an Integration Oracle. This is set by the authenticateFromIntegrationOracle method.
         * If this is null, then the point has not been authenticated by an Integration Oracle. Once the method is called, this will be set.
         */
        readonly factor: number;
        isEquals(other: import("../..").ZKGeoPoint): boolean;
        toString(): string;
        hash(): import("o1js/dist/node/lib/field").Field;
        combinedHash(elements: import("../..").ZKGeoPoint[]): import("o1js/dist/node/lib/field").Field;
        combinedHash(otherElements: import("../..").ZKGeoPoint[]): import("o1js/dist/node/lib/field").Field;
        rawValue(): {
            latitude: import("../Types").InputNumber | import("../models/ZKLatitude").ZKLatitude;
            longitude: import("../Types").InputNumber | import("../models/ZKLongitude").ZKLongitude;
        };
        normalizedValue(): {
            latitude: import("../models/ZKLatitude").ZKLatitude;
            longitude: import("../models/ZKLongitude").ZKLongitude;
            factor: import("../models/ZKNumber").ZKNumber;
        };
        toZKValue(): GeoPoint;
    };
} & T;
export {};
