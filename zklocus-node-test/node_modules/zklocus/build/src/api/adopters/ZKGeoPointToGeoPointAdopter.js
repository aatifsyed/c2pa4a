/*
    This file defines the Adaptor that converts a ZKGeoPoint to a GeoPoint.

    It's defined in a separate file and exported as a default export, due to TS4094 which presents issues
    when an exported class experssion contains private or protected members. The approach followed in this file
    serves as a workaround for this issue.

    See: https://github.com/microsoft/TypeScript/issues/30355
*/
import { Int64, Poseidon } from "o1js";
import { ZKLatitude } from "../models/ZKLatitude";
import { ZKLongitude } from "../models/ZKLongitude";
import { ZKNumber } from "../models/ZKNumber";
import { GeoPoint } from "../../model/Geography";
export default function (Base) {
    return class extends Base {
        rawValue() {
            return this.asRawValue;
        }
        normalizedValue() {
            const factor = new ZKNumber(this.factor);
            const latitude = new ZKLatitude(this.latitude.normalized);
            const longitude = new ZKLongitude(this.longitude.normalized);
            const maximumFactor = Math.max(latitude.factor, longitude.factor);
            console.log('Latitude factor: ' + latitude.factor);
            console.log('Longitude factor: ' + longitude.factor);
            console.log('Maximum factor: ' + maximumFactor);
            latitude.increaseFactor(maximumFactor);
            longitude.increaseFactor(maximumFactor);
            return {
                latitude,
                longitude,
                factor,
            };
        }
        /**
         * Converts the abstracted zkLocus API representation into the raw underlying O1JS value used directly within the Zero-Knowledge circuits of zkLocus.
         * Every call results in a new object.
         * @returns {GeoPoint} The converted GeoPoint object.
         */
        toZKValue() {
            const latitudeInt64 = Int64.from(this.latitude.scaled);
            const longitudeInt64 = Int64.from(this.longitude.scaled);
            const factorInt64 = Int64.from(this.factor);
            return new GeoPoint({
                latitude: latitudeInt64,
                longitude: longitudeInt64,
                factor: factorInt64,
            });
        }
        hash() {
            return this.toZKValue().hash();
        }
        static combinedHash(elements) {
            const hashes = elements.map(element => element.toZKValue().hash());
            return Poseidon.hash(hashes);
        }
        combinedHash(otherElements) {
            const allPoints = [this, ...otherElements];
            return this.combinedHash(allPoints);
        }
        ;
    };
}
//# sourceMappingURL=ZKGeoPointToGeoPointAdopter.js.map