import { Field } from "o1js";
import { InputNumber } from "../Types";
import { ZKLatitude } from "../models/ZKLatitude";
import type { ZKGeoPoint } from "../models/ZKGeoPoint";
import { ZKLongitude } from "../models/ZKLongitude";
import { ZKNumber } from "../models/ZKNumber";
import { GeoPoint } from "../../model/Geography";
export type ZKGeoPointConstructor = new (...args: any[]) => ZKGeoPoint;
export default function <T extends ZKGeoPointConstructor>(Base: T): {
    new (...args: any[]): {
        rawValue(): {
            latitude: InputNumber | ZKLatitude;
            longitude: InputNumber | ZKLongitude;
        };
        normalizedValue(): {
            latitude: ZKLatitude;
            longitude: ZKLongitude;
            factor: ZKNumber;
        };
        /**
         * Converts the abstracted zkLocus API representation into the raw underlying O1JS value used directly within the Zero-Knowledge circuits of zkLocus.
         * Every call results in a new object.
         * @returns {GeoPoint} The converted GeoPoint object.
         */
        toZKValue(): GeoPoint;
        hash(): Field;
        combinedHash(otherElements: ZKGeoPoint[]): Field;
        _latitude: ZKLatitude;
        _longitude: ZKLongitude;
        _rawValue: {
            latitude: InputNumber | ZKLatitude;
            longitude: InputNumber | ZKLongitude;
        };
        readonly latitude: ZKLatitude;
        readonly longitude: ZKLongitude;
        readonly asRawValue: {
            latitude: InputNumber | ZKLatitude;
            longitude: InputNumber | ZKLongitude;
        }; /**
         * Converts the abstracted zkLocus API representation into the raw underlying O1JS value used directly within the Zero-Knowledge circuits of zkLocus.
         * Every call results in a new object.
         * @returns {GeoPoint} The converted GeoPoint object.
         */
        readonly factor: number;
        isEquals(other: ZKGeoPoint): boolean;
        toString(): string;
        Prove: {
            inPolygon: (polygon: import("../..").ZKThreePointPolygon) => Promise<import("../..").ZKGeoPointInPolygonProof>;
            inPolygons: (polygons: import("../..").ZKThreePointPolygon[]) => Promise<import("../..").ZKGeoPointInPolygonProof[]>;
            combineProofs: (proofs: import("../..").ZKGeoPointInPolygonProof[]) => Promise<import("../..").ZKGeoPointInPolygonProof>;
            combinePointInPolygonProofs: () => Promise<import("../proofs/ZKGeoPointInOrOutOfPolygonCircuitProof").ZKGeoPointInOrOutOfPolygonCircuitProof>;
            authenticateFromIntegrationOracle: (publicKey: import("../..").ZKPublicKey, signature: import("../..").ZKSignature) => Promise<import("../proofs/ZKGeoPointProviderCircuitProof").ZKGeoPointProviderCircuitProof>;
            exactGeoPoint: () => Promise<import("../..").ZKExactGeoPointCircuitProof>;
            attachMetadata: (metadata: string) => Promise<import("../..").ZKExactGeolocationMetadataCircuitProof>;
        };
    };
    combinedHash(elements: ZKGeoPoint[]): Field;
} & T;
