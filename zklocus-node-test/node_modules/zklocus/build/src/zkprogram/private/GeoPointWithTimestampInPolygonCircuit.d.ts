import { SelfProof } from "o1js";
import { GeoPointWithTimeStampIntervalInPolygonCommitment } from '../../model/private/Commitment';
import { TimeStampInterval } from "../../model/Time";
import { GeoPointInPolygonCircuitProof } from "./GeoPointInPolygonCircuit";
import { TimeStampIntervalProviderCircuitProof } from "./Geography";
/**
 * Set of ZK circuits responsible for attaching a timestamp to a GeoPoint in Polygon proof.
 * The source of the timestamp is attested by the proof from where the timestamp is sourced.
 *
 * The means by which the timestamp is attached to the GeoPoint in Polygon proof is by
 * adding the timestamp to the GeoPoint in Polygon proof's public output. This follows the
 * architectural approach that I have developed as a part of developing zkLocus, and it consists
 * of "attaching" data to a proof.
 *
 *    IMPORTANT: This is a prototype, which was implemenented to demonstrate feasiablity.
 *         This is not a final implementation, and should not be used in production.
 */
export declare const GeoPointWithTimestampInPolygonCircuit: {
    name: string;
    compile: (options?: {
        cache?: import("o1js/dist/node/lib/proof-system/cache").Cache | undefined;
        forceRecompile?: boolean | undefined;
    } | undefined) => Promise<{
        verificationKey: {
            data: string;
            hash: import("o1js/dist/node/lib/field").Field;
        };
    }>;
    verify: (proof: import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>) => Promise<boolean>;
    digest: () => string;
    analyzeMethods: () => {
        proofAttachProvidedTimestampinterval: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
        increaseTimeStampInterval: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
        increaseTimeStampIntervalRecursive: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
        AND: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
        OR: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
    };
    publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
    publicOutputType: typeof GeoPointWithTimeStampIntervalInPolygonCommitment;
    privateInputTypes: {
        proofAttachProvidedTimestampinterval: [typeof GeoPointInPolygonCircuitProof, typeof TimeStampIntervalProviderCircuitProof];
        increaseTimeStampInterval: [typeof GeoPointWithTimeStampIntervalInPolygonCommitment, typeof TimeStampInterval];
        increaseTimeStampIntervalRecursive: [{
            new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
                proof: unknown;
                publicInput: undefined;
                publicOutput: GeoPointWithTimeStampIntervalInPolygonCommitment;
                maxProofsVerified: 0 | 1 | 2;
            }): SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>;
            publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
            fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
                publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                tag: () => {
                    name: string;
                };
                fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
                dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
            } & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
            }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
            dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
        }, typeof TimeStampInterval];
        AND: [{
            new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
                proof: unknown;
                publicInput: undefined;
                publicOutput: GeoPointWithTimeStampIntervalInPolygonCommitment;
                maxProofsVerified: 0 | 1 | 2;
            }): SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>;
            publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
            fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
                publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                tag: () => {
                    name: string;
                };
                fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
                dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
            } & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
            }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
            dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
        }, {
            new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
                proof: unknown;
                publicInput: undefined;
                publicOutput: GeoPointWithTimeStampIntervalInPolygonCommitment;
                maxProofsVerified: 0 | 1 | 2;
            }): SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>;
            publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
            fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
                publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                tag: () => {
                    name: string;
                };
                fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
                dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
            } & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
            }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
            dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
        }];
        OR: [{
            new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
                proof: unknown;
                publicInput: undefined;
                publicOutput: GeoPointWithTimeStampIntervalInPolygonCommitment;
                maxProofsVerified: 0 | 1 | 2;
            }): SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>;
            publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
            fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
                publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                tag: () => {
                    name: string;
                };
                fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
                dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
            } & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
            }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
            dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
        }, {
            new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
                proof: unknown;
                publicInput: undefined;
                publicOutput: GeoPointWithTimeStampIntervalInPolygonCommitment;
                maxProofsVerified: 0 | 1 | 2;
            }): SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>;
            publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
            fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
                publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
                tag: () => {
                    name: string;
                };
                fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
                dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
            } & {
                prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
            }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
            dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
        }];
    };
    rawMethods: {
        proofAttachProvidedTimestampinterval: (...args: [GeoPointInPolygonCircuitProof, TimeStampIntervalProviderCircuitProof] & any[]) => GeoPointWithTimeStampIntervalInPolygonCommitment;
        increaseTimeStampInterval: (...args: [GeoPointWithTimeStampIntervalInPolygonCommitment, TimeStampInterval] & any[]) => GeoPointWithTimeStampIntervalInPolygonCommitment;
        increaseTimeStampIntervalRecursive: (...args: [SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>, TimeStampInterval] & any[]) => GeoPointWithTimeStampIntervalInPolygonCommitment;
        AND: (...args: [SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>, SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>] & any[]) => GeoPointWithTimeStampIntervalInPolygonCommitment;
        OR: (...args: [SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>, SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>] & any[]) => GeoPointWithTimeStampIntervalInPolygonCommitment;
    };
} & {
    proofAttachProvidedTimestampinterval: (...args: [GeoPointInPolygonCircuitProof, TimeStampIntervalProviderCircuitProof] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>>;
    increaseTimeStampInterval: (...args: [GeoPointWithTimeStampIntervalInPolygonCommitment, TimeStampInterval] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>>;
    increaseTimeStampIntervalRecursive: (...args: [SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>, TimeStampInterval] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>>;
    AND: (...args: [SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>, SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>>;
    OR: (...args: [SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>, SelfProof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointWithTimeStampIntervalInPolygonCommitment>>;
};
