import { GeoPointInPolygonCommitment } from '../../model/private/Commitment';
import { ThreePointPolygon } from '../../model/Geography';
import { GeoPointProviderCircuitProof } from "./Geography";
/**
 * Set of ZK circuts responsible for verifying that a geographical point is within a polygon,
 * and contains the logic for combining multiple proofs into a single one.
 *
 * The source of the geographical point is attested by the proof from where the point is sourced.
 */
export declare const GeoPointInPolygonCircuit: {
    name: string;
    compile: (options?: {
        cache?: import("o1js/dist/node/lib/proof-system/cache").Cache | undefined;
        forceRecompile?: boolean | undefined;
    } | undefined) => Promise<{
        verificationKey: {
            data: string;
            hash: import("o1js/dist/node/lib/field").Field;
        };
    }>;
    verify: (proof: import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>) => Promise<boolean>;
    digest: () => string;
    analyzeMethods: () => {
        proveGeoPointIn3PointPolygon: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
    };
    publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
    publicOutputType: typeof GeoPointInPolygonCommitment;
    privateInputTypes: {
        proveGeoPointIn3PointPolygon: [typeof GeoPointProviderCircuitProof, typeof ThreePointPolygon];
    };
    rawMethods: {
        proveGeoPointIn3PointPolygon: (...args: [GeoPointProviderCircuitProof, ThreePointPolygon] & any[]) => GeoPointInPolygonCommitment;
    };
} & {
    proveGeoPointIn3PointPolygon: (...args: [GeoPointProviderCircuitProof, ThreePointPolygon] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>>;
};
declare const GeoPointInPolygonCircuitProof_base: {
    new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
        proof: unknown;
        publicInput: undefined;
        publicOutput: GeoPointInPolygonCommitment;
        maxProofsVerified: 0 | 1 | 2;
    }): {
        publicInput: undefined;
        publicOutput: GeoPointInPolygonCommitment;
        proof: unknown;
        maxProofsVerified: 0 | 1 | 2;
        shouldVerify: import("o1js/dist/node/lib/bool").Bool;
        verify(): void;
        verifyIf(condition: import("o1js/dist/node/lib/bool").Bool): void;
        toJSON(): import("o1js/dist/node/lib/proof_system").JsonProof;
    };
    publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
    publicOutputType: typeof GeoPointInPolygonCommitment;
    tag: () => {
        name: string;
        publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
        publicOutputType: typeof GeoPointInPolygonCommitment;
    };
    fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
        prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
        publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
        publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
        tag: () => {
            name: string;
        };
        fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
        dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
    } & {
        prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
    }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
    dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
};
export declare class GeoPointInPolygonCircuitProof extends GeoPointInPolygonCircuitProof_base {
}
export declare const GeoPointInPolygonCombinerCircuit: {
    name: string;
    compile: (options?: {
        cache?: import("o1js/dist/node/lib/proof-system/cache").Cache | undefined;
        forceRecompile?: boolean | undefined;
    } | undefined) => Promise<{
        verificationKey: {
            data: string;
            hash: import("o1js/dist/node/lib/field").Field;
        };
    }>;
    verify: (proof: import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>) => Promise<boolean>;
    digest: () => string;
    analyzeMethods: () => {
        AND: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
        OR: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
    };
    publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
    publicOutputType: typeof GeoPointInPolygonCommitment;
    privateInputTypes: {
        AND: [typeof GeoPointInPolygonCircuitProof, typeof GeoPointInPolygonCircuitProof];
        OR: [typeof GeoPointInPolygonCircuitProof, typeof GeoPointInPolygonCircuitProof];
    };
    rawMethods: {
        AND: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => GeoPointInPolygonCommitment;
        OR: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => GeoPointInPolygonCommitment;
    };
} & {
    AND: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>>;
    OR: (...args: [GeoPointInPolygonCircuitProof, GeoPointInPolygonCircuitProof] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<undefined, GeoPointInPolygonCommitment>>;
};
declare const GeoPointInPolygonCombinerCircuitProof_base: {
    new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
        proof: unknown;
        publicInput: undefined;
        publicOutput: GeoPointInPolygonCommitment;
        maxProofsVerified: 0 | 1 | 2;
    }): {
        publicInput: undefined;
        publicOutput: GeoPointInPolygonCommitment;
        proof: unknown;
        maxProofsVerified: 0 | 1 | 2;
        shouldVerify: import("o1js/dist/node/lib/bool").Bool;
        verify(): void;
        verifyIf(condition: import("o1js/dist/node/lib/bool").Bool): void;
        toJSON(): import("o1js/dist/node/lib/proof_system").JsonProof;
    };
    publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
    publicOutputType: typeof GeoPointInPolygonCommitment;
    tag: () => {
        name: string;
        publicInputType: import("o1js/dist/node/lib/circuit_value").ProvablePureExtended<undefined, null>;
        publicOutputType: typeof GeoPointInPolygonCommitment;
    };
    fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
        prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
        publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
        publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
        tag: () => {
            name: string;
        };
        fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
        dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
    } & {
        prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
    }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
    dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
};
export declare class GeoPointInPolygonCombinerCircuitProof extends GeoPointInPolygonCombinerCircuitProof_base {
}
export {};
