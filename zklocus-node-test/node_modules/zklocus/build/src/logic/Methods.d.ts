import { SelfProof, Empty } from "o1js";
import { GeoPoint, ThreePointPolygon } from '../model/Geography';
import { GeoPointInOutPolygonCommitment, GeoPointInPolygonCommitment, GeoPointWithTimeStampIntervalInPolygonCommitment } from "../model/private/Commitment";
import { TimeStampInterval } from "../model/Time";
import type { GeoPointProviderCircuitProof, TimeStampIntervalProviderCircuitProof } from "../zkprogram/private/Geography";
import type { GeoPointInPolygonCircuitProof } from "../zkprogram/private/GeoPointInPolygonCircuit";
import { OracleGeoPointProviderCircuitProof } from "../zkprogram/private/Oracle";
export declare function proveGeoPointIn3PointPolygon(point: GeoPoint, polygon: ThreePointPolygon): GeoPointInPolygonCommitment;
/**
 * Proves that a GeoPoint is inside or outside of a polygon with source-attested coordinate source.
 * This provides the foundational framework and a dynamic interface for the creation of proof with
 * verified coordinate source. This coordinate source could be the result of a request to an API,
 * the zero-knowledge proof from a hardware device, or a signature by some private key. This allows
 * for the dynamic creation of proofs with the source of coordinate verified by arbitrary logic.
 * This interface can be connected to through the use of proof recursion.
 *
 * Wether or not to trust the source is up to the verifier of the proof. They will be able to verify exactly which
 * set of circuits created that proof.
 *
 * @param sourcedGeoPointProof - the proof that the GeoPoint is sourced from a specific source
 * @param polygon
 * @returns
 */
export declare function proveProvidedGeoPointIn3PointPolygon(sourcedGeoPointProof: GeoPointProviderCircuitProof, polygon: ThreePointPolygon): GeoPointInPolygonCommitment;
/**
 * Given two proofs, it combines them into a single proof that is the AND of the two proofs.
 * The AND operand is applied to the `isInPolygon` field of the two proofs. The proof is computed
 * even if neither of the proofs have `isInPolygon` set to true. The proof verifies that the
 * `coordinatesCommitment` are the same, and that the `polygonCommitment` are different.
 * @param proof1 - the first proof
 * @param proof2  - the second proof
 * @returns CoordinateProofState
 */
export declare function AND(proof1: GeoPointInPolygonCircuitProof, proof2: GeoPointInPolygonCircuitProof): GeoPointInPolygonCommitment;
/**
 * Given two proofs, it combines them into a single proof that is the OR of the two proofs.
 * The OR operand is applied to the `isInPolygon` field of the two proofs. The proof is computed
 * even if neither of the proofs have `isInPolygon` set to true. The proof verifies that the
 * `coordinatesCommitment` are the same, and that the `polygonCommitment` are different.
 * @param proof1 - the first proof
 * @param proof2 - the second proof
 * @returns CoordinateProofState
 */
export declare function OR(proof1: GeoPointInPolygonCircuitProof, proof2: GeoPointInPolygonCircuitProof): GeoPointInPolygonCommitment;
export declare function combine(proof1: SelfProof<Empty, GeoPointInOutPolygonCommitment>, proof2: SelfProof<Empty, GeoPointInOutPolygonCommitment>): GeoPointInOutPolygonCommitment;
export declare function fromCoordinatesInPolygonProof(proof: SelfProof<Empty, GeoPointInPolygonCommitment>): GeoPointInOutPolygonCommitment;
export declare function proofGeoPointInPolygonCommitmentFromOutput(output: GeoPointInPolygonCommitment): GeoPointInPolygonCommitment;
/**
 * Attach interval timestamp to the proof that the coordinates are in a polygon.
 * @param geoPointInPolygonProof Proof that the coordinates are in a polygon
 * @param timestampIntervralProof Proof of source of timestamp interval
 * @returns GeoPoint with inclusion in polygon and time stamp interval information
 */
export declare function proofAttachSourcedTimestampinterval(geoPointInPolygonProof: GeoPointInPolygonCircuitProof, timestampIntervralProof: TimeStampIntervalProviderCircuitProof): GeoPointWithTimeStampIntervalInPolygonCommitment;
/**
 * Given two sources GeoPointWithTimeStampIntervalInPolygonCommitment proofs, it combines them into a single proof that is the AND of the two proofs.
 * This method requires for the time intervals to be equal in both proofs. A set of utility methods is provided to compress or extend a time interval,
 * and they can be used to adapt the time intervals to be equal, as long as they are compatible with one another.s
 * @param firstProof first proof
 * @param secondProof second proof
 * @returns combination of both proofs
 */
export declare function geoPointWithTimeStampInPolygonAND(firstProof: SelfProof<Empty, GeoPointWithTimeStampIntervalInPolygonCommitment>, secondProof: SelfProof<Empty, GeoPointWithTimeStampIntervalInPolygonCommitment>): GeoPointWithTimeStampIntervalInPolygonCommitment;
export declare function geoPointWithTimeStampInPolygonOR(firstProof: SelfProof<Empty, GeoPointWithTimeStampIntervalInPolygonCommitment>, secondProof: SelfProof<Empty, GeoPointWithTimeStampIntervalInPolygonCommitment>): GeoPointWithTimeStampIntervalInPolygonCommitment;
/**
 * Expand the time interval of a GeoPointWithTimeStampIntervalInPolygonCommitment proof. This method is useful for adapting time intervals for AND and OR operations.
 * This method only succeeds if the provided time interval is a super set of the original time interval.
 * @param commitment - the proof to expand
 * @param newTimeStampInterval  - the new time interval
 */
export declare function expandTimeStampInterval(commitment: GeoPointWithTimeStampIntervalInPolygonCommitment, newTimeStampInterval: TimeStampInterval): GeoPointWithTimeStampIntervalInPolygonCommitment;
/**
 * Recurvisevely expand the time interval of a GeoPointWithTimeStampIntervalInPolygonCommitment proof on the GeoPointWithTimeStampIntervalInPolygonCommitment.
 * This method is useful for adapting time intervals for AND and OR operations.
 * @param proof - Recursive proof with GeoPointWithTimeStampIntervalInPolygonCommitment as public output to expand
 * @param newTimeStampInterval  - the new and expanded time stamp interval.
 * @returns
 */
export declare function expandTimeStampIntervalRecursive(proof: SelfProof<Empty, GeoPointWithTimeStampIntervalInPolygonCommitment>, newTimeStampInterval: TimeStampInterval): GeoPointWithTimeStampIntervalInPolygonCommitment;
export declare function geoPointFromLiteral(point: GeoPoint): GeoPoint;
export declare function timeStampIntervalFromLiteral(interval: TimeStampInterval): TimeStampInterval;
export declare function exactGeoPointFromOracle(oracleProof: OracleGeoPointProviderCircuitProof, geoPoint: GeoPoint): GeoPoint;
