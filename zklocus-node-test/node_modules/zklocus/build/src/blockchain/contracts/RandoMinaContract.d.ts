import { SmartContract } from "o1js";
declare const PublicPRNGParameters_base: (new (value: {
    networkState: import("o1js/dist/node/lib/field").Field;
    sender: import("o1js/dist/node/lib/field").Field;
}) => {
    networkState: import("o1js/dist/node/lib/field").Field;
    sender: import("o1js/dist/node/lib/field").Field;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    networkState: import("o1js/dist/node/lib/field").Field;
    sender: import("o1js/dist/node/lib/field").Field;
}> & {
    toInput: (x: {
        networkState: import("o1js/dist/node/lib/field").Field;
        sender: import("o1js/dist/node/lib/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        networkState: import("o1js/dist/node/lib/field").Field;
        sender: import("o1js/dist/node/lib/field").Field;
    }) => {
        networkState: string;
        sender: string;
    };
    fromJSON: (x: {
        networkState: string;
        sender: string;
    }) => {
        networkState: import("o1js/dist/node/lib/field").Field;
        sender: import("o1js/dist/node/lib/field").Field;
    };
    empty: () => {
        networkState: import("o1js/dist/node/lib/field").Field;
        sender: import("o1js/dist/node/lib/field").Field;
    };
};
/**
 * Represents the public input parameters for a Pseudo-Random Number Generator (PRNG).
 *
 * The PRNG algorithm is defined by the following parameters:
 * - networkState: The state of the network at the time of the PRNG computation. This value is used to ensure freshness of
 *     the random number. This provides the PRNG with the security guarantee against brute-force attacks, which could give
 *     an attacker an advantage in some contexts. This value could be either a single Mina blockchain network attribute, or
 *     a combination of them. It's important that this attribute is constant, unique and unpredictable for each Mina block.
 *     The proofs generated with this number will only be valid within the Mina block where this proof was generated.
 * - sender: The public key of the sender of the PRNG computation. This value is obtained by Poseidon-hasing the public key of the
 *    sender. This is the second part of the seed, and it is used as a global nonce, to ensure that the random numbers generated
 *    throughout the network have a unique seed component.
 *
 * Additionally, the following private input is used:
 * - nonce: Any number, which is used as the "local seed/nonce" per (networkState, sender) pair. This enables each Mina address to
 *   be able to generate multiple (infinite) number of pseudo-random numbers in a single Mina block. If necesasry, nonce
 *   can also be used as a public input. This can be either done by extending the methods of the existing smart contract, or defining a new one.
 */
export declare class PublicPRNGParameters extends PublicPRNGParameters_base {
}
/**
 * Zero-Knowledge circuit which represents an observation of a computation that generates a random
 * number using a specific pseudo-random number generator (PRNG) algorithm.
 */
export declare const RandomNumberObservationCircuit: {
    name: string;
    compile: (options?: {
        cache?: import("o1js/dist/node/lib/proof-system/cache").Cache | undefined;
        forceRecompile?: boolean | undefined;
    } | undefined) => Promise<{
        verificationKey: {
            data: string;
            hash: import("o1js/dist/node/lib/field").Field;
        };
    }>;
    verify: (proof: import("o1js/dist/node/lib/proof_system").Proof<PublicPRNGParameters, import("o1js/dist/node/lib/field").Field>) => Promise<boolean>;
    digest: () => string;
    analyzeMethods: () => {
        generateRandomNumber: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky").GateType | "Total rows", number>>;
        };
    };
    publicInputType: typeof PublicPRNGParameters;
    publicOutputType: typeof import("o1js/dist/node/lib/field").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/field").Field | import("o1js/dist/node/lib/field").FieldVar | import("o1js/dist/node/lib/field").FieldConst) => import("o1js/dist/node/lib/field").Field);
    privateInputTypes: {
        generateRandomNumber: [typeof import("o1js/dist/node/lib/field").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/field").Field | import("o1js/dist/node/lib/field").FieldVar | import("o1js/dist/node/lib/field").FieldConst) => import("o1js/dist/node/lib/field").Field)];
    };
    rawMethods: {
        generateRandomNumber: (publicInput: PublicPRNGParameters, ...args: [import("o1js/dist/node/lib/field").Field] & any[]) => import("o1js/dist/node/lib/field").Field;
    };
} & {
    generateRandomNumber: (publicInput: PublicPRNGParameters, ...args: [import("o1js/dist/node/lib/field").Field] & any[]) => Promise<import("o1js/dist/node/lib/proof_system").Proof<PublicPRNGParameters, import("o1js/dist/node/lib/field").Field>>;
};
declare const RandomNumberObservationCircuitProof_base: {
    new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
        proof: unknown;
        publicInput: PublicPRNGParameters;
        publicOutput: import("o1js/dist/node/lib/field").Field;
        maxProofsVerified: 0 | 1 | 2;
    }): {
        publicInput: PublicPRNGParameters;
        publicOutput: import("o1js/dist/node/lib/field").Field;
        proof: unknown;
        maxProofsVerified: 0 | 1 | 2;
        shouldVerify: import("o1js/dist/node/lib/bool").Bool;
        verify(): void;
        verifyIf(condition: import("o1js/dist/node/lib/bool").Bool): void;
        toJSON(): import("o1js/dist/node/lib/proof_system").JsonProof;
    };
    publicInputType: typeof PublicPRNGParameters;
    publicOutputType: typeof import("o1js/dist/node/lib/field").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/field").Field | import("o1js/dist/node/lib/field").FieldVar | import("o1js/dist/node/lib/field").FieldConst) => import("o1js/dist/node/lib/field").Field);
    tag: () => {
        name: string;
        publicInputType: typeof PublicPRNGParameters;
        publicOutputType: typeof import("o1js/dist/node/lib/field").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/field").Field | import("o1js/dist/node/lib/field").FieldVar | import("o1js/dist/node/lib/field").FieldConst) => import("o1js/dist/node/lib/field").Field);
    };
    fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>) & {
        prototype: import("o1js/dist/node/lib/proof_system").Proof<any, any>;
        publicInputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
        publicOutputType: import("o1js/dist/node/lib/circuit_value").FlexibleProvablePure<any>;
        tag: () => {
            name: string;
        };
        fromJSON: typeof import("o1js/dist/node/lib/proof_system").Proof.fromJSON;
        dummy: typeof import("o1js/dist/node/lib/proof_system").Proof.dummy;
    } & {
        prototype: import("o1js/dist/node/lib/proof_system").Proof<unknown, unknown>;
    }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system").JsonProof): import("o1js/dist/node/lib/proof_system").Proof<import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field").Field>, import("o1js/dist/node/bindings/lib/provable-generic").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field").Field>>;
    dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system").Proof<Input, OutPut>>;
};
export declare class RandomNumberObservationCircuitProof extends RandomNumberObservationCircuitProof_base {
}
/**
 * Smart contract that verifies the observation of a computation of a PRNG algorithm and asserts that the
 * network state used as a seed is the state of the network in the current network block.
 *
 * This smart contract is meant to be inherited by other smart contracts, which need to rely on pseudo-random
 * numbers with freshness guarantees. As such, this smart contract would be invoked by any other smart-contract,
 * which can either use it direclty or a parameter to another smart contract. In practice, this brings
 * smart contracts on Mina blockchain. Those will be used for zkLocus for various protocol and functioanlity
 * needs, which include, but are not limited to $ZKL.
 */
export declare class RandoMinaContract extends SmartContract {
    verifyRandomNumber(observationProof: RandomNumberObservationCircuitProof): void;
}
export {};
