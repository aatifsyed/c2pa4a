import { Int64, Field } from "o1js";
import { TimeStampInterval } from './Time';
declare const GeoPoint_base: (new (value: {
    latitude: Int64;
    longitude: Int64;
    factor: Int64;
}) => {
    latitude: Int64;
    longitude: Int64;
    factor: Int64;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    latitude: Int64;
    longitude: Int64;
    factor: Int64;
}> & {
    toInput: (x: {
        latitude: Int64;
        longitude: Int64;
        factor: Int64;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        latitude: Int64;
        longitude: Int64;
        factor: Int64;
    }) => {
        latitude: any;
        longitude: any;
        factor: any;
    };
    fromJSON: (x: {
        latitude: any;
        longitude: any;
        factor: any;
    }) => {
        latitude: Int64;
        longitude: Int64;
        factor: Int64;
    };
    empty: () => {
        latitude: Int64;
        longitude: Int64;
        factor: Int64;
    };
};
/** Data Structures */
/**
 * Represents a geographical point. The point is represented as a pair of latitude and longitude values.
 * The latitude and longitude values are represented as Field values. The Field values are scaled to
 * the desired factor, in order to represent the desired percision. The percision is represented as
 * a Field value. The percision is the number of decimal points that the latitude and longitude values
 * have. For example, if the percision is 7, then the latitude and longitude values are scaled to
 * 7 decimal points. The latitude and longitude values are scaled by multiplying them with 10^7.
 * 10^7 is the scale factor. `factor` is used instead of percision to optimize the efficency, as it prevent
  the need to perform exponentiation computations
 */
export declare class GeoPoint extends GeoPoint_base {
    hash(): Field;
    toFields(): Field[];
    assertIsValid(): void;
}
declare const GeoPointWithTimestamp_base: (new (value: {
    point: GeoPoint;
    timestamp: TimeStampInterval;
}) => {
    point: GeoPoint;
    timestamp: TimeStampInterval;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    point: GeoPoint;
    timestamp: TimeStampInterval;
}> & {
    toInput: (x: {
        point: GeoPoint;
        timestamp: TimeStampInterval;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        point: GeoPoint;
        timestamp: TimeStampInterval;
    }) => {
        point: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        timestamp: {
            start: string;
            end: string;
        };
    };
    fromJSON: (x: {
        point: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        timestamp: {
            start: string;
            end: string;
        };
    }) => {
        point: GeoPoint;
        timestamp: TimeStampInterval;
    };
    empty: () => {
        point: GeoPoint;
        timestamp: TimeStampInterval;
    };
};
/**
 * Represents a geographical point, with a timestamp.
 */
export declare class GeoPointWithTimestamp extends GeoPointWithTimestamp_base {
    hash(): import("o1js/dist/node/lib/field").Field;
}
declare const ThreePointPolygon_base: (new (value: {
    vertice1: GeoPoint;
    vertice2: GeoPoint;
    vertice3: GeoPoint;
}) => {
    vertice1: GeoPoint;
    vertice2: GeoPoint;
    vertice3: GeoPoint;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky").ProvablePure<{
    vertice1: GeoPoint;
    vertice2: GeoPoint;
    vertice3: GeoPoint;
}> & {
    toInput: (x: {
        vertice1: GeoPoint;
        vertice2: GeoPoint;
        vertice3: GeoPoint;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        vertice1: GeoPoint;
        vertice2: GeoPoint;
        vertice3: GeoPoint;
    }) => {
        vertice1: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        vertice2: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        vertice3: {
            latitude: any;
            longitude: any;
            factor: any;
        };
    };
    fromJSON: (x: {
        vertice1: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        vertice2: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        vertice3: {
            latitude: any;
            longitude: any;
            factor: any;
        };
    }) => {
        vertice1: GeoPoint;
        vertice2: GeoPoint;
        vertice3: GeoPoint;
    };
    empty: () => {
        vertice1: GeoPoint;
        vertice2: GeoPoint;
        vertice3: GeoPoint;
    };
};
export declare class ThreePointPolygon extends ThreePointPolygon_base {
    hash(): import("o1js/dist/node/lib/field").Field;
    /**
     * Ensure that the `ThreePointPolygon` instance is valid. This includes
     * asserting that the coordinates are within the allowed values, and that
     * those coordinates are ordered correctly.
     */
    assertIsValid(): void;
    private assertIsVerticesValid;
    private assertIsOrderingValid;
}
export {};
