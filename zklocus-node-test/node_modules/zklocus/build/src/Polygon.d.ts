import { SelfProof } from 'o1js';
import { ThreePointPolygon, GeoPoint } from './model/Geography.js';
declare const IntervalTimeStamp_base: (new (value: {
    start: import("o1js/dist/node/lib/field.js").Field;
    end: import("o1js/dist/node/lib/field.js").Field;
}) => {
    start: import("o1js/dist/node/lib/field.js").Field;
    end: import("o1js/dist/node/lib/field.js").Field;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky.js").ProvablePure<{
    start: import("o1js/dist/node/lib/field.js").Field;
    end: import("o1js/dist/node/lib/field.js").Field;
}> & {
    toInput: (x: {
        start: import("o1js/dist/node/lib/field.js").Field;
        end: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        start: import("o1js/dist/node/lib/field.js").Field;
        end: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        start: string;
        end: string;
    };
    fromJSON: (x: {
        start: string;
        end: string;
    }) => {
        start: import("o1js/dist/node/lib/field.js").Field;
        end: import("o1js/dist/node/lib/field.js").Field;
    };
    empty: () => {
        start: import("o1js/dist/node/lib/field.js").Field;
        end: import("o1js/dist/node/lib/field.js").Field;
    };
};
declare class IntervalTimeStamp extends IntervalTimeStamp_base {
}
declare const LiteralCoordinatesAndTimeStamp_base: (new (value: {
    point: GeoPoint;
    timestamp: IntervalTimeStamp;
}) => {
    point: GeoPoint;
    timestamp: IntervalTimeStamp;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky.js").ProvablePure<{
    point: GeoPoint;
    timestamp: IntervalTimeStamp;
}> & {
    toInput: (x: {
        point: GeoPoint;
        timestamp: IntervalTimeStamp;
    }) => {
        fields?: import("o1js/dist/node/lib/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        point: GeoPoint;
        timestamp: IntervalTimeStamp;
    }) => {
        point: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        timestamp: {
            start: string;
            end: string;
        };
    };
    fromJSON: (x: {
        point: {
            latitude: any;
            longitude: any;
            factor: any;
        };
        timestamp: {
            start: string;
            end: string;
        };
    }) => {
        point: GeoPoint;
        timestamp: IntervalTimeStamp;
    };
    empty: () => {
        point: GeoPoint;
        timestamp: IntervalTimeStamp;
    };
};
declare class LiteralCoordinatesAndTimeStamp extends LiteralCoordinatesAndTimeStamp_base {
}
export declare const CoordinateSourceFromGoogle: {
    name: string;
    compile: (options?: {
        cache?: import("o1js/dist/node/lib/proof-system/cache.js").Cache | undefined;
        forceRecompile?: boolean | undefined;
    } | undefined) => Promise<{
        verificationKey: {
            data: string;
            hash: import("o1js/dist/node/lib/field.js").Field;
        };
    }>;
    verify: (proof: import("o1js/dist/node/lib/proof_system.js").Proof<undefined, GeoPoint>) => Promise<boolean>;
    digest: () => string;
    analyzeMethods: () => {
        proveGeoPointIn3PointPolygon2: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky.js").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky.js").GateType | "Total rows", number>>;
        };
    };
    publicInputType: import("o1js/dist/node/lib/circuit_value.js").ProvablePureExtended<undefined, null>;
    publicOutputType: typeof GeoPoint;
    privateInputTypes: {
        proveGeoPointIn3PointPolygon2: [typeof LiteralCoordinatesAndTimeStamp];
    };
    rawMethods: {
        proveGeoPointIn3PointPolygon2: (...args: [LiteralCoordinatesAndTimeStamp] & any[]) => GeoPoint;
    };
} & {
    proveGeoPointIn3PointPolygon2: (...args: [LiteralCoordinatesAndTimeStamp] & any[]) => Promise<import("o1js/dist/node/lib/proof_system.js").Proof<undefined, GeoPoint>>;
};
export declare const CoordinateUsage: {
    name: string;
    compile: (options?: {
        cache?: import("o1js/dist/node/lib/proof-system/cache.js").Cache | undefined;
        forceRecompile?: boolean | undefined;
    } | undefined) => Promise<{
        verificationKey: {
            data: string;
            hash: import("o1js/dist/node/lib/field.js").Field;
        };
    }>;
    verify: (proof: import("o1js/dist/node/lib/proof_system.js").Proof<undefined, void>) => Promise<boolean>;
    digest: () => string;
    analyzeMethods: () => {
        proveGeoPointIn3PointPolygon: {
            rows: number;
            digest: string;
            result: unknown;
            gates: import("o1js/dist/node/snarky.js").Gate[];
            publicInputSize: number;
            print(): void;
            summary(): Partial<Record<import("o1js/dist/node/snarky.js").GateType | "Total rows", number>>;
        };
    };
    publicInputType: import("o1js/dist/node/lib/circuit_value.js").ProvablePureExtended<undefined, null>;
    publicOutputType: import("o1js/dist/node/lib/circuit_value.js").ProvablePureExtended<void, null>;
    privateInputTypes: {
        proveGeoPointIn3PointPolygon: [{
            new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
                proof: unknown;
                publicInput: undefined;
                publicOutput: GeoPoint;
                maxProofsVerified: 0 | 1 | 2;
            }): SelfProof<undefined, GeoPoint>;
            publicInputType: import("o1js/dist/node/lib/circuit_value.js").FlexibleProvablePure<any>;
            publicOutputType: import("o1js/dist/node/lib/circuit_value.js").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
            fromJSON<S extends (new (...args: any) => import("o1js/dist/node/lib/proof_system.js").Proof<unknown, unknown>) & {
                prototype: import("o1js/dist/node/lib/proof_system.js").Proof<any, any>;
                publicInputType: import("o1js/dist/node/lib/circuit_value.js").FlexibleProvablePure<any>;
                publicOutputType: import("o1js/dist/node/lib/circuit_value.js").FlexibleProvablePure<any>;
                tag: () => {
                    name: string;
                };
                fromJSON: typeof import("o1js/dist/node/lib/proof_system.js").Proof.fromJSON;
                dummy: typeof import("o1js/dist/node/lib/proof_system.js").Proof.dummy;
            } & {
                prototype: import("o1js/dist/node/lib/proof_system.js").Proof<unknown, unknown>;
            }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("o1js/dist/node/lib/proof_system.js").JsonProof): import("o1js/dist/node/lib/proof_system.js").Proof<import("o1js/dist/node/bindings/lib/provable-generic.js").InferProvable<S["publicInputType"], import("o1js/dist/node/lib/field.js").Field>, import("o1js/dist/node/bindings/lib/provable-generic.js").InferProvable<S["publicOutputType"], import("o1js/dist/node/lib/field.js").Field>>;
            dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 1 | 2, domainLog2?: number | undefined): Promise<import("o1js/dist/node/lib/proof_system.js").Proof<Input, OutPut>>;
        }, typeof ThreePointPolygon];
    };
    rawMethods: {
        proveGeoPointIn3PointPolygon: (...args: [SelfProof<undefined, GeoPoint>, ThreePointPolygon] & any[]) => void;
    };
} & {
    proveGeoPointIn3PointPolygon: (...args: [SelfProof<undefined, GeoPoint>, ThreePointPolygon] & any[]) => Promise<import("o1js/dist/node/lib/proof_system.js").Proof<undefined, void>>;
};
export {};
