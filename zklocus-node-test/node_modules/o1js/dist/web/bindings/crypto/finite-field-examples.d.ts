export { exampleFields };
declare let exampleFields: {
    Fp: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    Fq: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    small: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    babybear: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    goldilocks: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    f25519: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    secp256k1: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    secq256k1: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    bls12_381_base: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
    bls12_381_scalar: {
        modulus: bigint;
        sizeInBits: number;
        t: bigint;
        M: bigint;
        twoadicRoot: bigint;
        mod(x: bigint): bigint;
        add(x: bigint, y: bigint): bigint;
        not(x: bigint, bits: number): bigint;
        negate(x: bigint): bigint;
        sub(x: bigint, y: bigint): bigint;
        mul(x: bigint, y: bigint): bigint;
        inverse(x: bigint): bigint | undefined;
        div(x: bigint, y: bigint): bigint | undefined;
        square(x: bigint): bigint;
        isSquare(x: bigint): boolean;
        sqrt(x: bigint): bigint | undefined;
        power(x: bigint, n: bigint): bigint;
        dot(x: bigint[], y: bigint[]): bigint;
        equal(x: bigint, y: bigint): boolean;
        isEven(x: bigint): boolean;
        random(): bigint;
        fromNumber(x: number): bigint;
        fromBigint(x: bigint): bigint;
        rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
        leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
        rightShift(x: bigint, bits: number): bigint;
    };
};
