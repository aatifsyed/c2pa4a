import { Binable } from './binable.js';
export { GenericProvable, GenericProvablePure, GenericProvableExtended, GenericProvableExtendedPure, GenericField, GenericBool, GenericHashInput, GenericSignable, GenericSignableField, GenericSignableBool, primitiveTypes, PrimitiveTypeMap, primitiveTypeMap, EmptyNull, EmptyUndefined, EmptyVoid, };
type GenericProvable<T, Field> = {
    toFields: (x: T) => Field[];
    toAuxiliary: (x?: T) => any[];
    fromFields: (x: Field[], aux: any[]) => T;
    sizeInFields(): number;
    check: (x: T) => void;
};
interface GenericProvablePure<T, Field> extends GenericProvable<T, Field> {
    toFields: (x: T) => Field[];
    toAuxiliary: (x?: T) => any[];
    fromFields: (x: Field[]) => T;
    sizeInFields(): number;
    check: (x: T) => void;
}
type GenericSignable<T, TJson, Field> = {
    toInput: (x: T) => {
        fields?: Field[];
        packed?: [Field, number][];
    };
    toJSON: (x: T) => TJson;
    fromJSON: (x: TJson) => T;
    empty: () => T;
};
type GenericProvableExtended<T, TJson, Field> = GenericProvable<T, Field> & GenericSignable<T, TJson, Field>;
type GenericProvableExtendedPure<T, TJson, Field> = GenericProvablePure<T, Field> & GenericSignable<T, TJson, Field>;
type GenericSignableField<Field> = ((value: number | string | bigint) => Field) & GenericSignable<Field, string, Field> & Binable<Field> & {
    sizeInBytes: number;
};
type GenericField<Field> = GenericSignableField<Field> & GenericProvable<Field, Field>;
type GenericSignableBool<Field, Bool = unknown> = ((value: boolean) => Bool) & GenericSignable<Bool, boolean, Field> & Binable<Bool> & {
    sizeInBytes: number;
};
type GenericBool<Field, Bool = unknown> = GenericSignableBool<Field, Bool> & GenericProvable<Bool, Field>;
type GenericHashInput<Field> = {
    fields?: Field[];
    packed?: [Field, number][];
};
declare let primitiveTypes: Set<string>;
declare function EmptyNull<Field>(): GenericProvableExtended<null, null, Field> & GenericProvablePure<null, Field>;
declare function EmptyUndefined<Field>(): GenericProvableExtended<undefined, null, Field> & GenericProvablePure<undefined, Field>;
declare function EmptyVoid<Field>(): GenericProvableExtended<void, null, Field> & GenericProvablePure<void, Field>;
type PrimitiveTypeMap<Field> = {
    number: GenericProvableExtended<number, number, Field>;
    string: GenericProvableExtended<string, string, Field>;
    null: GenericProvableExtended<null, null, Field>;
};
declare const primitiveTypeMap: PrimitiveTypeMap<any>;
