import { GenericHashInput, GenericProvable, GenericProvablePure, GenericProvableExtended, GenericProvableExtendedPure, GenericSignable } from './generic.js';
export { createDerivers, createHashInput, ProvableConstructor, SignableConstructor, NonMethods, InferProvable, InferJson, InferredProvable, IsPure, Constructor, };
type ProvableConstructor<Field> = <A>(typeObj: A, options?: {
    isPure?: boolean;
}) => InferredProvable<A, Field>;
type SignableConstructor<Field> = <A>(typeObj: A) => InferredSignable<A, Field>;
declare function createDerivers<Field>(): {
    provable: ProvableConstructor<Field>;
    signable: SignableConstructor<Field>;
};
declare function createHashInput<Field>(): {
    readonly empty: {};
    append(input1: GenericHashInput<Field>, input2: GenericHashInput<Field>): GenericHashInput<Field>;
};
type JSONValue = number | string | boolean | null | Array<JSONValue> | {
    [key: string]: JSONValue;
};
type Struct<T, Field> = GenericProvableExtended<NonMethods<T>, any, Field> & Constructor<T> & {
    _isStruct: true;
};
type NonMethodKeys<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type NonMethods<T> = Pick<T, NonMethodKeys<T>>;
type Constructor<T> = new (...args: any) => T;
type Tuple<T> = [T, ...T[]] | [];
type Primitive = typeof String | typeof Number | typeof Boolean | typeof BigInt | null | undefined;
type InferPrimitive<P extends Primitive> = P extends typeof String ? string : P extends typeof Number ? number : P extends typeof Boolean ? boolean : P extends typeof BigInt ? bigint : P extends null ? null : P extends undefined ? undefined : any;
type InferPrimitiveJson<P extends Primitive> = P extends typeof String ? string : P extends typeof Number ? number : P extends typeof Boolean ? boolean : P extends typeof BigInt ? string : P extends null ? null : P extends undefined ? null : JSONValue;
type InferProvable<A, Field> = A extends Constructor<infer U> ? A extends GenericProvable<U, Field> ? U : A extends Struct<U, Field> ? U : InferProvableBase<A, Field> : InferProvableBase<A, Field>;
type InferProvableBase<A, Field> = A extends GenericProvable<infer U, Field> ? U : A extends Primitive ? InferPrimitive<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferProvable<A[I], Field>;
} : A extends (infer U)[] ? InferProvable<U, Field>[] : A extends Record<any, any> ? {
    [K in keyof A]: InferProvable<A[K], Field>;
} : never;
type WithJson<J> = {
    toJSON: (x: any) => J;
};
type InferJson<A> = A extends WithJson<infer J> ? J : A extends Primitive ? InferPrimitiveJson<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferJson<A[I]>;
} : A extends WithJson<infer U>[] ? U[] : A extends Record<any, any> ? {
    [K in keyof A]: InferJson<A[K]>;
} : JSONValue;
type IsPure<A, Field> = IsPureBase<A, Field> extends true ? true : false;
type IsPureBase<A, Field> = A extends GenericProvablePure<any, Field> ? true : A extends GenericProvable<any, Field> ? false : A extends Primitive ? false : A extends (infer U)[] ? IsPure<U, Field> : A extends Record<any, any> ? {
    [K in keyof A]: IsPure<A[K], Field>;
}[keyof A] : false;
type InferredProvable<A, Field> = IsPure<A, Field> extends true ? GenericProvableExtendedPure<InferProvable<A, Field>, InferJson<A>, Field> : GenericProvableExtended<InferProvable<A, Field>, InferJson<A>, Field>;
type InferSignable<A, Field> = A extends GenericSignable<infer U, any, Field> ? U : A extends Primitive ? InferPrimitive<A> : A extends Tuple<any> ? {
    [I in keyof A]: InferSignable<A[I], Field>;
} : A extends (infer U)[] ? InferSignable<U, Field>[] : A extends Record<any, any> ? {
    [K in keyof A]: InferSignable<A[K], Field>;
} : never;
type InferredSignable<A, Field> = GenericSignable<InferSignable<A, Field>, InferJson<A>, Field>;
