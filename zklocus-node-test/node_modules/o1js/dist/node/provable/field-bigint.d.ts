import { HashInput } from '../bindings/lib/provable-bigint.js';
export { Field, Bool, UInt32, UInt64, Sign };
export { pseudoClass, sizeInBits, checkRange, checkField };
type Field = bigint;
type Bool = 0n | 1n;
type UInt32 = bigint;
type UInt64 = bigint;
declare const sizeInBits: number;
type minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;
declare const minusOne: minusOne;
type Sign = 1n | minusOne;
declare const checkField: (x: bigint) => void;
/**
 * The base field of the Pallas curve
 */
declare const Field: ((value: bigint | number | string) => bigint) & {
    modulus: bigint;
    sizeInBits: number;
    t: bigint;
    M: bigint;
    twoadicRoot: bigint;
    mod(x: bigint): bigint;
    add(x: bigint, y: bigint): bigint;
    not(x: bigint, bits: number): bigint;
    negate(x: bigint): bigint;
    sub(x: bigint, y: bigint): bigint;
    mul(x: bigint, y: bigint): bigint;
    inverse(x: bigint): bigint | undefined;
    div(x: bigint, y: bigint): bigint | undefined;
    square(x: bigint): bigint;
    isSquare(x: bigint): boolean;
    sqrt(x: bigint): bigint | undefined;
    power(x: bigint, n: bigint): bigint;
    dot(x: bigint[], y: bigint[]): bigint;
    equal(x: bigint, y: bigint): boolean;
    isEven(x: bigint): boolean;
    random(): bigint;
    fromNumber(x: number): bigint;
    fromBigint(x: bigint): bigint;
    rot(x: bigint, bits: bigint, direction?: "left" | "right", maxBits?: bigint): bigint;
    leftShift(x: bigint, bits: number, maxBitSize?: number): bigint;
    rightShift(x: bigint, bits: number): bigint;
    toBytes(t: bigint): number[];
    readBytes<N extends number>(bytes: number[], offset: import("../bindings/crypto/non-negative.js").NonNegativeInteger<N>): [value: bigint, offset: number];
    fromBytes(bytes: number[]): bigint;
    toBits(t: bigint): boolean[];
    fromBits(bits: boolean[]): bigint;
    sizeInBytes: number;
    toInput: (x: bigint) => {
        fields?: bigint[] | undefined;
        packed?: [bigint, number][] | undefined;
    };
    toJSON: (x: bigint) => string;
    fromJSON: (x: string) => bigint;
    empty: () => bigint;
};
/**
 * A field element which is either 0 or 1
 */
declare const Bool: ((value: boolean) => Bool) & {
    toInput(x: Bool): HashInput;
    toBoolean(x: Bool): boolean;
    toJSON(x: Bool): boolean;
    fromJSON(b: boolean): Bool;
    sizeInBytes: number;
    fromField(x: Field): 0n | 1n;
    toBytes(t: Bool): number[];
    readBytes<N extends number>(bytes: number[], offset: import("../bindings/crypto/non-negative.js").NonNegativeInteger<N>): [value: Bool, offset: number];
    fromBytes(bytes: number[]): Bool;
    toBits(t: Bool): boolean[];
    fromBits(bits: boolean[]): Bool;
    sizeInBits: number;
    empty: () => Bool;
};
declare const UInt32: ((value: bigint | number | string) => bigint) & {
    toInput(x: bigint): HashInput;
    maxValue: bigint;
    random(): bigint;
    toBytes(t: bigint): number[];
    readBytes<N extends number>(bytes: number[], offset: import("../bindings/crypto/non-negative.js").NonNegativeInteger<N>): [value: bigint, offset: number];
    fromBytes(bytes: number[]): bigint;
    toBits(t: bigint): boolean[];
    fromBits(bits: boolean[]): bigint;
    sizeInBytes: number;
    sizeInBits: number;
    toJSON: (x: bigint) => string;
    fromJSON: (x: string) => bigint;
    empty: () => bigint;
};
declare const UInt64: ((value: bigint | number | string) => bigint) & {
    toInput(x: bigint): HashInput;
    maxValue: bigint;
    random(): bigint;
    toBytes(t: bigint): number[];
    readBytes<N extends number>(bytes: number[], offset: import("../bindings/crypto/non-negative.js").NonNegativeInteger<N>): [value: bigint, offset: number];
    fromBytes(bytes: number[]): bigint;
    toBits(t: bigint): boolean[];
    fromBits(bits: boolean[]): bigint;
    sizeInBytes: number;
    sizeInBits: number;
    toJSON: (x: bigint) => string;
    fromJSON: (x: string) => bigint;
    empty: () => bigint;
};
declare const Sign: ((value: 1 | -1) => Sign) & {
    empty(): 1n;
    toInput(x: Sign): HashInput;
    fromFields([x]: Field[]): Sign;
    toJSON(x: Sign): "Positive" | "Negative";
    fromJSON(x: 'Positive' | 'Negative'): Sign;
    toBytes(t: Sign): number[];
    readBytes<N extends number>(bytes: number[], offset: import("../bindings/crypto/non-negative.js").NonNegativeInteger<N>): [value: Sign, offset: number];
    fromBytes(bytes: number[]): Sign;
    toBits(t: Sign): boolean[];
    fromBits(bits: boolean[]): Sign;
    sizeInBytes: number;
    sizeInBits: number;
};
declare function pseudoClass<F extends (...args: any) => any, M>(constructor: F, module: M): F & M;
declare function checkRange(lower: bigint, upper: bigint, name: string): (x: bigint) => void;
