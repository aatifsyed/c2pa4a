import { Field, Bool } from '../../lib/core.js';
import { UInt32, UInt64, Sign } from '../../lib/int.js';
import { PublicKey } from '../../lib/signature.js';
export { PublicKey, Field, Bool, AuthRequired, UInt64, UInt32, Sign, TokenId };
export { Events, Actions, ZkappUri, TokenSymbol, ActionState, VerificationKeyHash, ReceiptChainHash, StateHash, };
type AuthRequired = {
    constant: Bool;
    signatureNecessary: Bool;
    signatureSufficient: Bool;
};
type TokenId = Field;
type StateHash = Field;
type TokenSymbol = {
    symbol: string;
    field: Field;
};
type ZkappUri = {
    data: string;
    hash: Field;
};
declare const TokenId: Omit<import("../lib/generic.js").GenericProvableExtended<import("../../lib/field.js").Field, string, import("../../lib/field.js").Field>, "toJSON" | "fromJSON"> & {
    empty: () => import("../../lib/field.js").Field;
    toJSON(x: import("../../lib/field.js").Field): string;
    fromJSON(x: string): import("../../lib/field.js").Field;
}, StateHash: Omit<import("../lib/generic.js").GenericProvableExtended<import("../../lib/field.js").Field, string, import("../../lib/field.js").Field>, "toJSON" | "fromJSON"> & {
    empty: () => import("../../lib/field.js").Field;
    toJSON(x: import("../../lib/field.js").Field): string;
    fromJSON(x: string): import("../../lib/field.js").Field;
}, TokenSymbol: Omit<import("../lib/generic.js").GenericProvableExtended<{
    field: import("../../lib/field.js").Field;
    symbol: string;
}, {
    field: string;
    symbol: string;
}, import("../../lib/field.js").Field>, "toJSON" | "fromJSON"> & {
    toInput({ field }: {
        symbol: string;
        field: import("../../lib/field.js").Field;
    }): import("../lib/generic.js").GenericHashInput<import("../../lib/field.js").Field>;
    toJSON({ symbol }: {
        symbol: string;
        field: import("../../lib/field.js").Field;
    }): string;
    fromJSON(symbol: string): {
        symbol: string;
        field: import("../../lib/field.js").Field;
    };
}, AuthRequired: Omit<import("../lib/generic.js").GenericProvableExtended<{
    constant: import("../../lib/bool.js").Bool;
    signatureNecessary: import("../../lib/bool.js").Bool;
    signatureSufficient: import("../../lib/bool.js").Bool;
}, {
    constant: boolean;
    signatureNecessary: boolean;
    signatureSufficient: boolean;
}, import("../../lib/field.js").Field>, "toJSON" | "fromJSON"> & {
    empty(): {
        constant: import("../../lib/bool.js").Bool;
        signatureNecessary: import("../../lib/bool.js").Bool;
        signatureSufficient: import("../../lib/bool.js").Bool;
    };
    toJSON(x: {
        constant: import("../../lib/bool.js").Bool;
        signatureNecessary: import("../../lib/bool.js").Bool;
        signatureSufficient: import("../../lib/bool.js").Bool;
    }): import("./transaction-leaves-json.js").AuthRequired;
    fromJSON(json: import("./transaction-leaves-json.js").AuthRequired): {
        constant: import("../../lib/bool.js").Bool;
        signatureNecessary: import("../../lib/bool.js").Bool;
        signatureSufficient: import("../../lib/bool.js").Bool;
    };
}, ZkappUri: import("../lib/generic.js").GenericProvableExtended<{
    data: string;
    hash: import("../../lib/field.js").Field;
}, string, import("../../lib/field.js").Field>;
type Event = Field[];
type Events = {
    hash: Field;
    data: Event[];
};
type Actions = Events;
declare const Events: {
    toFields: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => import("../../lib/field.js").Field[];
    toAuxiliary: (x?: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    } | undefined) => any[];
    fromFields: (x: import("../../lib/field.js").Field[], aux: any[]) => {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    };
    sizeInFields(): number;
    check: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => void;
    toInput: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => {
        fields?: import("../../lib/field.js").Field[] | undefined;
        packed?: [import("../../lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => string[][];
    fromJSON: (x: string[][]) => {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    };
    empty: () => {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    };
    pushEvent(events: {
        hash: import("../../lib/field.js").Field;
        data: import("../../lib/field.js").Field[][];
    }, event: import("../../lib/field.js").Field[]): {
        hash: import("../../lib/field.js").Field;
        data: import("../../lib/field.js").Field[][];
    };
    fromList(events: import("../../lib/field.js").Field[][]): {
        hash: import("../../lib/field.js").Field;
        data: import("../../lib/field.js").Field[][];
    };
    hash(events: import("../../lib/field.js").Field[][]): import("../../lib/field.js").Field;
}, Actions: {
    toFields: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => import("../../lib/field.js").Field[];
    toAuxiliary: (x?: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    } | undefined) => any[];
    fromFields: (x: import("../../lib/field.js").Field[], aux: any[]) => {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    };
    sizeInFields(): number;
    check: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => void;
    toInput: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => {
        fields?: import("../../lib/field.js").Field[] | undefined;
        packed?: [import("../../lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    }) => string[][];
    fromJSON: (x: string[][]) => {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    };
    empty: () => {
        data: import("../../lib/field.js").Field[][];
        hash: import("../../lib/field.js").Field;
    };
    pushEvent(actions: {
        hash: import("../../lib/field.js").Field;
        data: import("../../lib/field.js").Field[][];
    }, event: import("../../lib/field.js").Field[]): {
        hash: import("../../lib/field.js").Field;
        data: import("../../lib/field.js").Field[][];
    };
    fromList(events: import("../../lib/field.js").Field[][]): {
        hash: import("../../lib/field.js").Field;
        data: import("../../lib/field.js").Field[][];
    };
    hash(events: import("../../lib/field.js").Field[][]): import("../../lib/field.js").Field;
    emptyActionState(): import("../../lib/field.js").Field;
    updateSequenceState(state: import("../../lib/field.js").Field, sequenceEventsHash: import("../../lib/field.js").Field): import("../../lib/field.js").Field;
};
type ActionState = Field;
declare const ActionState: {
    empty: () => import("../../lib/field.js").Field;
    toFields: (x: import("../../lib/field.js").Field) => import("../../lib/field.js").Field[];
    toAuxiliary: (x?: import("../../lib/field.js").Field | undefined) => any[];
    fromFields: (x: import("../../lib/field.js").Field[]) => import("../../lib/field.js").Field;
    sizeInFields(): number;
    check: (x: import("../../lib/field.js").Field) => void;
    toInput: (x: import("../../lib/field.js").Field) => {
        fields?: import("../../lib/field.js").Field[] | undefined;
        packed?: [import("../../lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: import("../../lib/field.js").Field) => string;
    fromJSON: (x: string) => import("../../lib/field.js").Field;
};
type VerificationKeyHash = Field;
declare const VerificationKeyHash: {
    empty: () => import("../../lib/field.js").Field;
    toFields: (x: import("../../lib/field.js").Field) => import("../../lib/field.js").Field[];
    toAuxiliary: (x?: import("../../lib/field.js").Field | undefined) => any[];
    fromFields: (x: import("../../lib/field.js").Field[]) => import("../../lib/field.js").Field;
    sizeInFields(): number;
    check: (x: import("../../lib/field.js").Field) => void;
    toInput: (x: import("../../lib/field.js").Field) => {
        fields?: import("../../lib/field.js").Field[] | undefined;
        packed?: [import("../../lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: import("../../lib/field.js").Field) => string;
    fromJSON: (x: string) => import("../../lib/field.js").Field;
};
type ReceiptChainHash = Field;
declare const ReceiptChainHash: {
    empty: () => import("../../lib/field.js").Field;
    toFields: (x: import("../../lib/field.js").Field) => import("../../lib/field.js").Field[];
    toAuxiliary: (x?: import("../../lib/field.js").Field | undefined) => any[];
    fromFields: (x: import("../../lib/field.js").Field[]) => import("../../lib/field.js").Field;
    sizeInFields(): number;
    check: (x: import("../../lib/field.js").Field) => void;
    toInput: (x: import("../../lib/field.js").Field) => {
        fields?: import("../../lib/field.js").Field[] | undefined;
        packed?: [import("../../lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: import("../../lib/field.js").Field) => string;
    fromJSON: (x: string) => import("../../lib/field.js").Field;
};
