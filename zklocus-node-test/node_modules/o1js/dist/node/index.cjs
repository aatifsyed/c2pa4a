"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// dist/node/index.js
var node_exports = {};
__export(node_exports, {
  Account: () => Account5,
  AccountUpdate: () => AccountUpdate3,
  Bool: () => Bool4,
  Bytes: () => Bytes2,
  Cache: () => Cache,
  Character: () => Character,
  Circuit: () => Circuit,
  CircuitString: () => CircuitString,
  CircuitValue: () => CircuitValue,
  Crypto: () => Crypto,
  EcdsaSignature: () => EcdsaSignature2,
  Empty: () => Empty,
  Encoding: () => encoding_exports,
  Encryption: () => encryption_exports,
  Experimental: () => Experimental,
  Field: () => Field4,
  ForeignCurve: () => ForeignCurve,
  Gadgets: () => Gadgets,
  Group: () => Group3,
  Hash: () => Hash,
  Int64: () => Int64,
  Keccak: () => Keccak,
  Keypair: () => Keypair,
  Ledger: () => Ledger,
  Lightnet: () => Lightnet,
  MerkleMap: () => MerkleMap,
  MerkleMapWitness: () => MerkleMapWitness,
  MerkleTree: () => MerkleTree,
  MerkleWitness: () => MerkleWitness,
  Mina: () => mina_exports,
  Nullifier: () => Nullifier,
  Permissions: () => Permissions,
  Poseidon: () => Poseidon2,
  PrivateKey: () => PrivateKey2,
  Proof: () => Proof,
  Provable: () => Provable,
  PublicKey: () => PublicKey2,
  Reducer: () => Reducer,
  Scalar: () => Scalar3,
  SelfProof: () => SelfProof,
  Sign: () => Sign3,
  Signature: () => Signature2,
  SmartContract: () => SmartContract,
  State: () => State2,
  Struct: () => Struct,
  Token: () => Token,
  TokenId: () => TokenId4,
  TokenSymbol: () => TokenSymbol,
  Types: () => transaction_exports,
  UInt32: () => UInt322,
  UInt64: () => UInt642,
  UInt8: () => UInt8,
  Undefined: () => Undefined,
  VerificationKey: () => VerificationKey,
  Void: () => Void,
  ZkProgram: () => ZkProgram,
  ZkappPublicInput: () => ZkappPublicInput,
  addCachedAccount: () => addCachedAccount,
  arrayProp: () => arrayProp,
  assert: () => assert3,
  checkZkappTransaction: () => checkZkappTransaction,
  circuitMain: () => circuitMain,
  createEcdsa: () => createEcdsa,
  createForeignCurve: () => createForeignCurve,
  createForeignField: () => createForeignField,
  declareMethods: () => declareMethods,
  declareState: () => declareState,
  fetchAccount: () => fetchAccount,
  fetchEvents: () => fetchEvents,
  fetchLastBlock: () => fetchLastBlock,
  fetchTransactionStatus: () => fetchTransactionStatus,
  isReady: () => isReady,
  matrixProp: () => matrixProp,
  method: () => method,
  prop: () => prop,
  provable: () => provable,
  provablePure: () => provablePure,
  public_: () => public_,
  scaleShifted: () => scaleShifted,
  sendZkapp: () => sendZkapp,
  setArchiveGraphqlEndpoint: () => setArchiveGraphqlEndpoint,
  setGraphqlEndpoint: () => setGraphqlEndpoint,
  setGraphqlEndpoints: () => setGraphqlEndpoints,
  shutdown: () => shutdown,
  state: () => state2,
  verify: () => verify
});
module.exports = __toCommonJS(node_exports);

// dist/node/bindings/crypto/constants.js
var prefixes = {
  "event": "MinaZkappEvent******",
  "events": "MinaZkappEvents*****",
  "sequenceEvents": "MinaZkappSeqEvents**",
  "body": "TestnetZkappBody****",
  "accountUpdateCons": "MinaAcctUpdateCons**",
  "accountUpdateNode": "MinaAcctUpdateNode**",
  "zkappMemo": "MinaZkappMemo*******",
  "signatureMainnet": "MinaSignatureMainnet",
  "signatureTestnet": "CodaSignature*******",
  "zkappUri": "MinaZkappUri********",
  "deriveTokenId": "MinaDeriveTokenId***"
};
var prefixHashes = {
  "MinaReceiptUC*******": [
    "17890046087060600378523962727948914890955845280331606421027576706277370812052",
    "2013454333407534591106411126192774509000627947643864003868625362325108814274",
    "11843535353803037930790320689348405921362689396018494249827525941843824404081"
  ],
  "CodaReceiptZkapp****": [
    "10173709693039436418323173817852473796760618468635274081106091878172355412495",
    "8139892805413950771311540201181177376747817902069998595519899391903936767134",
    "13514876620613630149351219463845257700223634963001020028151406467995275024594"
  ],
  "Coinbase************": [
    "16825847102297458526359719396083434368788313103713242309655412848174457920423",
    "21732702256017917816272795771734458959259892802453584375610183841451053027064",
    "20669950187190141732603807229833302926112666951294341954340514712643194206110"
  ],
  "PendingCoinbases****": [
    "16730315671906078134534118281698719603694322959719576832314142406897554025946",
    "25168172107432119701402092802564698772609386283424806773354665411015030859956",
    "20203823516569384790863281992678977204769111540506990077513414850340465376267"
  ],
  "CoinbaseStackData***": [
    "23795978781100345043289806728009175185120094645976380845310050347461663815988",
    "22848259504294538625391413055517172710405127059374914145881816600826824598643",
    "8292468073974572410325570929211069869427868613763277519881895337391418731450"
  ],
  "CoinbaseStackStaHash": [
    "335203117218289187585524630708440909952721586869179589604793956147132569543",
    "27066428515933869709871979311099618239824992817474733219473754649926311088531",
    "21249847167218596842529246266817628519376871370045151307329588726090940941283"
  ],
  "CoinbaseStack*******": [
    "10365018507282248303752506973112854406071106890516858854157506926717812932750",
    "19289691782405010481159082968251292806607879795611766141901748131065655579721",
    "8987039650233860747996941600635099179155585390854763935988086491644855810711"
  ],
  "MinaCheckpoints*****": [
    "15873130589302091361863210575263731242593763730169570459166821652327279429416",
    "27741778946681194402252199348726997679847260280438775383573755416459042152245",
    "7598438620402360345138640933713109733801127070065255775405685972203496634081"
  ],
  "MinaMergeSnark******": [
    "5465206932306554741198859294482250047374987110116571903153751264716396266207",
    "28325265961862852836567844362114881306407823522046946129773393861560948847052",
    "20049678444717746759028157787181298288785775657186008836042341914370292827996"
  ],
  "MinaBaseSnark*******": [
    "15502310217431654911062859746106286672455410530942120153504175184205809302248",
    "3469045624943527165009161295743804688154058669917024998601801713171804105078",
    "16667965011323249535055526937874001443515091810412343722400939445165393857780"
  ],
  "MinaProtoState******": [
    "5218970939948495870036503265499543025475317910763049867270287867667146978870",
    "7663210626148314949787033187186036425676070286961909238040356477815169631084",
    "19859188289320816036969227839574854326171440874550138016648548415357198703337"
  ],
  "MinaProtoStateBody**": [
    "3548547909990922956559515810876765435326873020883079662683136168632773655275",
    "134182536761489093478066959027928272525080293912190881939140820794450385287",
    "18910449726094816833941350890285540874861148441082116020102338532207375519343"
  ],
  "MinaVrfMessage******": [
    "24101363367502572671624471609928959797353672294440762288404204895418767914646",
    "5171820881164007689309616183632792746219180909518238150637460314245246143263",
    "10979796915023089328772347959806029121878467684484216605075459818053899045444"
  ],
  "MinaSignatureMainnet": [
    "28597293842583882050529337819282358444728515448690248936274177901465134844489",
    "13029865398778858891320837481651890827971447635226272051516204921834229015884",
    "2324960771278703080070347074343683653953770644553957353754880132143131569147"
  ],
  "CodaSignature*******": [
    "6547874669265470003564181123405173756111990160585052594027544303901364349512",
    "22191763046611062479784309793717481299019591714391827084400612211604078633201",
    "15360317550574394687602808211901764964514686767298144053612144955373862517277"
  ],
  "MinaVrfOutput*******": [
    "2251514781415689779315070305878469259850299612928948069881728941286436529416",
    "28445424317765931437563566658155841532256907311948842353165636913979445243675",
    "1697103740469522139030362533818365124680980524626250761960654638291888644330"
  ],
  "MinaVrfEvaluation***": [
    "28080055385183205248434069314913715411795750554846638282391132356635075327118",
    "25018718747831549163470950235902703474807728450690404911050923194299837536932",
    "3256623657773355300700179149632147114566124258546613752475489953689825740823"
  ],
  "MinaEpochSeed*******": [
    "7920024158807749362970659876749181530334941449960381128739613586571256360405",
    "13756862713999441076472977832321298402266591073703520273734381195492800342833",
    "16931743843465107540110860558687538825985475311420101960428698400767332393906"
  ],
  "MinaTransitionSnark*": [
    "11049595972041980914958840531625028328602860712038036656362464370121336040984",
    "24369517789348117364784880800333031735213111703459853079908318927717982912175",
    "996573540734206293061884582007205418029995442386259428924494388795357965385"
  ],
  "MinaAccount*********": [
    "21547009634669789644192675386133007766042650219024716227935570378579547706642",
    "3869977418072959680344087467966431440327948593054069717779845397512987438978",
    "17591003611016737523041467644989399067682599282318802410210271366172380277153"
  ],
  "MinaSideLoadedVk****": [
    "27153629295534844750482612843518005572402188741101822965689207110291504095805",
    "11073437601016088346212553894160581939150688827288603152461976873708720172824",
    "9169013693168830396847022454402673046094697740892173219744332585469764409612"
  ],
  "MinaZkappAccount****": [
    "11742420651603425685690711434636216727968618158667382343736587130720645535016",
    "20917169788479399921968659996772666237321879817943938162255353371266230737562",
    "20221577186851444354528754069740362935513598751580381763045954351047955571417"
  ],
  "MinaZkappPayload****": [
    "15735138827391397348912010094577234813869450438840158969759900004702547928125",
    "25095612872941242247876048162039143509752212627701285511972307921367391645919",
    "7245494597725009330136300549232949784423520250577599502394596645257342395146"
  ],
  "TestnetZkappBody****": [
    "20037733640875789833090442509053816933966165101372309054048970230906793051053",
    "1106678471497583468621635190733109842219273971961053291385773425960251864224",
    "25565387364959491931899708566015584890804577695743228799735258954982776499278"
  ],
  "MinaZkappPred*******": [
    "1288860557840839698672685006364179285130411098848600694737282320588924548492",
    "24648295833336558525603848295184424886548932461541421142783307792871113347031",
    "1330615836835056811243082335077124866238751435915242573993316916713469087050"
  ],
  "MinaZkappPredAcct***": [
    "16247099195538206941970428186933809576049890124762896310373916059400681012938",
    "15171999803179862436296250357712424012107969488385552487664863256867849154640",
    "4695118160519310765712802705640939163487421977728313886668234870398464448283"
  ],
  "MinaZkappPredPS*****": [
    "28115844434401213157045670864292277190427496512916771660477513364996586226191",
    "17764239860871865704512758086410304367016330694375482081848267812860896213477",
    "2608563583120825722034995217249250504732387097295075568312443453761249924462"
  ],
  "MinaAcctUpdAcctPred*": [
    "11173347481325879282537380504137543614432174467122278589147153842480174214350",
    "22433785030516935555884954114999194863743668497200511950547006360846720681436",
    "4261224905860522407514587942832658209487173552801239748203234114069543449134"
  ],
  "MinaAcctUpdateCons**": [
    "7974184247425786365466969127827083941281743695327546149120833518746435921046",
    "1079147682067570431747049877519099849334832444581201545961023544596733431550",
    "9670106619202136718451303928765479503313491401619698334696903962327538130992"
  ],
  "MinaAcctUpdateNode**": [
    "15921812961830232432174711488904180713275251781093575291539345321597011303739",
    "5852213322332241594845871336918115662219071361771346507406094569679662937607",
    "21122827334147180286039671993443893600964526985496742826857975683524856341379"
  ],
  "MinaAcctUpdStckFrm**": [
    "1223279431820750727612295994589444883292600761079562536688416996919972234987",
    "1873141333924103856860857609363983758885824745969813373245393521390926426683",
    "3550105212452130151915860825756512345408015936295894584118372238840612023788"
  ],
  "MinaActUpStckFrmCons": [
    "2363089775097766730570162674460603870980415123701610894146069429352874281636",
    "8717086429614898734892919627864489205116600585932141922995487227707208282057",
    "14660270392332597302006144557344641683528071714290878702086758222477469533211"
  ],
  "MinaZkappUri********": [
    "534822897390732927195976832726937157108052596941484097303405936433225931144",
    "21308674973525253012607500915181592359821899373849668837401701284134790635210",
    "19235616568963430752220890547731083898076295596325584947617173371158207986317"
  ],
  "MinaZkappEvent******": [
    "4144672248660824652311280789227568759501644435839088465487215978090977152836",
    "16580012705864177241905923711864666027965216928284588602669501632136706453456",
    "28268897103231723777184618409092967932555901943057586428182153116992131011025"
  ],
  "MinaZkappEvents*****": [
    "22941690192200157010958144262626906691861453230235765939870625581651903942109",
    "8085194290973996063041942057794139208480036474122767282118588735695477304146",
    "26729904183313179836453835886592671283117737890095730465188585661277543615385"
  ],
  "MinaZkappSeqEvents**": [
    "20111532619758468729019280527752703188436440291616049387250019116440725105679",
    "28272901079534355755544153990297346241256584111406088887261772513761686581936",
    "11593971643819429831651280663135869674712971584194549509498204047075895747923"
  ],
  "MinaZkappMemo*******": [
    "2662735671148484138098041239517130399444285195614926917304994766121342901330",
    "1889560324711062089177091328630260720221153765601231238715650562289804935970",
    "4150523804923664151142435309968051550133270766858171566059780615187901817023"
  ],
  "MinaZkappTest*******": [
    "23523101868899742954180674496902908392567863852999903167375927084079494055612",
    "4491786955849351692402874941062803293792761915358826996649017458255778371918",
    "18160445324611651688025194683090940451613686777550031421971998315243738422364"
  ],
  "MinaDeriveTokenId***": [
    "6192019453766080264591455948244350296532066491511280821771403784079613278630",
    "3474280028978446563781013959252007045004226094384968366087940198662654278266",
    "20434002876694963787609307807174199928279086350854834006718281273564667456637"
  ],
  "CodaReceiptEmpty": [
    "14564582992068613478915821183083107733064540968050799295374021047658500056219",
    "21765043973285063733734239399942750176857972907855721619600674857294623000734",
    "18519955733587546799174091248819038069762857427193969217428957100491271613694"
  ],
  "MinaZkappEventsEmpty": [
    "11558119263070965853863267079253872832625419457395008685779236645292569607921",
    "25458142203119307439619503192644060065091275427503371449742352140981637359577",
    "28343474290528262467651243371210869540984529302238754668057531270656874883506"
  ],
  "MinaZkappActionsEmpty": [
    "2965377540200775924504968637505084669999360240500907972788072774778139588064",
    "17888733104410001265760460027725887240172765470923695174284923303416908725309",
    "6155733123951817300356401771271939707310716210385193729101357561319788034953"
  ],
  "MinaZkappActionStateEmptyElt": [
    "25079927036070901246064867767436987657692091363973573142121686150614948079097",
    "26431778411571512074795067173224334387034335867358343719815640998216694007738",
    "25080775363764450744501815075506845022058095277795060631172637381645274354727"
  ],
  "CoinbaseStack": [
    "13478948633790621346997153068092516261975764161208078295837519850718904039733",
    "23794571567771902109532327523992257297445027552423990566905688786749549749640",
    "12437776415960587857483436445253285567999534294199440886476575966193776753527"
  ],
  "PendingCoinbaseMerkleTree": [
    "21962074494103541153175746450273873003299668759086391980006382367241943398196",
    "2903435713642676558047328375873609628346075739786101737671585224825766548393",
    "25831764682100331646870313396659195191400312071282528592914032765816857800473"
  ]
};
var prefixHashesLegacy = {
  "MinaReceiptUC*******": [
    "20070382753578399401327804098717363060981792725858206382885984326454503485317",
    "9741317264439603248522437238966700420795613627770380489972854421227543398236",
    "7781138462994911643117614691750702461577493967611677045054456828859235572948"
  ],
  "MinaSignatureMainnet": [
    "25220214331362653986409717908235786107802222826119905443072293294098933388948",
    "7563646774167489166725044360539949525624365058064455335567047240620397351731",
    "171774671134240704318655896509797243441784148630375331692878460323037832932"
  ],
  "CodaSignature*******": [
    "28132119227444686413214523693400847740858213284875453355294308721084881982354",
    "24895072146662946646133617369498198544578131474807621989761680811592073367193",
    "3216013753133880902260672769141972972810073620591719805178695684388949134646"
  ]
};
var versionBytes = {
  "tokenIdKey": 28,
  "receiptChainHash": 12,
  "ledgerHash": 5,
  "epochSeed": 13,
  "stateHash": 16,
  "publicKey": 203,
  "userCommandMemo": 20,
  "privateKey": 90,
  "signature": 154,
  "transactionHash": 29,
  "signedCommandV1": 19
};
var poseidonParamsKimchiFp = {
  "mds": [
    [
      "12035446894107573964500871153637039653510326950134440362813193268448863222019",
      "25461374787957152039031444204194007219326765802730624564074257060397341542093",
      "27667907157110496066452777015908813333407980290333709698851344970789663080149"
    ],
    [
      "4491931056866994439025447213644536587424785196363427220456343191847333476930",
      "14743631939509747387607291926699970421064627808101543132147270746750887019919",
      "9448400033389617131295304336481030167723486090288313334230651810071857784477"
    ],
    [
      "10525578725509990281643336361904863911009900817790387635342941550657754064843",
      "27437632000253211280915908546961303399777448677029255413769125486614773776695",
      "27566319851776897085443681456689352477426926500749993803132851225169606086988"
    ]
  ],
  "roundConstants": [
    [
      "21155079691556475130150866428468322463125560312786319980770950159250751855431",
      "16883442198399350202652499677723930673110172289234921799701652810789093522349",
      "17030687036425314703519085065002231920937594822150793091243263847382891822670"
    ],
    [
      "25216718237129482752721276445368692059997901880654047883630276346421457427360",
      "9054264347380455706540423067244764093107767235485930776517975315876127782582",
      "26439087121446593160953570192891907825526260324480347638727375735543609856888"
    ],
    [
      "15251000790817261169639394496851831733819930596125214313084182526610855787494",
      "10861916012597714684433535077722887124099023163589869801449218212493070551767",
      "18597653523270601187312528478986388028263730767495975370566527202946430104139"
    ],
    [
      "15831416454198644276563319006805490049460322229057756462580029181847589006611",
      "15171856919255965617705854914448645702014039524159471542852132430360867202292",
      "15488495958879593647482715143904752785889816789652405888927117106448507625751"
    ],
    [
      "19039802679983063488134304670998725949842655199289961967801223969839823940152",
      "4720101937153217036737330058775388037616286510783561045464678919473230044408",
      "10226318327254973427513859412126640040910264416718766418164893837597674300190"
    ],
    [
      "20878756131129218406920515859235137275859844638301967889441262030146031838819",
      "7178475685651744631172532830973371642652029385893667810726019303466125436953",
      "1996970955918516145107673266490486752153434673064635795711751450164177339618"
    ],
    [
      "15205545916434157464929420145756897321482314798910153575340430817222504672630",
      "25660296961552699573824264215804279051322332899472350724416657386062327210698",
      "13842611741937412200312851417353455040950878279339067816479233688850376089318"
    ],
    [
      "1383799642177300432144836486981606294838630135265094078921115713566691160459",
      "1135532281155277588005319334542025976079676424839948500020664227027300010929",
      "4384117336930380014868572224801371377488688194169758696438185377724744869360"
    ],
    [
      "21725577575710270071808882335900370909424604447083353471892004026180492193649",
      "676128913284806802699862508051022306366147359505124346651466289788974059668",
      "25186611339598418732666781049829183886812651492845008333418424746493100589207"
    ],
    [
      "10402240124664763733060094237696964473609580414190944671778761753887884341073",
      "11918307118590866200687906627767559273324023585642003803337447146531313172441",
      "16895677254395661024186292503536662354181715337630376909778003268311296637301"
    ],
    [
      "23818602699032741669874498456696325705498383130221297580399035778119213224810",
      "4285193711150023248690088154344086684336247475445482883105661485741762600154",
      "19133204443389422404056150665863951250222934590192266371578950735825153238612"
    ],
    [
      "5515589673266504033533906836494002702866463791762187140099560583198974233395",
      "11830435563729472715615302060564876527985621376031612798386367965451821182352",
      "7510711479224915247011074129666445216001563200717943545636462819681638560128"
    ],
    [
      "24694843201907722940091503626731830056550128225297370217610328578733387733444",
      "27361655066973784653563425664091383058914302579694897188019422193564924110528",
      "21606788186194534241166833954371013788633495786419718955480491478044413102713"
    ],
    [
      "19934060063390905409309407607814787335159021816537006003398035237707924006757",
      "8495813630060004961768092461554180468161254914257386012937942498774724649553",
      "27524960680529762202005330464726908693944660961000958842417927307941561848461"
    ],
    [
      "15178481650950399259757805400615635703086255035073919114667254549690862896985",
      "16164780354695672259791105197274509251141405713012804937107314962551600380870",
      "10529167793600778056702353412758954281652843049850979705476598375597148191979"
    ],
    [
      "721141070179074082553302896292167103755384741083338957818644728290501449040",
      "22044408985956234023934090378372374883099115753118261312473550998188148912041",
      "27068254103241989852888872162525066148367014691482601147536314217249046186315"
    ],
    [
      "3880429241956357176819112098792744584376727450211873998699580893624868748961",
      "17387097125522937623262508065966749501583017524609697127088211568136333655623",
      "6256814421247770895467770393029354017922744712896100913895513234184920631289"
    ],
    [
      "2942627347777337187690939671601251987500285937340386328746818861972711408579",
      "24031654937764287280548628128490074801809101323243546313826173430897408945397",
      "14401457902976567713827506689641442844921449636054278900045849050301331732143"
    ],
    [
      "20170632877385406450742199836933900257692624353889848352407590794211839130727",
      "24056496193857444725324410428861722338174099794084586764867109123681727290181",
      "11257913009612703357266904349759250619633397075667824800196659858304604714965"
    ],
    [
      "22228158921984425749199071461510152694025757871561406897041788037116931009246",
      "9152163378317846541430311327336774331416267016980485920222768197583559318682",
      "13906695403538884432896105059360907560653506400343268230130536740148070289175"
    ],
    [
      "7220714562509721437034241786731185291972496952091254931195414855962344025067",
      "27608867305903811397208862801981345878179337369367554478205559689592889691927",
      "13288465747219756218882697408422850918209170830515545272152965967042670763153"
    ],
    [
      "8251343892709140154567051772980662609566359215743613773155065627504813327653",
      "22035238365102171608166944627493632660244312563934708756134297161332908879090",
      "13560937766273321037807329177749403409731524715067067740487246745322577571823"
    ],
    [
      "21652518608959234550262559135285358020552897349934571164032339186996805408040",
      "22479086963324173427634460342145551255011746993910136574926173581069603086891",
      "13676501958531751140966255121288182631772843001727158043704693838707387130095"
    ],
    [
      "5680310394102577950568930199056707827608275306479994663197187031893244826674",
      "25125360450906166639190392763071557410047335755341060350879819485506243289998",
      "22659254028501616785029594492374243581602744364859762239504348429834224676676"
    ],
    [
      "23101411405087512171421838856759448177512679869882987631073569441496722536782",
      "24149774013240355952057123660656464942409328637280437515964899830988178868108",
      "5782097512368226173095183217893826020351125522160843964147125728530147423065"
    ],
    [
      "13540762114500083869920564649399977644344247485313990448129838910231204868111",
      "20421637734328811337527547703833013277831804985438407401987624070721139913982",
      "7742664118615900772129122541139124149525273579639574972380600206383923500701"
    ],
    [
      "1109643801053963021778418773196543643970146666329661268825691230294798976318",
      "16580663920817053843121063692728699890952505074386761779275436996241901223840",
      "14638514680222429058240285918830106208025229459346033470787111294847121792366"
    ],
    [
      "17080385857812672649489217965285727739557573467014392822992021264701563205891",
      "26176268111736737558502775993925696791974738793095023824029827577569530708665",
      "4382756253392449071896813428140986330161215829425086284611219278674857536001"
    ],
    [
      "13934033814940585315406666445960471293638427404971553891617533231178815348902",
      "27054912732979753314774418228399230433963143177662848084045249524271046173121",
      "28916070403698593376490976676534962592542013020010643734621202484860041243391"
    ],
    [
      "24820015636966360150164458094894587765384135259446295278101998130934963922381",
      "7969535238488580655870884015145760954416088335296905520306227531221721881868",
      "7690547696740080985104189563436871930607055124031711216224219523236060212249"
    ],
    [
      "9712576468091272384496248353414290908377825697488757134833205246106605867289",
      "12148698031438398980683630141370402088785182722473169207262735228500190477924",
      "14359657643133476969781351728574842164124292705609900285041476162075031948227"
    ],
    [
      "23563839965372067275137992801035780013422228997724286060975035719045352435470",
      "4184634822776323233231956802962638484057536837393405750680645555481330909086",
      "16249511905185772125762038789038193114431085603985079639889795722501216492487"
    ],
    [
      "11001863048692031559800673473526311616702863826063550559568315794438941516621",
      "4702354107983530219070178410740869035350641284373933887080161024348425080464",
      "23751680507533064238793742311430343910720206725883441625894258483004979501613"
    ],
    [
      "28670526516158451470169873496541739545860177757793329093045522432279094518766",
      "3568312993091537758218792253361873752799472566055209125947589819564395417072",
      "1819755756343439646550062754332039103654718693246396323207323333948654200950"
    ],
    [
      "5372129954699791301953948907349887257752247843844511069896766784624930478273",
      "17512156688034945920605615850550150476471921176481039715733979181538491476080",
      "25777105342317622165159064911913148785971147228777677435200128966844208883059"
    ],
    [
      "25350392006158741749134238306326265756085455157012701586003300872637887157982",
      "20096724945283767296886159120145376967480397366990493578897615204296873954844",
      "8063283381910110762785892100479219642751540456251198202214433355775540036851"
    ],
    [
      "4393613870462297385565277757207010824900723217720226130342463666351557475823",
      "9874972555132910032057499689351411450892722671352476280351715757363137891038",
      "23590926474329902351439438151596866311245682682435235170001347511997242904868"
    ],
    [
      "17723373371137275859467518615551278584842947963894791032296774955869958211070",
      "2350345015303336966039836492267992193191479606566494799781846958620636621159",
      "27755207882790211140683010581856487965587066971982625511152297537534623405016"
    ],
    [
      "6584607987789185408123601849106260907671314994378225066806060862710814193906",
      "609759108847171587253578490536519506369136135254150754300671591987320319770",
      "28435187585965602110074342250910608316032945187476441868666714022529803033083"
    ],
    [
      "16016664911651770663938916450245705908287192964254704641717751103464322455303",
      "17551273293154696089066968171579395800922204266630874071186322718903959339163",
      "20414195497994754529479032467015716938594722029047207834858832838081413050198"
    ],
    [
      "19773307918850685463180290966774465805537520595602496529624568184993487593855",
      "24598603838812162820757838364185126333280131847747737533989799467867231166980",
      "11040972566103463398651864390163813377135738019556270484707889323659789290225"
    ],
    [
      "5189242080957784038860188184443287562488963023922086723850863987437818393811",
      "1435203288979376557721239239445613396009633263160237764653161500252258220144",
      "13066591163578079667911016543985168493088721636164837520689376346534152547210"
    ],
    [
      "17345901407013599418148210465150865782628422047458024807490502489711252831342",
      "22139633362249671900128029132387275539363684188353969065288495002671733200348",
      "1061056418502836172283188490483332922126033656372467737207927075184389487061"
    ],
    [
      "10241738906190857416046229928455551829189196941239601756375665129874835232299",
      "27808033332417845112292408673209999320983657696373938259351951416571545364415",
      "18820154989873674261497645724903918046694142479240549687085662625471577737140"
    ],
    [
      "7983688435214640842673294735439196010654951226956101271763849527529940619307",
      "17067928657801807648925755556866676899145460770352731818062909643149568271566",
      "24472070825156236829515738091791182856425635433388202153358580534810244942762"
    ],
    [
      "25752201169361795911258625731016717414310986450004737514595241038036936283227",
      "26041505376284666160132119888949817249574689146924196064963008712979256107535",
      "23977050489096115210391718599021827780049209314283111721864956071820102846008"
    ],
    [
      "26678257097278788410676026718736087312816016749016738933942134600725962413805",
      "10480026985951498884090911619636977502506079971893083605102044931823547311729",
      "21126631300593007055117122830961273871167754554670317425822083333557535463396"
    ],
    [
      "1564862894215434177641156287699106659379648851457681469848362532131406827573",
      "13247162472821152334486419054854847522301612781818744556576865965657773174584",
      "8673615954922496961704442777870253767001276027366984739283715623634850885984"
    ],
    [
      "2794525076937490807476666942602262298677291735723129868457629508555429470085",
      "4656175953888995612264371467596648522808911819700660048695373348629527757049",
      "23221574237857660318443567292601561932489621919104226163978909845174616477329"
    ],
    [
      "1878392460078272317716114458784636517603142716091316893054365153068227117145",
      "2370412714505757731457251173604396662292063533194555369091306667486647634097",
      "17409784861870189930766639925394191888667317762328427589153989811980152373276"
    ],
    [
      "25869136641898166514111941708608048269584233242773814014385564101168774293194",
      "11361209360311194794795494027949518465383235799633128250259863567683341091323",
      "14913258820718821235077379851098720071902170702113538811112331615559409988569"
    ],
    [
      "12957012022018304419868287033513141736995211906682903915897515954290678373899",
      "17128889547450684566010972445328859295804027707361763477802050112063630550300",
      "23329219085372232771288306767242735245018143857623151155581182779769305489903"
    ],
    [
      "1607741027962933685476527275858938699728586794398382348454736018784568853937",
      "2611953825405141009309433982109911976923326848135736099261873796908057448476",
      "7372230383134982628913227482618052530364724821976589156840317933676130378411"
    ],
    [
      "20203606758501212620842735123770014952499754751430660463060696990317556818571",
      "4678361398979174017885631008335559529633853759463947250620930343087749944307",
      "27176462634198471376002287271754121925750749676999036165457559387195124025594"
    ],
    [
      "6361981813552614697928697527332318530502852015189048838072565811230204474643",
      "13815234633287489023151647353581705241145927054858922281829444557905946323248",
      "10888828634279127981352133512429657747610298502219125571406085952954136470354"
    ]
  ],
  "fullRounds": 55,
  "partialRounds": 0,
  "hasInitialRoundConstant": false,
  "stateSize": 3,
  "rate": 2,
  "power": 7
};
var poseidonParamsLegacyFp = {
  "mds": [
    [
      "5328350144166205084223774245058198666309664348635459768305312917086056785354",
      "15214731724107930304595906373487084110291887262136882623959435918484004667388",
      "22399519358931858664262538157042328690232277435337286643350379269028878354609"
    ],
    [
      "10086628405675314879458652402278736459294354590428582803795166650930540770072",
      "17127968360683744052278857147989507037142007029142438136689352416106177192235",
      "14207324749280135281015658576564097509614634975132487654324863824516044294735"
    ],
    [
      "3059104278162906687184746935153057867173086006783171716838577369156969739687",
      "16755849208683706534025643823697988418063305979108082130624352443958404325985",
      "16889774624482628108075965871448623911656600744832339664842346756371603433407"
    ]
  ],
  "roundConstants": [
    [
      "1346081094044643970582493287085428191977688221215786919106342366360741041016",
      "10635969173348128974923358283368657934408577270968219574411363948927109531877",
      "18431955373344919956072236142080066866861234899777299873162413437379924987003"
    ],
    [
      "5797044060651575840084283729791357462720161727701814038830889113712361837236",
      "931288489507796144596974766082847744938192694315568692730730202141894005205",
      "13659894470945121760517769979107966886673294523737498361566285362771110125394"
    ],
    [
      "6076231707445968054305995680347976771585015308155855387339303513025362636128",
      "28822740034050339685362260108484262889265034407340240070058997651710236456303",
      "23420266473857869790486107029614186913447272961845992963194006142267563993493"
    ],
    [
      "13753917374184785903125509246122783296344288469304898921025291716613575849357",
      "22396739346703340038555577564698139382745239004673153148674304627904081092826",
      "13064238335532551154986111986409392866270911640785653458047811526842088084911"
    ],
    [
      "23165923875642452719095776619341762858050322341374771345641255745672274104746",
      "1876216571769482372914291210815859835162659440705283782713345335434924136736",
      "25448252060136178247213604035267580231762596830634036926922217427938159849142"
    ],
    [
      "2161875315509206970842862195937323600322108268401381254431163181777726747153",
      "19159855698625842998331760283165907305622417625829203038229273729196960321630",
      "24828563875172432296791053766778475681869974948122169083176331088266823626561"
    ],
    [
      "15959479662608710141128458274961057999257961784282074767105536637788386907463",
      "8006369581283017287449277389162056290714176164680299906116833200510117952858",
      "18794336794618132129607701188430371953320538976527988886453665523008714542779"
    ],
    [
      "19408271715954593722501381885401160867835377473312521553027032015227895029571",
      "13654747284005184272412579731446984220568337794941823533879059135026064413631",
      "14094055032353750931629930778481002727722804310855727808905931659115939920989"
    ],
    [
      "13241818625838429282823260827177433104574315653706102174619924764342778921524",
      "25709259239494174564705048436260891089407557689981668111890003079561388887725",
      "26866626910239634723971078462134580196819809568632305020800296809092442642381"
    ],
    [
      "23886826350713085163238005260075062110062681905356997481925492650252417143049",
      "16853602711255261520713463306790360324679500458440235992292027384928526778856",
      "18444710386168488194610417945072711530390091945738595259171890487504771614189"
    ],
    [
      "16896789009769903615328691751424474161656500693270070895928499575572871141439",
      "23842266984616972287898037872537536999393060934879414668030219493005225085992",
      "24369698563802298585444760814856330583118549706483939267059237951238240608187"
    ],
    [
      "25360195173713628054110426524260405937218170863260484655473435413697869858790",
      "1486437708678506228822038923353468635394979165769861487132708983207562337116",
      "18653498960429911228442559598959970807723487073275324556015861725806677047150"
    ],
    [
      "18878179044241268037057256060083772636369783391816038647949347814518015576522",
      "178715779905629247116805974152863592571182389085419970371289655361443016848",
      "8381006794425876451998903949255801618132578446062133243427381291481465852184"
    ],
    [
      "4176946262813877719206528849579392120806054050640974718891398605746592169324",
      "16376345520728802444699629729684297833862527190772376028981704525651968727081",
      "8399065769082251057361366626601550736334213197703006866551331927128775757919"
    ],
    [
      "15435308585611812393531506745122614542196708285088622615406141986333182280857",
      "4082259282787276939431186930090898350392871145699460879678141552997816391817",
      "26348742719959309014730178326877937464605873211235784184917342950648457078699"
    ],
    [
      "9707631711734344681918469569872517425107158187591261754498805460753455298868",
      "27910768846011709391567916011595957279088224137468948238696800459136335473132",
      "20407239095656434708569263842372155762970847207558227886302782130015730063802"
    ],
    [
      "22726225412881182965250630589245572283256255052470345984553083359461473893802",
      "12443967854426795490638709950679156338200426963050610832781263082981525248175",
      "27102543658848146076219989119639465430524061997280788166887046421706499775415"
    ],
    [
      "14427224233985680214097547669945064793149553513421479297921556194475574770861",
      "22917454832925781549840198815703114840452733537799472739275668965081704937832",
      "3455076056123630366063931123762198941796412458154689469887583689725886013901"
    ],
    [
      "4513100023937785913596662867311227004762025658663076805918211014066645403017",
      "18187619530784075723418065322038024507729605774832001333883311123910954334059",
      "9447065431426150382325592560406989926365684509675374414068135115024495130938"
    ],
    [
      "3227816098015819796753427754968234889554095489076864339942014527747604603014",
      "14798316759185072116520458171957899889489461918408669809912344751222514418582",
      "23013904852315603905843158448056763116188801262838729536210355401378476650033"
    ],
    [
      "20979191509934291452182967564058656088941447895799901211038858159903580333267",
      "20772973010251235271448378823573767262405703078344288856168565499702414379868",
      "10105446427739226002497411811738001382334316505480517822035303561899927603685"
    ],
    [
      "11079074761356717003579108002319997196881121172538617046865136940931215263187",
      "4693927775411489288330326150094711670434597808961717172753867514688725690438",
      "18581720304902876944842830383273503265470859268712618325357902881821721540119"
    ],
    [
      "3065369948183164725765083504606321683481629263177690053939474679689088169185",
      "18515622379147081456114962668688706121098539582467584736624699157043365677487",
      "17563088600719312877716085528177751048248154461245613291986010180187238198006"
    ],
    [
      "26199746176994924146211004840756471702409132230831594954444947705902602287290",
      "7576136600627345523051497639367002272003104458453478964661395239732811642605",
      "20058687874612168338994287374025378897088936171250328231848098497610185784281"
    ],
    [
      "16894722532414195606958290526999761110785277556463400588047573469106594850228",
      "13961730805696859614283621225672002906734926278118993580398533742874863598733",
      "25256842011135514243352951950573936602906198374305137963222382546140030647211"
    ],
    [
      "18530360047537856737482157200091774590035773602620205695980247565433703032532",
      "23014819965938599260086897799541446473887833964178378497976832161473586995397",
      "27911426213258307990762460361663504655967992659180759140364181941291843542489"
    ],
    [
      "1067338118323302017358103178057182291035336430305886255160210378977812067042",
      "17219092885519007424608854460610388434712113621163885775309496940189894433620",
      "16432921127615937542183846559291144733339643093361323334499888895135356545408"
    ],
    [
      "28608851042959977114787048070153637607786033079364369200270218128830983558707",
      "10121629780013165888398831090128011045011860641816380162950736555305748332191",
      "2348036340843128746981122630521268144839343500596932561106759754644596320722"
    ],
    [
      "16619881370356823200358060093334065394764987467483650323706184068451904156452",
      "2302436627861989749837563733434625231689351276818486757748445924305258835336",
      "27514536540953539473280001431110316405453388911725550380123851609652679788049"
    ],
    [
      "9459277727420672604737117687200019308525004979918488827092207438664125039815",
      "23425670740358068509956137586663046763224562225383386726193078231034380596217",
      "7641885067011661443791509688937280323563328029517832788240965464798835873658"
    ],
    [
      "9579420382351699601929202663836555665702024548386778299996961509578687980280",
      "18513671386572584282611234979588379470994484682444053600751415262497237017703",
      "24923151431234706142737221165378041700050312199585085101919834422744926421604"
    ],
    [
      "21131320841803068139502705966375283830095161079635803028011171241658723560073",
      "19208476595309656066589572658712717685014329237892885950958199953675225096566",
      "24023185216737416080949689106968568821656545490748664446389634158498624398204"
    ],
    [
      "7510552996848634969347937904645640209946785877619890235458182993413526028718",
      "3694415017252995094553868781762548289196990492336482360084813900937464847638",
      "9219021070107873028263141554048987416559034633883158827414043929220388719352"
    ],
    [
      "5058327241234443421111591959922712922949620710493120384930391763032694640881",
      "13148252221647574076185511663661016015859769210867362839817254885265598775418",
      "15186790492457240277904880519227706403545816456632095870015828239411033220638"
    ],
    [
      "2775942914650502409705888572245750999561427024488403026572311267798009048466",
      "6277965230841030155341171319927732572492215818164736949144854827643964384893",
      "24144742149845235561087977558785057713814731737434473021812189457617252043745"
    ],
    [
      "25789129719327437503403457598813971826156253950521984610569937361506914183550",
      "21500534320778995945845999974779950304491968082325255355181901574840373597824",
      "17185359848218837018503091932245529880546896465437232425673134558221638601375"
    ],
    [
      "12253896579078110143384981818031883112606762215016553811786428215758384195713",
      "12956658260778456372481429232709881794962204180363200699121804724437678625542",
      "3023603786717368708677300377055384474816569333060487675635618249403832078921"
    ],
    [
      "4186492855716808019562789862833898284927736051002588766326482010810259565130",
      "4263939782228419774639068267872291539552889472311225829898746091327730032923",
      "24068843626280451423530509388397151179174104901782990365720205643492047328816"
    ],
    [
      "14564937827374621319716285527475223392664010281568256859627186463065876537730",
      "28367596550218705971881480694115935470211319172596432472834880507822452927283",
      "28712267437482356021504544448225827500268648754270274754623969882031853409874"
    ],
    [
      "4542596163006916397403529184431773692747461300288194722982487051249951403191",
      "2530461821259252672899452671728393208543894014761816288817584587718369998371",
      "12886393063011539390567049190923398676964700147222878509238966758839020897414"
    ],
    [
      "21593897590707514492037699253654745501762191795293908682495110982956631870528",
      "13233005790593128135480716846773978578237145313006994631606474472023504621256",
      "21621863098292803642478350494794106282518362577273973885587684567452726939909"
    ],
    [
      "26068620073001644720969640099644251616742620988609091568084348314770436291745",
      "18248589586787935500122854210401321966459127818593446990365211078521058875685",
      "21247134484403265289037859533347798468858819117600251067578809852124865474448"
    ],
    [
      "7947383127165915366383984718363902897504221803836013123394785749404572432524",
      "22173041014621867335598230447618036223462011647696367239478182269973488867154",
      "16773227734018849308448505860847939069870370055633571816925675705713088305139"
    ],
    [
      "10708707957340055662073314227607620808612686977606082605219160019699644826999",
      "21249897193797038261479589555720746994050836195265348846222835266344091683000",
      "12581195059139097540117398803363514148192715293133623516709277290477633379593"
    ],
    [
      "19779599816866992123290302397082614570282926215253589712189610064229996603178",
      "21749216503901548676985371189807470207364320167486559936962401093285243029177",
      "17600045923623503357380202389718735904174992978547372448837488832457719009224"
    ],
    [
      "2732872979548118117758016335601225525660858727422778256671975055129965858636",
      "13703031005128062046175331918702218558750713240446179585947851411173844703597",
      "28447710105386636841938034820015573492556750872924193415447818187228356409281"
    ],
    [
      "28539960355005748517007309210788803416171161412204526246799800716567376494244",
      "21329318452221893900731030722137844458345358926323127858742388587761302609863",
      "28135302149599894709369178097439582767613940517471323224020113411362601191873"
    ],
    [
      "24980774120400248734054527936006392540889095705961960837980443629260392758683",
      "20339911045808632098936066397942175169549806052128535543540543556255197716643",
      "7929293103930252545581851978492699598413941396422930641071359388697302362494"
    ],
    [
      "8911092207145893152276662096451247820054843777071569723455408545101628926203",
      "19648860643145256523615441075182036100116634560394529500146405733687718224516",
      "14635387208623683806428528837466762532853903031263830054986064902455379735903"
    ],
    [
      "11555212214346132926966321609673228184079851030522218543981385635403167028692",
      "20896918157639814425520058178561910811657326967880217845710779511927814874973",
      "4650158165912007049140499755153804318686705949436165235742106170124284287326"
    ],
    [
      "13880660273492757167295696447853232191657893303250187467329180558670697369810",
      "8043529172463774320604378774840863923445982272478964686447801046272917236836",
      "2134399296482715903442913099374581981696436050603410080564843555725771329441"
    ],
    [
      "27320952903412641133501507962185246982787769547770982814240701526492601978122",
      "23417491374379751329394424924400186404791519133465537872457405970098902747611",
      "17612427354278346772575179176139417348059847375297761006336024476146551185903"
    ],
    [
      "10710998507064742997612080847223278109404482930427999113323732519626499166548",
      "14958094513415797513745395709487730603918953350067504982704138489305723550923",
      "24096319595904213497633343966229498735553590589105811393277073274927955202995"
    ],
    [
      "17983724131200292654039765185049138356840415443160477259330748730019147254309",
      "17598096800487588874709548646068838880468456205252324677357706597166777506441",
      "27420647821110229619898200875848631488422182349567475956209153112306555222281"
    ],
    [
      "448538544835457571662601142415301047108854812427100562339376187510452313026",
      "23494184556634922103535803143214434479598067155171780264810485708203176455201",
      "22626342941879801989161990529511235538216563009907378573817996229389756621777"
    ],
    [
      "26128268137723417163973860961686381960826033145738852158792607959175787222856",
      "20225791828042873305317281581105429726352058325970107209484198122707862156597",
      "7538871133759632802857159609785118198934349221046986784429069814655215585732"
    ],
    [
      "26184554861259642274153262777073624024579929401668865520166966302070394487366",
      "28755259264665180745537307265993667261709206143628938749669440804401623257679",
      "11896066093033549470312328497237649508068258723531931099214795928200015717321"
    ],
    [
      "21657721599978732693249012287058163532690942515202465984736373311077240614059",
      "9214914097169852704753116653702415951907628005986883140609006971322091003693",
      "18710111680849814325169297240208687402588261569152088592693815711857504371037"
    ],
    [
      "6813635166770764528979084175325709935892248249948967889926276426090222296643",
      "20546585456429436268067726231902751119458200511988152296570567167520382569278",
      "20087466019194902429054761607398988292568594301671509779549344754172952693871"
    ],
    [
      "28185105286740691904534067831357491310995891986363455251895371651360605333143",
      "10108348212894231193041286244259038275269464277821588425688314560368589986063",
      "11433633215392393209829215018579238412423821563056156785641278458497271271546"
    ],
    [
      "27870881917195016999862550657996865268956893566432995492427618003637597051321",
      "102309803677783876701097881491240456320211833502658383473112057006867019389",
      "22844040227595875612525628393174357057929113317578127744718774517498324646590"
    ],
    [
      "18364790233947478619325319418813215212267974311771564959136180502266118026133",
      "2480624341921718230432383518425561514824501138863702825916674641657321180841",
      "16778939567530361665956758171503829349658551798564323167725356065198936433124"
    ],
    [
      "11947564511486966895926950599696532964589539443187518177489990556481125699966",
      "3133187646540385483015602955087323554103587039123577645562801570574691666057",
      "27704797101265438206569218421707753788081674727344603874614391656565567951541"
    ],
    [
      "13001484695584753475562184349533365512515447041450030471627087395341039487710",
      "477322000667279478600757543806155989948171541982639893984064422067850617496",
      "13913755821658634147813329813115566967428755223601185963529801459396673113438"
    ],
    [
      "16621869429023470107454028095846067937827722393398508604914831452950874033411",
      "21755744236927410239079501831014076529931327263341620300431356747367343619046",
      "26538666591151124505694487799121414506088199961481579132019627484065014831180"
    ],
    [
      "3066480818457008068617042549071052338581291837882909165666223566402713429090",
      "16182268213934119294035309949459684472027705439038023775276926916166831108357",
      "28907604876608422892474268478706783033050951245339691569015166507728369585190"
    ],
    [
      "27973960109508292680965426133498827831691369851701664449575719912259359998113",
      "1456924360278399121996742356757866616312146358469991014696110099534285524446",
      "8234248752911525485438611255163504976087091103090603316695312869292347668495"
    ],
    [
      "8716078950082339630026654067608811496722305720644485560320987802533380421009",
      "19016744645809919602099479306503354923553336014593353020688463619133130053825",
      "24379650661051444982012238084495990858827340608012118841005379796362233056432"
    ],
    [
      "2245379544097631382062919677963998259142792890502492881341386639439507471783",
      "28788137434161061988371619554419440748189388934884757179010092973102292086583",
      "7187000185648741287953633167647835668543536354944774631102766873251849991238"
    ],
    [
      "18319349500538500800225762827448369057030532278398270164660609327776487168142",
      "2622932985948021877314529887962683530522545893985767148345336304947201715671",
      "13805188629797792210337544360632964855143280581052079479249966961215582531026"
    ],
    [
      "27457600993464082637917106210690168172469473943609357897393615707457194410878",
      "15448646156961779103834447043970817898237835202826003934642165760908058355399",
      "9396792545729486882231669677795667529746274932273033601723318032992363022062"
    ],
    [
      "9927877141952679457141759789181418464292082444806533413864151258248124544859",
      "23827901395971835838179844085051957393677906360196119690926757794561937573142",
      "3273544693673216914876067527455588276979859627093391584406340272737391174619"
    ],
    [
      "19571510438350300564152393820251652609646082150148656806391655428002614034315",
      "4458840243585913642400750597703353770666314833058197517675446022682775625834",
      "6452218213610300363069953741424106105609715382419342511693148495219793324457"
    ],
    [
      "14558167930891460678441266912176752652821641543245953113671886345167213541771",
      "10650967986920075561478528461783351160938460620955779955379459848889204404950",
      "19990009778942542934049216419052172134625404062770188357110708518621145688588"
    ],
    [
      "26855242974447190235826233682457047761532515293146087151296725996543442567035",
      "22785340043356532865086769889360674409753343398766563441587096485751538658065",
      "28603049427449348335651629195385434188071937908693764500052489540779792538285"
    ],
    [
      "20545812864989828913452616721240947168977365844984763819184465128164378967167",
      "23234068381345797209897730226956922073109641728569353961504167817770340037954",
      "26031714567641615877877111172701145299483019910006153132858512509897185854695"
    ],
    [
      "9512221744061419790435674197238913998387834650389922233458121639503195504983",
      "12587458000103271975978240683793268604398305885278203470492658961734100340536",
      "9670291694005369437277651504604785512303147991710650505302465204429311229197"
    ],
    [
      "26995526763045548800439747262386290359229145489609341602564040676717570935439",
      "23742712112104280264401317024221734961713400615669958343926511931219510484675",
      "27931469778579449247589315744656633392873808631802461175539563849884447358271"
    ],
    [
      "20669006894143187877081688942720159738269397552445286314270368345994751825389",
      "26891772301075275370472640177651637211280740381619976926886106618375467277414",
      "28387986011980449959047232529988203397251084614417760995257355718700961696092"
    ],
    [
      "6579105010484741592730389416372694666279917604793318157514380025250233913402",
      "11007035767869292700964744408562802781669930023548892567535397874932420229930",
      "981148366863906885900456473323410468923514528856216824044152942069412627408"
    ],
    [
      "22213671088722307302576907504985884923571642958053627659840326928319445671280",
      "1318836216310789598614608105109389429335273432455224127576823891011367206122",
      "25586582796990779718352441955439394949194222626688223867952982491529809559257"
    ],
    [
      "4923739488579452777913681531125585976446366144127161879759262506690369040090",
      "23505612338866210737103599484620591026802005128655081877133994175016351514827",
      "323887003859465324514901860965142186539600668250760639664361851354147799637"
    ],
    [
      "10198923064967306784017949469108033682156920551672348936591491217255268794658",
      "9593680688139131432883442351722730169325112619984238956948153423155998917175",
      "27027988263960602112273050725720071355535922812577299127302015348825197871870"
    ],
    [
      "14419883951157390867695097127684346981136020111885301573583640959136319507752",
      "5104414988075833278683649298543440897371415916271358703850262680431809374355",
      "24739655595299332818980677669648719986462429574612913501586844601377825836782"
    ],
    [
      "28522818684103966731129743408029731246564480741348128436668680764518115102581",
      "21520350704208288978690888796633940487888044365108767319141211249242880355961",
      "17391005598311948834360476853940353239444383292422171321575043660157438608537"
    ],
    [
      "15367833944125677011173327826570204350687925236257190051755087781855930646142",
      "21715073802090413714601069529558707101797361591183718695054701329871284436172",
      "8994093285353831008525761670339342200997965950202092028313103110478252647618"
    ],
    [
      "8370824693889782161629525898408725452177580012023459750897244954935682978671",
      "16123253540853556024347150096993154278773652905830608614979368087152152043083",
      "3535380953353495025888433493640531836449699255364366295870140701379497967423"
    ],
    [
      "6954518484798178646508803478426114267143074508396663899281411171704702743829",
      "28903134801897070276701950388422104654018369750191967384271618837091859516942",
      "20872505363530172448468374920196608937030884647150175861507911076568784054834"
    ],
    [
      "6902861581703501105786795670676641959401710346423594578401934671029571262513",
      "10124161387604183369443890585742198433184078889862870469507328332805848271064",
      "10488004060799269337071647841224034919633445750252076195310163972966405029030"
    ],
    [
      "507704911991278613147490289466075160618843900088471236546244459176211783848",
      "7252739745607302667257774481690407709040936359589867974787811552896597703097",
      "23278073497974004442836030100920157527910770509761505828038443336325476654930"
    ],
    [
      "22766285055433137793164317120096790621982728188995759745859222009100808389090",
      "23129058299483468195787339200845749049960038336751758017949899311636830205152",
      "16665333681978951552434356320651834889869437822496200946959897681307959400425"
    ],
    [
      "12145699202182574939376505075528461451757079041659894988784442097333218352048",
      "26340666275844437932755852805027863696219004039301187587209926587657008948704",
      "19208771804191839410002226941825269105677187954811130189835856228258013753206"
    ],
    [
      "21957102494792377508237608216278079874536155315851198461024084071231867104453",
      "6933367436450995525851693784691226222726503560893470094614235356287049091852",
      "15707767379191450768747057313641112321773921923533732633534831270357733757271"
    ],
    [
      "27661963645951389261638591385668507557739541354225916772550248746235106571003",
      "19699458096897937575096494582288688995241392471402204995195057374756282223421",
      "902873385171181344315871113842580653512118892800584003934454469411716098791"
    ],
    [
      "17184835876565576154014372215369798779520343573944211203710896053325717110660",
      "664657295519303589036289440053175741110032988007278988577620229144220576240",
      "10803972669668998371638869508774217165881281885838503958226056357738500321396"
    ],
    [
      "2329846733754251453632375727999372856194157027336139087170310553870624325301",
      "14139944357035048486675740400655356660678187875721949218090128899571575479791",
      "18368148273419807418427674359327442879484531833435081951870369910704734685351"
    ],
    [
      "10480273665080572189328459165704340191901489646067580012574464138528963201459",
      "21773636700078124500346009061678153597323236568110076029811348966753228682835",
      "18184268307211429260956076021417309535471438696101133218049142374847151474905"
    ],
    [
      "25957533025669311312382992376854735734491934602484112256289764602447226406852",
      "22223261506176684934865714490719116745135417403915426392159449667435294570739",
      "22937309162832499167063076416585504361695925730111272512450449042837586253575"
    ],
    [
      "16956181785481598286719868503945127919581091625126206673934113115358441284347",
      "8497782777197814773596870810881707148695901557289856910220737358078100998191",
      "21135503731586600979470064722475007625236017670426339278983640892218291297054"
    ],
    [
      "17809297343844488723046665739910571149089769215421130894378638450427880983923",
      "72435395972188389387093550708873189001876361107443937983754878061522372356",
      "7511239878692099209014947248389283109997289411550315391143819429585903287870"
    ]
  ],
  "fullRounds": 63,
  "partialRounds": 0,
  "hasInitialRoundConstant": true,
  "stateSize": 3,
  "rate": 2,
  "power": 5
};
var mocks = {
  "dummyVerificationKeyHash": "3392518251768960475377392625298437850623664973002200885669375116181514017494"
};

// dist/node/lib/ml/base.js
var MlArray = {
  to(arr) {
    return [0, ...arr];
  },
  from([, ...arr]) {
    return arr;
  },
  map([, ...arr], map) {
    return [0, ...arr.map(map)];
  },
  mapTo(arr, map) {
    return [0, ...arr.map(map)];
  },
  mapFrom([, ...arr], map) {
    return arr.map(map);
  }
};
var MlPair = Object.assign(function MlTuple(x, y) {
  return [0, x, y];
}, {
  from([, x, y]) {
    return [x, y];
  },
  first(t) {
    return t[1];
  },
  second(t) {
    return t[2];
  }
});
var MlBool = Object.assign(function MlBool2(b2) {
  return b2 ? 1 : 0;
}, {
  from(b2) {
    return !!b2;
  }
});
var MlOption = Object.assign(function MlOption2(x) {
  return x === void 0 ? 0 : [0, x];
}, {
  from(option) {
    return option === 0 ? void 0 : option[1];
  },
  map(option, map) {
    if (option === 0)
      return 0;
    return [0, map(option[1])];
  },
  mapFrom(option, map) {
    if (option === 0)
      return void 0;
    return map(option[1]);
  },
  mapTo(option, map) {
    if (option === void 0)
      return 0;
    return [0, map(option)];
  },
  isNone(option) {
    return option === 0;
  },
  isSome(option) {
    return option !== 0;
  }
});
var MlResult = {
  ok(t) {
    return [0, t];
  },
  unitError() {
    return [1, 0];
  }
};
var MlTuple2 = {
  map([, ...mlTuple], f) {
    return [0, ...mlTuple.map(f)];
  },
  mapFrom([, ...mlTuple], f) {
    return mlTuple.map(f);
  },
  mapTo(tuple2, f) {
    return [0, ...tuple2.map(f)];
  }
};

// dist/node/bindings/crypto/bindings/util.js
function withPrefix(prefix, obj) {
  return Object.fromEntries(Object.entries(obj).map(([k, v]) => {
    return [`${prefix}_${k}`, v];
  }));
}
function mapTuple(tuple2, f) {
  return tuple2.map(f);
}

// dist/node/bindings/crypto/bindings/bigint256.js
var Bigint256Bindings = withPrefix("caml_bigint_256", {
  // TODO
  of_numeral(s, i2, j) {
    throw Error("caml_bigint_256_of_numeral not implemented");
  },
  of_decimal_string(s) {
    return [0, BigInt(fromMlString(s))];
  },
  num_limbs() {
    return 4;
  },
  bytes_per_limb() {
    return 8;
  },
  div([, x], [, y]) {
    return [0, x / y];
  },
  compare([, x], [, y]) {
    if (x < y)
      return -1;
    if (x === y)
      return 0;
    return 1;
  },
  print([, x]) {
    console.log(x.toString());
  },
  to_string(x) {
    return toMlStringAscii(x[1].toString());
  },
  // TODO performance critical
  test_bit(b2, i2) {
    return MlBool(!!(b2[1] & 1n << BigInt(i2)));
  },
  to_bytes([, x]) {
    let ocamlBytes = caml_create_bytes(32);
    for (let i2 = 0; i2 < 32; i2++) {
      let byte = Number(x & 0xffn);
      caml_bytes_unsafe_set(ocamlBytes, i2, byte);
      x >>= 8n;
    }
    if (x !== 0n)
      throw Error("bigint256 doesn't fit into 32 bytes.");
    return ocamlBytes;
  },
  of_bytes(ocamlBytes) {
    let length = ocamlBytes.l;
    if (length > 32)
      throw Error(length + " bytes don't fit into bigint256");
    let x = 0n;
    let bitPosition = 0n;
    for (let i2 = 0; i2 < length; i2++) {
      let byte = caml_bytes_unsafe_get(ocamlBytes, i2);
      x |= BigInt(byte) << bitPosition;
      bitPosition += 8n;
    }
    return [0, x];
  },
  deep_copy([, x]) {
    return [0, x];
  }
});
function fromMlString(s) {
  return s.c;
}
function toMlStringAscii(s) {
  return new MlBytes(9, s, s.length);
}
function caml_bytes_unsafe_get(s, i2) {
  switch (s.t & 6) {
    default:
      if (i2 >= s.c.length)
        return 0;
    case 0:
      return s.c.charCodeAt(i2);
    case 4:
      return s.c[i2];
  }
}
function caml_bytes_unsafe_set(s, i2, c) {
  c &= 255;
  if (s.t != 4) {
    if (i2 == s.c.length) {
      s.c += String.fromCharCode(c);
      if (i2 + 1 == s.l)
        s.t = 0;
      return 0;
    }
    caml_convert_bytes_to_array(s);
  }
  s.c[i2] = c;
  return 0;
}
function caml_create_bytes(len) {
  return new MlBytes(2, "", len);
}
function caml_convert_bytes_to_array(s) {
  let a2 = new Uint8Array(s.l);
  let b2 = s.c, l4 = b2.length, i2 = 0;
  for (; i2 < l4; i2++)
    a2[i2] = b2.charCodeAt(i2);
  for (l4 = s.l; i2 < l4; i2++)
    a2[i2] = 0;
  s.c = a2;
  s.t = 4;
  return a2;
}
var MlBytes = class _MlBytes {
  constructor(tag, content, length) {
    this.t = tag;
    this.c = content;
    this.l = length;
  }
  toString() {
    if (this.t === 9)
      return this.c;
    throw Error("todo");
  }
  toUtf16() {
    return this.toString();
  }
  slice() {
    let content = this.t == 4 ? this.c.slice() : this.c;
    return new _MlBytes(this.t, content, this.l);
  }
};

// dist/node/bindings/crypto/bigint-helpers.js
function bytesToBigint32(bytes) {
  let words = new BigUint64Array(bytes.buffer, bytes.byteOffset, 4);
  return words[0] | words[1] << 64n | words[2] << 128n | words[3] << 192n;
}
var mask64 = (1n << 64n) - 1n;
function bigintToBytes32(x, bytes) {
  let words = new BigUint64Array(bytes.buffer, bytes.byteOffset, 4);
  words[0] = x & mask64;
  words[1] = x >> 64n & mask64;
  words[2] = x >> 128n & mask64;
  words[3] = x >> 192n;
  return bytes;
}
function bytesToBigInt(bytes) {
  let x = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    x += BigInt(byte) << bitPosition;
    bitPosition += 8n;
  }
  return x;
}
var hexToNum = {};
for (let i2 = 0; i2 < 16; i2++)
  hexToNum[i2.toString(16).charCodeAt(0)] = i2;
var encoder = new TextEncoder();
var tmpBytes = new Uint8Array(64);
function parseHexString32(input) {
  encoder.encodeInto(input, tmpBytes);
  for (let j = 0; j < 32; j++) {
    let n1 = hexToNum[tmpBytes[2 * j]];
    let n0 = hexToNum[tmpBytes[2 * j + 1]];
    tmpBytes[j] = n1 << 4 | n0;
  }
  return bytesToBigint32(tmpBytes);
}
function bigIntToBytes(x, length) {
  if (x < 0n) {
    throw Error(`bigIntToBytes: negative numbers are not supported, got ${x}`);
  }
  if (length === void 0)
    return bigintToBytesFlexible(x);
  let bytes = Array(length);
  for (let i2 = 0; i2 < length; i2++, x >>= 8n) {
    bytes[i2] = Number(x & 0xffn);
  }
  if (x > 0n) {
    throw Error(`bigIntToBytes: input does not fit in ${length} bytes`);
  }
  return bytes;
}
function bigintToBytesFlexible(x) {
  let bytes = [];
  for (; x > 0n; x >>= 8n) {
    bytes.push(Number(x & 0xffn));
  }
  return bytes;
}
function bigIntToBits(x) {
  if (x < 0n) {
    throw Error(`bigIntToBits: negative numbers are not supported, got ${x}`);
  }
  let bits2 = [];
  for (; x > 0n; x >>= 1n) {
    let bit = !!(x & 1n);
    bits2.push(bit);
  }
  return bits2;
}
function changeBase(digits, base, newBase) {
  let x = fromBase(digits, base);
  let newDigits = toBase(x, newBase);
  return newDigits;
}
function fromBase(digits, base) {
  if (base <= 0n)
    throw Error("fromBase: base must be positive");
  let basePowers = [];
  for (let power2 = base, n = 1; n < digits.length; power2 **= 2n, n *= 2) {
    basePowers.push(power2);
  }
  let k = basePowers.length;
  digits = digits.concat(Array(2 ** k - digits.length).fill(0n));
  for (let i2 = 0; i2 < k; i2++) {
    let newDigits = Array(digits.length >> 1);
    let basePower = basePowers[i2];
    for (let j = 0; j < newDigits.length; j++) {
      newDigits[j] = digits[2 * j] + basePower * digits[2 * j + 1];
    }
    digits = newDigits;
  }
  console.assert(digits.length === 1);
  let [digit] = digits;
  return digit;
}
function toBase(x, base) {
  if (base <= 0n)
    throw Error("toBase: base must be positive");
  let basePowers = [];
  for (let power2 = base; power2 < x; power2 **= 2n) {
    basePowers.push(power2);
  }
  let digits = [x];
  let k = basePowers.length;
  for (let i2 = 0; i2 < k; i2++) {
    let newDigits = Array(2 * digits.length);
    let basePower = basePowers[k - 1 - i2];
    for (let j = 0; j < digits.length; j++) {
      let x2 = digits[j];
      let high = x2 / basePower;
      newDigits[2 * j + 1] = high;
      newDigits[2 * j] = x2 - high * basePower;
    }
    digits = newDigits;
  }
  while (digits[digits.length - 1] === 0n) {
    digits.pop();
  }
  return digits;
}
function log2(n) {
  if (typeof n === "number")
    n = BigInt(n);
  if (n === 1n)
    return 0;
  return (n - 1n).toString(2).length;
}
function max(a2, b2) {
  return a2 > b2 ? a2 : b2;
}
function abs(x) {
  return x < 0n ? -x : x;
}
function sign(x) {
  return x >= 0 ? 1n : -1n;
}

// dist/node/lib/util/assert.js
function assert(stmt, message) {
  if (!stmt) {
    throw Error(message ?? "Assertion failed");
  }
}

// dist/node/bindings/crypto/random.js
var import_crypto = require("crypto");
function randomBytes(n) {
  return new Uint8Array((0, import_crypto.randomBytes)(n));
}

// dist/node/bindings/crypto/finite_field.js
var p = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
var q = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;
var pMinusOneOddFactor = 0x40000000000000000000000000000000224698fc094cf91b992d30edn;
var qMinusOneOddFactor = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb21n;
var twoadicRootFp = 0x2bce74deac30ebda362120830561f81aea322bf2b7bb7584bdad6fabd87ea32fn;
var twoadicRootFq = 0x2de6a9b8746d3f589e5c4dfd492ae26e9bb97ea3c106f049a70e2c1102b6d05fn;
function mod(x, p3) {
  x = x % p3;
  if (x < 0)
    return x + p3;
  return x;
}
function power(a2, n, p3) {
  a2 = mod(a2, p3);
  let x = 1n;
  for (; n > 0n; n >>= 1n) {
    if (n & 1n)
      x = mod(x * a2, p3);
    a2 = mod(a2 * a2, p3);
  }
  return x;
}
function inverse(a2, p3) {
  a2 = mod(a2, p3);
  if (a2 === 0n)
    return void 0;
  let b2 = p3;
  let x = 0n;
  let y = 1n;
  let u = 1n;
  let v = 0n;
  while (a2 !== 0n) {
    let q3 = b2 / a2;
    let r = mod(b2, a2);
    let m = x - u * q3;
    let n = y - v * q3;
    b2 = a2;
    a2 = r;
    x = u;
    y = v;
    u = m;
    v = n;
  }
  if (b2 !== 1n)
    return void 0;
  return mod(x, p3);
}
function fastInverse(x, p3, n, kmax, twoToMinusKmax) {
  x = mod(x, p3);
  if (x === 0n)
    return void 0;
  const w = 31;
  const hiBits = 31;
  const wn = BigInt(w);
  const wMask = (1n << wn) - 1n;
  let u = p3;
  let v = x;
  let r = 0n;
  let s = 1n;
  let i2 = 0;
  for (; i2 < 2 * n; i2++) {
    let f0 = 1;
    let g0 = 0;
    let f1 = 0;
    let g1 = 1;
    let ulo = Number(u & wMask);
    let vlo = Number(v & wMask);
    let len = Math.max(log2(u), log2(v));
    let shift3 = BigInt(Math.max(len - hiBits, 0));
    let uhi = Number(u >> shift3);
    let vhi = Number(v >> shift3);
    for (let j = 0; j < w; j++) {
      if ((ulo & 1) === 0) {
        uhi >>= 1;
        ulo >>= 1;
        f1 <<= 1;
        g1 <<= 1;
      } else if ((vlo & 1) === 0) {
        vhi >>= 1;
        vlo >>= 1;
        f0 <<= 1;
        g0 <<= 1;
      } else {
        if (vhi <= uhi) {
          uhi = uhi - vhi >> 1;
          ulo = ulo - vlo >> 1;
          f0 = f0 + f1;
          g0 = g0 + g1;
          f1 <<= 1;
          g1 <<= 1;
        } else {
          vhi = vhi - uhi >> 1;
          vlo = vlo - ulo >> 1;
          f1 = f0 + f1;
          g1 = g0 + g1;
          f0 <<= 1;
          g0 <<= 1;
        }
      }
    }
    let f0n = BigInt(f0);
    let g0n = BigInt(g0);
    let f1n = BigInt(f1);
    let g1n = BigInt(g1);
    let unew = u * f0n - v * g0n;
    let vnew = v * g1n - u * f1n;
    u = unew >> wn;
    v = vnew >> wn;
    if (u < 0)
      u = -u, f0n = -f0n, g0n = -g0n;
    if (v < 0)
      v = -v, f1n = -f1n, g1n = -g1n;
    let rnew = r * f0n + s * g0n;
    let snew = s * g1n + r * f1n;
    r = rnew;
    s = snew;
    if (u === 0n)
      break;
    if (v === 0n) {
      assert(u === 1n, "u = 1");
      s = mod(-r, p3);
      break;
    }
  }
  let k = BigInt((i2 + 1) * w);
  s = mod(s * twoToMinusKmax, p3);
  s = mod(s << kmax - k, p3);
  assert(mod(x * s - 1n, p3) === 0n, "mod p");
  return s;
}
function sqrt(n, p3, Q, c, M) {
  if (n === 0n)
    return 0n;
  let t = power(n, Q - 1n >> 1n, p3);
  let R = mod(t * n, p3);
  t = mod(t * R, p3);
  while (true) {
    if (t === 1n)
      return R;
    let i2 = 0n;
    let s = t;
    while (s !== 1n) {
      s = mod(s * s, p3);
      i2 = i2 + 1n;
    }
    if (i2 === M)
      return void 0;
    let b2 = power(c, 1n << M - i2 - 1n, p3);
    M = i2;
    c = mod(b2 * b2, p3);
    t = mod(t * c, p3);
    R = mod(R * b2, p3);
  }
}
function isSquare(x, p3) {
  if (x === 0n)
    return true;
  let sqrt1 = power(x, (p3 - 1n) / 2n, p3);
  return sqrt1 === 1n;
}
function randomField(p3, sizeInBytes, hiBitMask) {
  while (true) {
    let bytes = randomBytes(sizeInBytes);
    bytes[sizeInBytes - 1] &= hiBitMask;
    let x = bytesToBigInt(bytes);
    if (x < p3)
      return x;
  }
}
var Fp = createField(p, {
  oddFactor: pMinusOneOddFactor,
  twoadicRoot: twoadicRootFp,
  twoadicity: 32n
});
var Fq = createField(q, {
  oddFactor: qMinusOneOddFactor,
  twoadicRoot: twoadicRootFq,
  twoadicity: 32n
});
function createField(p3, constants) {
  let { oddFactor, twoadicRoot, twoadicity } = constants ?? computeFieldConstants(p3);
  let sizeInBits2 = log2(p3);
  let sizeInBytes = Math.ceil(sizeInBits2 / 8);
  let sizeHighestByte = sizeInBits2 - 8 * (sizeInBytes - 1);
  let hiBitMask = (1 << sizeHighestByte) - 1;
  const w = 31;
  const n = Math.ceil(sizeInBits2 / w);
  const kmax = BigInt(2 * n * w);
  const twoToMinusKmax = inverse(1n << kmax, p3);
  assert(twoToMinusKmax !== void 0, "2^-kmax exists");
  return {
    modulus: p3,
    sizeInBits: sizeInBits2,
    t: oddFactor,
    M: twoadicity,
    twoadicRoot,
    mod(x) {
      return mod(x, p3);
    },
    add(x, y) {
      return mod(x + y, p3);
    },
    not(x, bits2) {
      return mod(2n ** BigInt(bits2) - (x + 1n), p3);
    },
    negate(x) {
      return x === 0n ? 0n : p3 - x;
    },
    sub(x, y) {
      return mod(x - y, p3);
    },
    mul(x, y) {
      return mod(x * y, p3);
    },
    inverse(x) {
      return fastInverse(x, p3, n, kmax, twoToMinusKmax);
    },
    div(x, y) {
      let yinv = fastInverse(y, p3, n, kmax, twoToMinusKmax);
      if (yinv === void 0)
        return;
      return mod(x * yinv, p3);
    },
    square(x) {
      return mod(x * x, p3);
    },
    isSquare(x) {
      return isSquare(x, p3);
    },
    sqrt(x) {
      return sqrt(x, p3, oddFactor, twoadicRoot, twoadicity);
    },
    power(x, n2) {
      return power(x, n2, p3);
    },
    dot(x, y) {
      let z = 0n;
      let n2 = x.length;
      for (let i2 = 0; i2 < n2; i2++) {
        z += x[i2] * y[i2];
      }
      return mod(z, p3);
    },
    equal(x, y) {
      return mod(x - y, p3) === 0n;
    },
    isEven(x) {
      return !(x & 1n);
    },
    random() {
      return randomField(p3, sizeInBytes, hiBitMask);
    },
    fromNumber(x) {
      return mod(BigInt(x), p3);
    },
    fromBigint(x) {
      return mod(x, p3);
    },
    rot(x, bits2, direction = "left", maxBits = 64n) {
      if (direction === "right")
        bits2 = maxBits - bits2;
      let full = x << bits2;
      let excess = full >> maxBits;
      let shifted = full & (1n << maxBits) - 1n;
      return shifted | excess;
    },
    leftShift(x, bits2, maxBitSize = 64) {
      let shifted = x << BigInt(bits2);
      return shifted & (1n << BigInt(maxBitSize)) - 1n;
    },
    rightShift(x, bits2) {
      return x >> BigInt(bits2);
    }
  };
}
function computeFieldConstants(p3) {
  let oddFactor = p3 - 1n;
  let twoadicity = 0n;
  while ((oddFactor & 1n) === 0n) {
    oddFactor >>= 1n;
    twoadicity++;
  }
  let z = 2n;
  while (isSquare(z, p3))
    z++;
  let twoadicRoot = power(z, oddFactor, p3);
  return { oddFactor, twoadicRoot, twoadicity };
}

// dist/node/lib/errors.js
var lineRemovalKeywords = [
  "o1js_node.bc.cjs",
  "/builtin/",
  "CatchAndPrettifyStacktrace"
  // Decorator name to remove from stacktrace (covers both class and method decorator)
];
function prettifyStacktrace(error) {
  error = unwrapMlException(error);
  if (!(error instanceof Error) || !error.stack)
    return error;
  const stacktrace = error.stack;
  const stacktraceLines = stacktrace.split("\n");
  const newStacktrace = [];
  for (let i2 = 0; i2 < stacktraceLines.length; i2++) {
    const shouldRemoveLine = lineRemovalKeywords.some((lineToRemove) => stacktraceLines[i2].includes(lineToRemove));
    if (shouldRemoveLine) {
      continue;
    }
    const trimmedLine = trimPaths(stacktraceLines[i2]);
    newStacktrace.push(trimmedLine);
  }
  error.stack = newStacktrace.join("\n");
  return error;
}
async function prettifyStacktracePromise(result) {
  try {
    return await result;
  } catch (error) {
    throw prettifyStacktrace(error);
  }
}
function unwrapMlException(error) {
  if (error instanceof Error)
    return error;
  if (Array.isArray(error) && error[2] instanceof Error)
    return error[2];
  return error;
}
function trimPaths(stacktracePath) {
  const includesO1js = stacktracePath.includes("o1js");
  if (includesO1js) {
    return trimO1jsPath(stacktracePath);
  }
  const includesOpam = stacktracePath.includes("opam");
  if (includesOpam) {
    return trimOpamPath(stacktracePath);
  }
  const includesWorkspace = stacktracePath.includes("workspace_root");
  if (includesWorkspace) {
    return trimWorkspacePath(stacktracePath);
  }
  return stacktracePath;
}
function trimO1jsPath(stacktraceLine) {
  const fullPath = getDirectoryPath(stacktraceLine);
  if (!fullPath) {
    return stacktraceLine;
  }
  const o1jsIndex = fullPath.indexOf("o1js");
  if (o1jsIndex === -1) {
    return stacktraceLine;
  }
  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf("(") + 1);
  const updatedPath = fullPath.slice(o1jsIndex);
  return `${prefix}${updatedPath})`;
}
function trimOpamPath(stacktraceLine) {
  const fullPath = getDirectoryPath(stacktraceLine);
  if (!fullPath) {
    return stacktraceLine;
  }
  const opamIndex = fullPath.indexOf("opam");
  if (opamIndex === -1) {
    return stacktraceLine;
  }
  const updatedPathArray = fullPath.slice(opamIndex).split("/");
  const libIndex = updatedPathArray.lastIndexOf("lib");
  if (libIndex === -1) {
    return stacktraceLine;
  }
  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf("(") + 1);
  const trimmedPath = updatedPathArray.slice(libIndex + 1);
  trimmedPath.unshift("ocaml");
  return `${prefix}${trimmedPath.join("/")})`;
}
function trimWorkspacePath(stacktraceLine) {
  const fullPath = getDirectoryPath(stacktraceLine);
  if (!fullPath) {
    return stacktraceLine;
  }
  const workspaceIndex = fullPath.indexOf("workspace_root");
  if (workspaceIndex === -1) {
    return stacktraceLine;
  }
  const updatedPathArray = fullPath.slice(workspaceIndex).split("/");
  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf("(") + 1);
  const trimmedPath = updatedPathArray.slice(workspaceIndex);
  return `${prefix}${trimmedPath.join("/")})`;
}
function getDirectoryPath(stacktraceLine) {
  const fullPathRegex = /\(([^)]+)\)/;
  const matchedPaths = stacktraceLine.match(fullPathRegex);
  if (matchedPaths) {
    return matchedPaths[1];
  }
}
function Bug(message) {
  return Error(`${message}
This shouldn't have happened and indicates an internal bug.`);
}
function assert2(condition, message = "Failed assertion.") {
  if (!condition)
    throw Bug(message);
}

// dist/node/bindings/crypto/elliptic-curve-endomorphism.js
function Endomorphism(name, Field5, Scalar4, generator, endoScalar, endoBase) {
  if (endoScalar === void 0 || endoBase === void 0) {
    try {
      ({ endoScalar, endoBase } = computeEndoConstants(Field5, Scalar4, generator));
    } catch (e) {
      console.log(`Warning: no endomorphism for ${name}`, e?.message);
      return void 0;
    }
  }
  let endoBase_ = endoBase;
  let glvData = computeGlvData(Scalar4.modulus, endoScalar);
  return {
    scalar: endoScalar,
    base: endoBase,
    decomposeMaxBits: glvData.maxBits,
    decompose(s) {
      return decompose(s, glvData);
    },
    endomorphism(P) {
      return endomorphism(P, endoBase_, Field5.modulus);
    },
    scaleProjective(g, s) {
      return glvScaleProjective(g, s, Field5.modulus, endoBase_, glvData);
    },
    scale(g, s) {
      let gProj = projectiveFromAffine(g);
      let sGProj = glvScaleProjective(gProj, s, Field5.modulus, endoBase_, glvData);
      return projectiveToAffine(sGProj, Field5.modulus);
    }
  };
}
function decompose(s, data) {
  let { v00, v01, v10, v11, det } = data;
  let x0 = divideAndRound(-v11 * s, det);
  let x1 = divideAndRound(v10 * s, det);
  let s0 = v00 * x0 + v01 * x1 + s;
  let s1 = v10 * x0 + v11 * x1;
  return [
    { value: s0, isNegative: s0 < 0n, abs: abs(s0) },
    { value: s1, isNegative: s1 < 0n, abs: abs(s1) }
  ];
}
function endomorphism(P, endoBase, p3) {
  return { x: mod(endoBase * P.x, p3), y: P.y };
}
function endomorphismProjective(P, endoBase, p3) {
  return { x: mod(endoBase * P.x, p3), y: P.y, z: P.z };
}
function glvScaleProjective(g, s, p3, endoBase, data) {
  let endoG = endomorphismProjective(g, endoBase, p3);
  let [s0, s1] = decompose(s, data);
  let S0 = bigIntToBits(s0.abs);
  let S1 = bigIntToBits(s1.abs);
  if (s0.isNegative)
    g = projectiveNeg(g, p3);
  if (s1.isNegative)
    endoG = projectiveNeg(endoG, p3);
  let h = projectiveZero;
  for (let i2 = data.maxBits - 1; i2 >= 0; i2--) {
    if (S0[i2])
      h = projectiveAdd(h, g, p3);
    if (S1[i2])
      h = projectiveAdd(h, endoG, p3);
    if (i2 === 0)
      break;
    h = projectiveDouble(h, p3);
  }
  return h;
}
function computeEndoConstants(Field5, Scalar4, G) {
  let p3 = Field5.modulus;
  let q3 = Scalar4.modulus;
  assert2(p3 % 3n === 1n, "Base field has a cube root of unity");
  assert2(q3 % 3n === 1n, "Scalar field has a cube root of unity");
  let sqrtMinus3 = Scalar4.sqrt(Scalar4.negate(3n));
  assert2(sqrtMinus3 !== void 0, "Scalar field has a square root of -3");
  let lambda = Scalar4.div(Scalar4.sub(sqrtMinus3, 1n), 2n);
  assert2(lambda !== void 0, "Scalar field has a cube root of unity");
  assert2(Scalar4.power(lambda, 3n) === 1n, "lambda is a cube root");
  assert2(lambda !== 1n, "lambda is not 1");
  let lambdaG = affineScale(G, lambda, p3);
  assert2(lambdaG.y === G.y, "multiplication by lambda is a cheap endomorphism");
  let beta = Field5.div(lambdaG.x, G.x);
  assert2(beta !== void 0, "Gx is invertible");
  assert2(Field5.power(beta, 3n) === 1n, "beta is a cube root");
  assert2(beta !== 1n, "beta is not 1");
  let R = affineScale(G, Scalar4.random(), p3);
  let lambdaR = affineScale(R, lambda, p3);
  assert2(lambdaR.x === Field5.mul(beta, R.x), "confirm endomorphism");
  assert2(lambdaR.y === R.y, "confirm endomorphism");
  return { endoScalar: lambda, endoBase: beta };
}
function computeGlvData(q3, lambda) {
  let [[v00, v01], [v10, v11]] = egcdStopEarly(lambda, q3);
  let det = v00 * v11 - v10 * v01;
  let maxS0 = (abs(v00) + abs(v01) >> 1n) + 1n;
  let maxS1 = (abs(v10) + abs(v11) >> 1n) + 1n;
  let maxBits = log2(max(maxS0, maxS1));
  return { v00, v01, v10, v11, det, maxS0, maxS1, maxBits };
}
function egcdStopEarly(l4, p3) {
  if (l4 > p3)
    throw Error("a > p");
  let [r0, r1] = [p3, l4];
  let [s0, s1] = [1n, 0n];
  let [t0, t1] = [0n, 1n];
  while (r1 * r1 > p3) {
    let quotient2 = r0 / r1;
    [r0, r1] = [r1, r0 - quotient2 * r1];
    [s0, s1] = [s1, s0 - quotient2 * s1];
    [t0, t1] = [t1, t0 - quotient2 * t1];
  }
  let quotient = r0 / r1;
  let r2 = r0 - quotient * r1;
  let t2 = t0 - quotient * t1;
  let [v00, v10] = [r1, -t1];
  let [v01, v11] = max(r0, abs(t0)) <= max(r2, abs(t2)) ? [r0, -t0] : [r2, -t2];
  return [
    [v00, v01],
    [v10, v11]
  ];
}
function divideAndRound(x, y) {
  let signz = sign(x) * sign(y);
  x = abs(x);
  y = abs(y);
  let z = x / y;
  if (2n * (x - z * y) >= y)
    z++;
  return signz * z;
}

// dist/node/bindings/crypto/elliptic_curve.js
var pallasGeneratorProjective = {
  x: 1n,
  y: 12418654782883325593414442427049395787963493412651469444558597405572177144507n
};
var vestaGeneratorProjective = {
  x: 1n,
  y: 11426906929455361843568202299992114520848200991084027513389447476559454104162n
};
var vestaEndoBase = 2942865608506852014473558576493638302197734138389222805617480874486368177743n;
var pallasEndoBase = 20444556541222657078399132219657928148671392403212669005631716460534733845831n;
var vestaEndoScalar = 8503465768106391777493614032514048814691664078728891710322960303815233784505n;
var pallasEndoScalar = 26005156700822196841419187675678338661165322343552424574062261873906994770353n;
var b = 5n;
var a = 0n;
var projectiveZero = { x: 1n, y: 1n, z: 0n };
var GroupMap = {
  create: (F, params) => {
    const { a: a2, b: b2 } = params.spec;
    if (a2 !== 0n)
      throw Error("GroupMap only supports a = 0");
    function tryDecode(x) {
      const pow3 = F.power(x, 3n);
      const y = F.add(pow3, b2);
      if (!F.isSquare(y))
        return void 0;
      return { x, y: F.sqrt(y) };
    }
    function sToVTruncated(s) {
      const { u, v, y } = s;
      return [v, F.negate(F.add(u, v)), F.add(u, F.square(y))];
    }
    function conic_to_s(c) {
      const d = F.div(c.z, c.y);
      if (d === void 0)
        throw Error(`Division undefined! ${c.z}/${c.y}`);
      const v = F.sub(d, params.u_over_2);
      return { u: params.u, v, y: c.y };
    }
    function field_to_conic(t) {
      const { z: z0, y: y0 } = params.projection_point;
      const ct = F.mul(params.conic_c, t);
      const d1 = F.add(F.mul(ct, y0), z0);
      const d2 = F.add(F.mul(ct, t), 1n);
      const d = F.div(d1, d2);
      if (d === void 0)
        throw Error(`Division undefined! ${d1}/${d2}`);
      const s = F.mul(2n, d);
      return {
        z: F.sub(z0, s),
        y: F.sub(y0, F.mul(s, t))
      };
    }
    return {
      potentialXs: (t) => sToVTruncated(conic_to_s(field_to_conic(t))),
      tryDecode
    };
  }
};
var GroupMapParamsFp = {
  u: 2n,
  u_over_2: 1n,
  conic_c: 3n,
  projection_point: {
    z: 12196889842669319921865617096620076994180062626450149327690483414064673774441n,
    y: 1n
  },
  spec: {
    a: 0n,
    b: 5n
  }
};
var GroupMapPallas = GroupMap.create(Fp, GroupMapParamsFp);
function projectiveNeg({ x, y, z }, p3) {
  return { x, y: y === 0n ? 0n : p3 - y, z };
}
function projectiveAdd(g, h, p3) {
  if (g.z === 0n)
    return h;
  if (h.z === 0n)
    return g;
  let X1 = g.x, Y1 = g.y, Z1 = g.z, X2 = h.x, Y2 = h.y, Z2 = h.z;
  let Z1Z1 = mod(Z1 * Z1, p3);
  let Z2Z2 = mod(Z2 * Z2, p3);
  let U1 = mod(X1 * Z2Z2, p3);
  let U2 = mod(X2 * Z1Z1, p3);
  let S1 = mod(Y1 * Z2 * Z2Z2, p3);
  let S2 = mod(Y2 * Z1 * Z1Z1, p3);
  let H = mod(U2 - U1, p3);
  if (H === 0n) {
    if (S1 === S2)
      return projectiveDouble(g, p3);
    if (mod(S1 + S2, p3) === 0n)
      return projectiveZero;
    throw Error("projectiveAdd: invalid point");
  }
  let I = mod(H * H << 2n, p3);
  let J = mod(H * I, p3);
  let r = 2n * (S2 - S1);
  let V = mod(U1 * I, p3);
  let X3 = mod(r * r - J - 2n * V, p3);
  let Y3 = mod(r * (V - X3) - 2n * S1 * J, p3);
  let Z3 = mod(((Z1 + Z2) * (Z1 + Z2) - Z1Z1 - Z2Z2) * H, p3);
  return { x: X3, y: Y3, z: Z3 };
}
function projectiveDouble(g, p3) {
  if (g.z === 0n)
    return g;
  let X1 = g.x, Y1 = g.y, Z1 = g.z;
  if (Y1 === 0n)
    throw Error("projectiveDouble: unhandled case");
  let A = mod(X1 * X1, p3);
  let B = mod(Y1 * Y1, p3);
  let C = mod(B * B, p3);
  let D = mod(2n * ((X1 + B) * (X1 + B) - A - C), p3);
  let E = 3n * A;
  let F = mod(E * E, p3);
  let X3 = mod(F - 2n * D, p3);
  let Y3 = mod(E * (D - X3) - 8n * C, p3);
  let Z3 = mod(2n * Y1 * Z1, p3);
  return { x: X3, y: Y3, z: Z3 };
}
function projectiveSub(g, h, p3) {
  return projectiveAdd(g, projectiveNeg(h, p3), p3);
}
function projectiveScale(g, x, p3) {
  let bits2 = typeof x === "bigint" ? bigIntToBits(x) : x;
  let h = projectiveZero;
  for (let bit of bits2) {
    if (bit)
      h = projectiveAdd(h, g, p3);
    g = projectiveDouble(g, p3);
  }
  return h;
}
function projectiveFromAffine({ x, y, infinity }) {
  if (infinity)
    return projectiveZero;
  return { x, y, z: 1n };
}
function projectiveToAffine(g, p3) {
  let z = g.z;
  if (z === 0n) {
    return { x: 0n, y: 0n, infinity: true };
  } else if (z === 1n) {
    return { x: g.x, y: g.y, infinity: false };
  } else {
    let zinv = inverse(z, p3);
    let zinv_squared = mod(zinv * zinv, p3);
    let x = mod(g.x * zinv_squared, p3);
    let y = mod(g.y * zinv * zinv_squared, p3);
    return { x, y, infinity: false };
  }
}
function projectiveEqual(g, h, p3) {
  if ((g.z === 0n || h.z === 0n) && g.z !== h.z)
    return false;
  let gz2 = mod(g.z * g.z, p3);
  let hz2 = mod(h.z * h.z, p3);
  if (mod(g.x * hz2 - h.x * gz2, p3) !== 0n)
    return false;
  let gz3 = mod(gz2 * g.z, p3);
  let hz3 = mod(hz2 * h.z, p3);
  return mod(g.y * hz3, p3) === mod(h.y * gz3, p3);
}
function projectiveOnCurve({ x, y, z }, p3, b2) {
  let x3 = mod(mod(x * x, p3) * x, p3);
  let y2 = mod(y * y, p3);
  let z3 = mod(mod(z * z, p3) * z, p3);
  let z6 = mod(z3 * z3, p3);
  return mod(y2 - x3 - b2 * z6, p3) === 0n;
}
function projectiveInSubgroup(g, p3, order) {
  let orderTimesG = projectiveScale(g, order, p3);
  return projectiveEqual(orderTimesG, projectiveZero, p3);
}
function createCurveProjective({ name, modulus: p3, order, cofactor, generator, b: b2, a: a2, endoBase, endoScalar }) {
  if (a2 !== 0n)
    throw Error("createCurveProjective only supports a = 0");
  cofactor ??= 1n;
  let hasCofactor = cofactor !== 1n;
  return {
    name,
    modulus: p3,
    order,
    cofactor,
    zero: projectiveZero,
    one: { ...generator, z: 1n },
    get endoBase() {
      if (endoBase === void 0)
        throw Error("`endoBase` for this curve was not provided.");
      return endoBase;
    },
    get endoScalar() {
      if (endoScalar === void 0)
        throw Error("`endoScalar` for this curve was not provided.");
      return endoScalar;
    },
    a: a2,
    b: b2,
    hasCofactor,
    equal(g, h) {
      return projectiveEqual(g, h, p3);
    },
    isOnCurve(g) {
      return projectiveOnCurve(g, p3, b2);
    },
    isInSubgroup(g) {
      return projectiveInSubgroup(g, p3, order);
    },
    add(g, h) {
      return projectiveAdd(g, h, p3);
    },
    double(g) {
      return projectiveDouble(g, p3);
    },
    negate(g) {
      return projectiveNeg(g, p3);
    },
    sub(g, h) {
      return projectiveSub(g, h, p3);
    },
    scale(g, s) {
      return projectiveScale(g, s, p3);
    },
    endomorphism({ x, y, z }) {
      if (endoBase === void 0)
        throw Error("endomorphism needs `endoBase` parameter.");
      return { x: mod(endoBase * x, p3), y, z };
    },
    toAffine(g) {
      return projectiveToAffine(g, p3);
    },
    fromAffine(a3) {
      return projectiveFromAffine(a3);
    }
  };
}
var Pallas = createCurveProjective({
  name: "Pallas",
  modulus: p,
  order: q,
  generator: pallasGeneratorProjective,
  b,
  a,
  endoBase: pallasEndoBase,
  endoScalar: pallasEndoScalar
});
var Vesta = createCurveProjective({
  name: "Vesta",
  modulus: q,
  order: p,
  generator: vestaGeneratorProjective,
  b,
  a,
  endoBase: vestaEndoBase,
  endoScalar: vestaEndoScalar
});
var affineZero = { x: 0n, y: 0n, infinity: true };
function affineOnCurve({ x, y, infinity }, p3, a2, b2) {
  if (infinity)
    return true;
  let x2 = mod(x * x, p3);
  return mod(y * y - x * x2 - a2 * x - b2, p3) === 0n;
}
function affineAdd(g, h, p3) {
  if (g.infinity)
    return h;
  if (h.infinity)
    return g;
  let { x: x1, y: y1 } = g;
  let { x: x2, y: y2 } = h;
  if (x1 === x2) {
    if (y1 === y2)
      return affineDouble(g, p3);
    return affineZero;
  }
  let d = inverse(x2 - x1, p3);
  if (d === void 0)
    throw Error("impossible");
  let m = mod((y2 - y1) * d, p3);
  let x3 = mod(m * m - x1 - x2, p3);
  let y3 = mod(m * (x1 - x3) - y1, p3);
  return { x: x3, y: y3, infinity: false };
}
function affineDouble({ x, y, infinity }, p3) {
  if (infinity)
    return affineZero;
  let d = inverse(2n * y, p3);
  if (d === void 0)
    throw Error("impossible");
  let m = mod(3n * x * x * d, p3);
  let x2 = mod(m * m - 2n * x, p3);
  let y2 = mod(m * (x - x2) - y, p3);
  return { x: x2, y: y2, infinity: false };
}
function affineNegate({ x, y, infinity }, p3) {
  if (infinity)
    return affineZero;
  return { x, y: y === 0n ? 0n : p3 - y, infinity };
}
function affineScale(g, s, p3) {
  let gProj = projectiveFromAffine(g);
  let sgProj = projectiveScale(gProj, s, p3);
  return projectiveToAffine(sgProj, p3);
}
function createCurveAffine({ name, modulus: p3, order, cofactor, generator, a: a2, b: b2, endoScalar, endoBase }) {
  if (a2 !== 0n)
    throw Error("createCurveAffine only supports a = 0");
  let hasCofactor = cofactor !== void 0 && cofactor !== 1n;
  const Field5 = createField(p3);
  const Scalar4 = createField(order);
  const one = { ...generator, infinity: false };
  const Endo = Endomorphism(name, Field5, Scalar4, one, endoScalar, endoBase);
  return {
    name,
    /**
     * Arithmetic over the base field
     */
    Field: Field5,
    /**
     * Arithmetic over the scalar field
     */
    Scalar: Scalar4,
    modulus: p3,
    order,
    a: a2,
    b: b2,
    cofactor,
    hasCofactor,
    zero: affineZero,
    one,
    hasEndomorphism: Endo !== void 0,
    get Endo() {
      if (Endo === void 0)
        throw Error(`no endomorphism defined on ${name}`);
      return Endo;
    },
    from(g) {
      if (g.x === 0n && g.y === 0n)
        return affineZero;
      return { ...g, infinity: false };
    },
    fromNonzero(g) {
      if (g.x === 0n && g.y === 0n) {
        throw Error("fromNonzero: got (0, 0), which is reserved for the zero point");
      }
      return { ...g, infinity: false };
    },
    equal(g, h) {
      return mod(g.x - h.x, p3) === 0n && mod(g.y - h.y, p3) === 0n;
    },
    isOnCurve(g) {
      return affineOnCurve(g, p3, a2, b2);
    },
    isInSubgroup(g) {
      return projectiveInSubgroup(projectiveFromAffine(g), p3, order);
    },
    add(g, h) {
      return affineAdd(g, h, p3);
    },
    double(g) {
      return affineDouble(g, p3);
    },
    negate(g) {
      return affineNegate(g, p3);
    },
    sub(g, h) {
      return affineAdd(g, affineNegate(h, p3), p3);
    },
    scale(g, s) {
      return affineScale(g, s, p3);
    }
  };
}

// dist/node/bindings/crypto/bindings/curve.js
var VestaBindings = withPrefix("caml_vesta", createCurveBindings(Vesta));
var PallasBindings = withPrefix("caml_pallas", createCurveBindings(Pallas));
function createCurveBindings(Curve) {
  return {
    one() {
      return Curve.one;
    },
    add: Curve.add,
    sub: Curve.sub,
    negate: Curve.negate,
    double: Curve.double,
    scale(g, [, s]) {
      return Curve.scale(g, s);
    },
    random() {
      throw Error("random not implemented");
    },
    rng(i2) {
      throw Error("rng not implemented");
    },
    endo_base() {
      return [0, Curve.endoBase];
    },
    endo_scalar() {
      return [0, Curve.endoScalar];
    },
    to_affine(g) {
      return toMlOrInfinity(Curve.toAffine(g));
    },
    of_affine(g) {
      return Curve.fromAffine(fromMlOrInfinity(g));
    },
    of_affine_coordinates(x, y) {
      return { x: x[1], y: y[1], z: 1n };
    },
    affine_deep_copy(g) {
      return toMlOrInfinity(fromMlOrInfinity(g));
    }
  };
}
var affineZero2 = { x: 0n, y: 0n, infinity: true };
var Infinity = 0;
function toMlOrInfinity(g) {
  if (g.infinity)
    return 0;
  return [0, [0, [0, g.x], [0, g.y]]];
}
function fromMlOrInfinity(g) {
  if (g === 0)
    return affineZero2;
  return { x: g[1][1][1], y: g[1][2][1], infinity: false };
}
var OrInfinity = {
  toJSON(g) {
    if (g === 0)
      return "Infinity";
    return { x: g[1][1][1].toString(), y: g[1][2][1].toString() };
  },
  fromJSON(g) {
    if (g === "Infinity")
      return 0;
    return [0, [0, [0, BigInt(g.x)], [0, BigInt(g.y)]]];
  }
};

// dist/node/bindings/crypto/bindings/field.js
var FpBindings = withPrefix("caml_pasta_fp", createFieldBindings(Fp));
var FqBindings = withPrefix("caml_pasta_fq", createFieldBindings(Fq));
function createFieldBindings(Field5) {
  return {
    size_in_bits() {
      return Field5.sizeInBits;
    },
    size() {
      return [0, Field5.modulus];
    },
    add([, x], [, y]) {
      return [0, Field5.add(x, y)];
    },
    sub([, x], [, y]) {
      return [0, Field5.sub(x, y)];
    },
    negate([, x]) {
      return [0, Field5.negate(x)];
    },
    mul([, x], [, y]) {
      return [0, Field5.mul(x, y)];
    },
    div([, x], [, y]) {
      let z = Field5.div(x, y);
      if (z === void 0)
        throw Error("division by zero");
      return [0, z];
    },
    inv([, x]) {
      return toMlOption(Field5.inverse(x));
    },
    square([, x]) {
      return [0, Field5.square(x)];
    },
    is_square([, x]) {
      return MlBool(Field5.isSquare(x));
    },
    sqrt([, x]) {
      return toMlOption(Field5.sqrt(x));
    },
    of_int(x) {
      if (x < 0)
        throw Error("of_int: inputs must be non-negative");
      return [0, Field5.fromNumber(x)];
    },
    to_string([, x]) {
      return toMlStringAscii(x.toString());
    },
    of_string(s) {
      return [0, Field5.fromBigint(BigInt(fromMlString(s)))];
    },
    print(x) {
      console.log(x[0].toString());
    },
    copy(x, [, y]) {
      x[1] = y;
    },
    mut_add(x, [, y]) {
      x[1] = Field5.add(x[1], y);
    },
    mut_sub(x, [, y]) {
      x[1] = Field5.sub(x[1], y);
    },
    mut_mul(x, [, y]) {
      x[1] = Field5.mul(x[1], y);
    },
    mut_square(x) {
      x[1] = Field5.square(x[1]);
    },
    compare(x, y) {
      return Bigint256Bindings.caml_bigint_256_compare(x, y);
    },
    equal([, x], [, y]) {
      return MlBool(x === y);
    },
    random() {
      return [0, Field5.random()];
    },
    rng(i2) {
      throw Error("rng: not implemented");
    },
    to_bigint([, x]) {
      return [0, x];
    },
    of_bigint([, x]) {
      if (x >= Field5.modulus)
        throw Error("of_bigint: input exceeds field size");
      return [0, x];
    },
    two_adic_root_of_unity() {
      return [0, Field5.twoadicRoot];
    },
    domain_generator(i2) {
      if (i2 > 32 || i2 < 0)
        throw Error("log2 size of evaluation domain must be in [0, 32], got " + i2);
      if (i2 === 0)
        return [0, 1n];
      let generator = Field5.twoadicRoot;
      for (let j = 32; j > i2; j--) {
        generator = mod(generator * generator, Field5.modulus);
      }
      return [0, generator];
    },
    to_bytes(x) {
      return Bigint256Bindings.caml_bigint_256_to_bytes(x);
    },
    of_bytes(bytes) {
      throw Error("of_bytes: not implemented");
    },
    deep_copy([, x]) {
      return [0, x];
    }
  };
}
function toMlOption(x) {
  if (x === void 0)
    return 0;
  return [0, [0, x]];
}

// dist/node/bindings/crypto/bindings/vector.js
var FieldVectorBindings = {
  create() {
    return [0];
  },
  length(v) {
    return v.length - 1;
  },
  emplace_back(v, x) {
    v.push(x);
  },
  get(v, i2) {
    let value = v[i2 + 1];
    if (value === void 0) {
      throw Error(`FieldVector.get(): Index out of bounds, got ${i2}/${v.length - 1}`);
    }
    return [...value];
  },
  set(v, i2, x) {
    v[i2 + 1] = x;
  }
};
var FpVectorBindings = withPrefix("caml_fp_vector", FieldVectorBindings);
var FqVectorBindings = withPrefix("caml_fq_vector", FieldVectorBindings);

// dist/node/bindings/crypto/bindings/conversion-base.js
var fieldSizeBytes = 32;
function fieldToRust([, x], dest = new Uint8Array(32)) {
  return bigintToBytes32(x, dest);
}
function fieldFromRust(x) {
  return [0, bytesToBigint32(x)];
}
function fieldsToRustFlat([, ...fields]) {
  let n = fields.length;
  let flatBytes = new Uint8Array(n * fieldSizeBytes);
  for (let i2 = 0, offset = 0; i2 < n; i2++, offset += fieldSizeBytes) {
    fieldToRust(fields[i2], flatBytes.subarray(offset, offset + fieldSizeBytes));
  }
  return flatBytes;
}
function fieldsFromRustFlat(fieldBytes) {
  let n = fieldBytes.length / fieldSizeBytes;
  if (!Number.isInteger(n)) {
    throw Error("fieldsFromRustFlat: invalid bytes");
  }
  let fields = Array(n);
  for (let i2 = 0, offset = 0; i2 < n; i2++, offset += fieldSizeBytes) {
    let fieldView = new Uint8Array(fieldBytes.buffer, offset, fieldSizeBytes);
    fields[i2] = fieldFromRust(fieldView);
  }
  return [0, ...fields];
}
function maybeFieldToRust(x) {
  return x && fieldToRust(x);
}
function affineFromRust(pt) {
  if (pt.infinity) {
    pt.free();
    return 0;
  } else {
    let x = fieldFromRust(pt.x);
    let y = fieldFromRust(pt.y);
    pt.free();
    return [0, [0, x, y]];
  }
}
var tmpBytes2 = new Uint8Array(32);
function affineToRust(pt, makeAffine) {
  let res = makeAffine();
  if (pt === Infinity) {
    res.infinity = true;
  } else {
    let [, [, x, y]] = pt;
    res.x = fieldToRust(x, tmpBytes2);
    res.y = fieldToRust(y, tmpBytes2);
  }
  return res;
}

// dist/node/bindings/crypto/bindings/conversion-core.js
function conversionCore(wasm2) {
  const fp = conversionCorePerField(wasm2, {
    CommitmentCurve: wasm2.WasmGVesta,
    makeAffine: wasm2.caml_vesta_affine_one,
    Gate: wasm2.WasmFpGate,
    PolyComm: wasm2.WasmFpPolyComm
  });
  const fq = conversionCorePerField(wasm2, {
    CommitmentCurve: wasm2.WasmGPallas,
    makeAffine: wasm2.caml_pallas_affine_one,
    Gate: wasm2.WasmFqGate,
    PolyComm: wasm2.WasmFqPolyComm
  });
  return {
    fp,
    fq,
    wireToRust: fp.wireToRust,
    mapMlArrayToRustVector([, ...array], map) {
      return mapToUint32Array(array, (x) => unwrap(map(x)));
    }
  };
}
function conversionCorePerField(wasm2, { CommitmentCurve, makeAffine, Gate, PolyComm }) {
  let self = {
    wireToRust([, row, col]) {
      return wasm2.Wire.create(row, col);
    },
    vectorToRust: fieldsToRustFlat,
    vectorFromRust: fieldsFromRustFlat,
    gateToRust(gate) {
      let [, typ, [, ...wires], coeffs] = gate;
      let rustWires = new wasm2.WasmGateWires(...mapTuple(wires, self.wireToRust));
      let rustCoeffs = fieldsToRustFlat(coeffs);
      return new Gate(typ, rustWires, rustCoeffs);
    },
    gateFromRust(wasmGate) {
      throw Error("gateFromRust not implemented");
    },
    pointToRust(point) {
      return affineToRust(point, makeAffine);
    },
    pointFromRust: affineFromRust,
    pointsToRust([, ...points]) {
      return mapToUint32Array(points, (point) => unwrap(self.pointToRust(point)));
    },
    pointsFromRust(points) {
      let arr = mapFromUintArray(points, (ptr) => affineFromRust(wrap(ptr, CommitmentCurve)));
      return [0, ...arr];
    },
    polyCommToRust(polyComm) {
      let [, camlUnshifted, camlShifted] = polyComm;
      let rustShifted = MlOption.mapFrom(camlShifted, self.pointToRust);
      let rustUnshifted = self.pointsToRust(camlUnshifted);
      return new PolyComm(rustUnshifted, rustShifted);
    },
    polyCommFromRust(polyComm) {
      let rustShifted = polyComm.shifted;
      let rustUnshifted = polyComm.unshifted;
      let mlShifted = MlOption.mapTo(rustShifted, affineFromRust);
      let mlUnshifted = mapFromUintArray(rustUnshifted, (ptr) => {
        return affineFromRust(wrap(ptr, CommitmentCurve));
      });
      return [0, [0, ...mlUnshifted], mlShifted];
    },
    polyCommsToRust([, ...comms]) {
      return mapToUint32Array(comms, (c) => unwrap(self.polyCommToRust(c)));
    },
    polyCommsFromRust(rustComms) {
      let comms = mapFromUintArray(rustComms, (ptr) => self.polyCommFromRust(wrap(ptr, PolyComm)));
      return [0, ...comms];
    }
  };
  return self;
}
function wrap(ptr, Class) {
  const obj = Object.create(Class.prototype);
  obj.__wbg_ptr = ptr;
  return obj;
}
function unwrap(obj) {
  let ptr = obj.__wbg_ptr;
  if (ptr === void 0)
    throw Error("unwrap: missing ptr");
  return ptr;
}
var registry = new FinalizationRegistry((ptr) => {
  ptr.free();
});
function freeOnFinalize(instance) {
  let instanceRepresentative = wrap(instance.__wbg_ptr, instance.constructor);
  registry.register(instance, instanceRepresentative, instance);
  return instance;
}
function mapFromUintArray(array, map) {
  let n = array.length;
  let result = Array(n);
  for (let i2 = 0; i2 < n; i2++) {
    result[i2] = map(array[i2]);
  }
  return result;
}
function mapToUint32Array(array, map) {
  let n = array.length;
  let result = new Uint32Array(n);
  for (let i2 = 0; i2 < n; i2++) {
    result[i2] = map(array[i2]);
  }
  return result;
}

// dist/node/bindings/crypto/bindings/conversion-proof.js
var fieldToRust_ = (x) => fieldToRust(x);
var proofEvaluationsToRust = mapProofEvaluations(fieldToRust_);
var proofEvaluationsFromRust = mapProofEvaluations(fieldFromRust);
var pointEvalsOptionToRust = mapPointEvalsOption(fieldToRust_);
var pointEvalsOptionFromRust = mapPointEvalsOption(fieldFromRust);
function proofConversion(wasm2, core) {
  return {
    fp: proofConversionPerField(core.fp, {
      ProverCommitments: wasm2.WasmFpProverCommitments,
      OpeningProof: wasm2.WasmFpOpeningProof,
      VecVec: wasm2.WasmVecVecFp,
      ProverProof: wasm2.WasmFpProverProof,
      LookupCommitments: wasm2.WasmFpLookupCommitments,
      RuntimeTable: wasm2.WasmFpRuntimeTable,
      RuntimeTableCfg: wasm2.WasmPastaFpRuntimeTableCfg,
      LookupTable: wasm2.WasmPastaFpLookupTable
    }),
    fq: proofConversionPerField(core.fq, {
      ProverCommitments: wasm2.WasmFqProverCommitments,
      OpeningProof: wasm2.WasmFqOpeningProof,
      VecVec: wasm2.WasmVecVecFq,
      ProverProof: wasm2.WasmFqProverProof,
      LookupCommitments: wasm2.WasmFqLookupCommitments,
      RuntimeTable: wasm2.WasmFqRuntimeTable,
      RuntimeTableCfg: wasm2.WasmPastaFqRuntimeTableCfg,
      LookupTable: wasm2.WasmPastaFqLookupTable
    })
  };
}
function proofConversionPerField(core, { ProverCommitments, OpeningProof, VecVec, ProverProof, LookupCommitments, RuntimeTable, RuntimeTableCfg, LookupTable }) {
  function commitmentsToRust(commitments) {
    let wComm = core.polyCommsToRust(commitments[1]);
    let zComm = core.polyCommToRust(commitments[2]);
    let tComm = core.polyCommToRust(commitments[3]);
    let lookup = MlOption.mapFrom(commitments[4], lookupCommitmentsToRust);
    return new ProverCommitments(wComm, zComm, tComm, lookup);
  }
  function commitmentsFromRust(commitments) {
    let wComm = core.polyCommsFromRust(commitments.w_comm);
    let zComm = core.polyCommFromRust(commitments.z_comm);
    let tComm = core.polyCommFromRust(commitments.t_comm);
    let lookup = MlOption.mapTo(commitments.lookup, lookupCommitmentsFromRust);
    commitments.free();
    return [0, wComm, zComm, tComm, lookup];
  }
  function lookupCommitmentsToRust(lookup) {
    let sorted = core.polyCommsToRust(lookup[1]);
    let aggreg = core.polyCommToRust(lookup[2]);
    let runtime = MlOption.mapFrom(lookup[3], core.polyCommToRust);
    return new LookupCommitments(sorted, aggreg, runtime);
  }
  function lookupCommitmentsFromRust(lookup) {
    let sorted = core.polyCommsFromRust(lookup.sorted);
    let aggreg = core.polyCommFromRust(lookup.aggreg);
    let runtime = MlOption.mapTo(lookup.runtime, core.polyCommFromRust);
    lookup.free();
    return [0, sorted, aggreg, runtime];
  }
  function openingProofToRust(proof) {
    let [_, [, ...lr], delta, z1, z2, sg] = proof;
    let l4 = [0];
    let r = [0];
    for (let [, li, ri] of lr) {
      l4.push(li);
      r.push(ri);
    }
    return new OpeningProof(core.pointsToRust(l4), core.pointsToRust(r), core.pointToRust(delta), fieldToRust(z1), fieldToRust(z2), core.pointToRust(sg));
  }
  function openingProofFromRust(proof) {
    let [, ...l4] = core.pointsFromRust(proof.lr_0);
    let [, ...r] = core.pointsFromRust(proof.lr_1);
    let n = l4.length;
    if (n !== r.length)
      throw Error("openingProofFromRust: l and r length mismatch.");
    let lr = l4.map((li, i2) => [0, li, r[i2]]);
    let delta = core.pointFromRust(proof.delta);
    let z1 = fieldFromRust(proof.z1);
    let z2 = fieldFromRust(proof.z2);
    let sg = core.pointFromRust(proof.sg);
    proof.free();
    return [0, [0, ...lr], delta, z1, z2, sg];
  }
  function runtimeTableToRust([, id, data]) {
    return new RuntimeTable(id, core.vectorToRust(data));
  }
  function runtimeTableCfgToRust([, id, firstColumn]) {
    return new RuntimeTableCfg(id, core.vectorToRust(firstColumn));
  }
  function lookupTableToRust([, id, [, ...data]]) {
    let n = data.length;
    let wasmData = new VecVec(n);
    for (let i2 = 0; i2 < n; i2++) {
      wasmData.push(fieldsToRustFlat(data[i2]));
    }
    return new LookupTable(id, wasmData);
  }
  return {
    proofToRust([, public_evals, proof]) {
      let commitments = commitmentsToRust(proof[1]);
      let openingProof = openingProofToRust(proof[2]);
      let [, ...evals] = proofEvaluationsToRust(proof[3]);
      let publicEvals = pointEvalsOptionToRust(public_evals);
      let evalsActual = [0, publicEvals, ...evals];
      let ftEval1 = fieldToRust(proof[4]);
      let public_2 = fieldsToRustFlat(proof[5]);
      let [, ...prevChallenges] = proof[6];
      let n = prevChallenges.length;
      let prevChallengeScalars = new VecVec(n);
      let prevChallengeCommsMl = [0];
      for (let [, scalars, comms] of prevChallenges) {
        prevChallengeScalars.push(fieldsToRustFlat(scalars));
        prevChallengeCommsMl.push(comms);
      }
      let prevChallengeComms = core.polyCommsToRust(prevChallengeCommsMl);
      return new ProverProof(commitments, openingProof, evalsActual, ftEval1, public_2, prevChallengeScalars, prevChallengeComms);
    },
    proofFromRust(wasmProof) {
      let commitments = commitmentsFromRust(wasmProof.commitments);
      let openingProof = openingProofFromRust(wasmProof.proof);
      let [, wasmPublicEvals, ...wasmEvals] = wasmProof.evals;
      let publicEvals = pointEvalsOptionFromRust(wasmPublicEvals);
      let evals = proofEvaluationsFromRust([0, ...wasmEvals]);
      let ftEval1 = fieldFromRust(wasmProof.ft_eval1);
      let public_2 = fieldsFromRustFlat(wasmProof.public_);
      let prevChallengeScalars = wasmProof.prev_challenges_scalars;
      let [, ...prevChallengeComms] = core.polyCommsFromRust(wasmProof.prev_challenges_comms);
      let prevChallenges = prevChallengeComms.map((comms, i2) => {
        let scalars = fieldsFromRustFlat(prevChallengeScalars.get(i2));
        return [0, scalars, comms];
      });
      wasmProof.free();
      let proof = [
        0,
        commitments,
        openingProof,
        evals,
        ftEval1,
        public_2,
        [0, ...prevChallenges]
      ];
      return [0, publicEvals, proof];
    },
    runtimeTablesToRust([, ...tables]) {
      return mapToUint32Array(tables, (table) => unwrap(runtimeTableToRust(table)));
    },
    runtimeTableCfgsToRust([, ...tableCfgs]) {
      return mapToUint32Array(tableCfgs, (tableCfg) => unwrap(runtimeTableCfgToRust(tableCfg)));
    },
    lookupTablesToRust([, ...tables]) {
      return mapToUint32Array(tables, (table) => unwrap(lookupTableToRust(table)));
    }
  };
}
function createMapPointEvals(map) {
  return (evals) => {
    let [, zeta, zeta_omega] = evals;
    return [0, MlArray.map(zeta, map), MlArray.map(zeta_omega, map)];
  };
}
function mapPointEvalsOption(map) {
  return (evals) => MlOption.map(evals, createMapPointEvals(map));
}
function mapProofEvaluations(map) {
  const mapPointEvals = createMapPointEvals(map);
  const mapPointEvalsOption2 = (evals) => MlOption.map(evals, mapPointEvals);
  return function mapProofEvaluations2(evals) {
    let [, w, z, s, coeffs, genericSelector, poseidonSelector, completeAddSelector, mulSelector, emulSelector, endomulScalarSelector, rangeCheck0Selector, rangeCheck1Selector, foreignFieldAddSelector, foreignFieldMulSelector, xorSelector, rotSelector, lookupAggregation, lookupTable, lookupSorted, runtimeLookupTable, runtimeLookupTableSelector, xorLookupSelector, lookupGateLookupSelector, rangeCheckLookupSelector, foreignFieldMulLookupSelector] = evals;
    return [
      0,
      MlTuple2.map(w, mapPointEvals),
      mapPointEvals(z),
      MlTuple2.map(s, mapPointEvals),
      MlTuple2.map(coeffs, mapPointEvals),
      mapPointEvals(genericSelector),
      mapPointEvals(poseidonSelector),
      mapPointEvals(completeAddSelector),
      mapPointEvals(mulSelector),
      mapPointEvals(emulSelector),
      mapPointEvals(endomulScalarSelector),
      mapPointEvalsOption2(rangeCheck0Selector),
      mapPointEvalsOption2(rangeCheck1Selector),
      mapPointEvalsOption2(foreignFieldAddSelector),
      mapPointEvalsOption2(foreignFieldMulSelector),
      mapPointEvalsOption2(xorSelector),
      mapPointEvalsOption2(rotSelector),
      mapPointEvalsOption2(lookupAggregation),
      mapPointEvalsOption2(lookupTable),
      MlArray.map(lookupSorted, mapPointEvalsOption2),
      mapPointEvalsOption2(runtimeLookupTable),
      mapPointEvalsOption2(runtimeLookupTableSelector),
      mapPointEvalsOption2(xorLookupSelector),
      mapPointEvalsOption2(lookupGateLookupSelector),
      mapPointEvalsOption2(rangeCheckLookupSelector),
      mapPointEvalsOption2(foreignFieldMulLookupSelector)
    ];
  };
}

// dist/node/bindings/crypto/bindings/conversion-verifier-index.js
function verifierIndexConversion(wasm2, core) {
  return {
    fp: verifierIndexConversionPerField(wasm2, core.fp, {
      Domain: wasm2.WasmFpDomain,
      VerificationEvals: wasm2.WasmFpPlonkVerificationEvals,
      Shifts: wasm2.WasmFpShifts,
      VerifierIndex: wasm2.WasmFpPlonkVerifierIndex,
      LookupVerifierIndex: wasm2.WasmFpLookupVerifierIndex,
      LookupSelector: wasm2.WasmFpLookupSelectors
    }),
    fq: verifierIndexConversionPerField(wasm2, core.fq, {
      Domain: wasm2.WasmFqDomain,
      VerificationEvals: wasm2.WasmFqPlonkVerificationEvals,
      Shifts: wasm2.WasmFqShifts,
      VerifierIndex: wasm2.WasmFqPlonkVerifierIndex,
      LookupVerifierIndex: wasm2.WasmFqLookupVerifierIndex,
      LookupSelector: wasm2.WasmFqLookupSelectors
    })
  };
}
function verifierIndexConversionPerField(wasm2, core, { Domain, VerificationEvals, Shifts, VerifierIndex, LookupVerifierIndex, LookupSelector }) {
  function domainToRust([, logSizeOfGroup, groupGen]) {
    return new Domain(logSizeOfGroup, fieldToRust(groupGen));
  }
  function domainFromRust(domain) {
    let logSizeOfGroup = domain.log_size_of_group;
    let groupGen = fieldFromRust(domain.group_gen);
    domain.free();
    return [0, logSizeOfGroup, groupGen];
  }
  function verificationEvalsToRust(evals) {
    let sigmaComm = core.polyCommsToRust(evals[1]);
    let coefficientsComm = core.polyCommsToRust(evals[2]);
    let genericComm = core.polyCommToRust(evals[3]);
    let psmComm = core.polyCommToRust(evals[4]);
    let completeAddComm = core.polyCommToRust(evals[5]);
    let mulComm = core.polyCommToRust(evals[6]);
    let emulComm = core.polyCommToRust(evals[7]);
    let endomulScalarComm = core.polyCommToRust(evals[8]);
    let xorComm = MlOption.mapFrom(evals[9], core.polyCommToRust);
    let rangeCheck0Comm = MlOption.mapFrom(evals[10], core.polyCommToRust);
    let rangeCheck1Comm = MlOption.mapFrom(evals[11], core.polyCommToRust);
    let foreignFieldAddComm = MlOption.mapFrom(evals[12], core.polyCommToRust);
    let foreignFieldMulComm = MlOption.mapFrom(evals[13], core.polyCommToRust);
    let rotComm = MlOption.mapFrom(evals[14], core.polyCommToRust);
    return new VerificationEvals(sigmaComm, coefficientsComm, genericComm, psmComm, completeAddComm, mulComm, emulComm, endomulScalarComm, xorComm, rangeCheck0Comm, rangeCheck1Comm, foreignFieldAddComm, foreignFieldMulComm, rotComm);
  }
  function verificationEvalsFromRust(evals) {
    let mlEvals = [
      0,
      core.polyCommsFromRust(evals.sigma_comm),
      core.polyCommsFromRust(evals.coefficients_comm),
      core.polyCommFromRust(evals.generic_comm),
      core.polyCommFromRust(evals.psm_comm),
      core.polyCommFromRust(evals.complete_add_comm),
      core.polyCommFromRust(evals.mul_comm),
      core.polyCommFromRust(evals.emul_comm),
      core.polyCommFromRust(evals.endomul_scalar_comm),
      MlOption.mapTo(evals.xor_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.range_check0_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.range_check1_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.foreign_field_add_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.foreign_field_mul_comm, core.polyCommFromRust),
      MlOption.mapTo(evals.rot_comm, core.polyCommFromRust)
    ];
    evals.free();
    return mlEvals;
  }
  function lookupVerifierIndexToRust(lookup) {
    let [, joint_lookup_used, lookup_table, selectors, table_ids, lookup_info, runtime_tables_selector] = lookup;
    return new LookupVerifierIndex(MlBool.from(joint_lookup_used), core.polyCommsToRust(lookup_table), lookupSelectorsToRust(selectors), MlOption.mapFrom(table_ids, core.polyCommToRust), lookupInfoToRust(lookup_info), MlOption.mapFrom(runtime_tables_selector, core.polyCommToRust));
  }
  function lookupVerifierIndexFromRust(lookup) {
    let mlLookup = [
      0,
      MlBool(lookup.joint_lookup_used),
      core.polyCommsFromRust(lookup.lookup_table),
      lookupSelectorsFromRust(lookup.lookup_selectors),
      MlOption.mapTo(lookup.table_ids, core.polyCommFromRust),
      lookupInfoFromRust(lookup.lookup_info),
      MlOption.mapTo(lookup.runtime_tables_selector, core.polyCommFromRust)
    ];
    lookup.free();
    return mlLookup;
  }
  function lookupSelectorsToRust([, lookup, xor4, range_check, ffmul]) {
    return new LookupSelector(MlOption.mapFrom(xor4, core.polyCommToRust), MlOption.mapFrom(lookup, core.polyCommToRust), MlOption.mapFrom(range_check, core.polyCommToRust), MlOption.mapFrom(ffmul, core.polyCommToRust));
  }
  function lookupSelectorsFromRust(selector) {
    let lookup = MlOption.mapTo(selector.lookup, core.polyCommFromRust);
    let xor4 = MlOption.mapTo(selector.xor, core.polyCommFromRust);
    let range_check = MlOption.mapTo(selector.range_check, core.polyCommFromRust);
    let ffmul = MlOption.mapTo(selector.ffmul, core.polyCommFromRust);
    selector.free();
    return [0, lookup, xor4, range_check, ffmul];
  }
  function lookupInfoToRust([, maxPerRow, maxJointSize, features]) {
    let [, patterns, joint_lookup_used, uses_runtime_tables] = features;
    let [, xor4, lookup, range_check, foreign_field_mul] = patterns;
    let wasmPatterns = new wasm2.LookupPatterns(MlBool.from(xor4), MlBool.from(lookup), MlBool.from(range_check), MlBool.from(foreign_field_mul));
    let wasmFeatures = new wasm2.LookupFeatures(wasmPatterns, MlBool.from(joint_lookup_used), MlBool.from(uses_runtime_tables));
    return new wasm2.LookupInfo(maxPerRow, maxJointSize, wasmFeatures);
  }
  function lookupInfoFromRust(info) {
    let features = info.features;
    let patterns = features.patterns;
    let mlInfo = [
      0,
      info.max_per_row,
      info.max_joint_size,
      [
        0,
        [
          0,
          MlBool(patterns.xor),
          MlBool(patterns.lookup),
          MlBool(patterns.range_check),
          MlBool(patterns.foreign_field_mul)
        ],
        MlBool(features.joint_lookup_used),
        MlBool(features.uses_runtime_tables)
      ]
    ];
    info.free();
    return mlInfo;
  }
  let self = {
    shiftsToRust([, ...shifts]) {
      let s = shifts.map((s2) => fieldToRust(s2));
      return new Shifts(s[0], s[1], s[2], s[3], s[4], s[5], s[6]);
    },
    shiftsFromRust(s) {
      let shifts = [s.s0, s.s1, s.s2, s.s3, s.s4, s.s5, s.s6];
      s.free();
      return [0, ...shifts.map(fieldFromRust)];
    },
    verifierIndexToRust(vk) {
      let domain = domainToRust(vk[1]);
      let maxPolySize = vk[2];
      let nPublic = vk[3];
      let prevChallenges = vk[4];
      let srs2 = vk[5];
      let evals = verificationEvalsToRust(vk[6]);
      let shifts = self.shiftsToRust(vk[7]);
      let lookupIndex = MlOption.mapFrom(vk[8], lookupVerifierIndexToRust);
      return new VerifierIndex(domain, maxPolySize, nPublic, prevChallenges, srs2, evals, shifts, lookupIndex);
    },
    verifierIndexFromRust(vk) {
      let mlVk = [
        0,
        domainFromRust(vk.domain),
        vk.max_poly_size,
        vk.public_,
        vk.prev_challenges,
        freeOnFinalize(vk.srs),
        verificationEvalsFromRust(vk.evals),
        self.shiftsFromRust(vk.shifts),
        MlOption.mapTo(vk.lookup_index, lookupVerifierIndexFromRust)
      ];
      vk.free();
      return mlVk;
    }
  };
  return self;
}

// dist/node/bindings/crypto/bindings/conversion-oracles.js
function oraclesConversion(wasm2) {
  return {
    fp: oraclesConversionPerField({
      RandomOracles: wasm2.WasmFpRandomOracles,
      Oracles: wasm2.WasmFpOracles
    }),
    fq: oraclesConversionPerField({
      RandomOracles: wasm2.WasmFqRandomOracles,
      Oracles: wasm2.WasmFqOracles
    })
  };
}
function oraclesConversionPerField({ RandomOracles, Oracles }) {
  function randomOraclesToRust(ro) {
    let jointCombinerMl = MlOption.from(ro[1]);
    let jointCombinerChal = maybeFieldToRust(jointCombinerMl?.[1][1]);
    let jointCombiner = maybeFieldToRust(jointCombinerMl?.[2]);
    let beta = fieldToRust(ro[2]);
    let gamma = fieldToRust(ro[3]);
    let alphaChal = fieldToRust(ro[4][1]);
    let alpha = fieldToRust(ro[5]);
    let zeta = fieldToRust(ro[6]);
    let v = fieldToRust(ro[7]);
    let u = fieldToRust(ro[8]);
    let zetaChal = fieldToRust(ro[9][1]);
    let vChal = fieldToRust(ro[10][1]);
    let uChal = fieldToRust(ro[11][1]);
    return new RandomOracles(jointCombinerChal, jointCombiner, beta, gamma, alphaChal, alpha, zeta, v, u, zetaChal, vChal, uChal);
  }
  function randomOraclesFromRust(ro) {
    let jointCombinerChal = ro.joint_combiner_chal;
    let jointCombiner = ro.joint_combiner;
    let jointCombinerOption = MlOption(jointCombinerChal && jointCombiner && [
      0,
      [0, fieldFromRust(jointCombinerChal)],
      fieldFromRust(jointCombiner)
    ]);
    let mlRo = [
      0,
      jointCombinerOption,
      fieldFromRust(ro.beta),
      fieldFromRust(ro.gamma),
      [0, fieldFromRust(ro.alpha_chal)],
      fieldFromRust(ro.alpha),
      fieldFromRust(ro.zeta),
      fieldFromRust(ro.v),
      fieldFromRust(ro.u),
      [0, fieldFromRust(ro.zeta_chal)],
      [0, fieldFromRust(ro.v_chal)],
      [0, fieldFromRust(ro.u_chal)]
    ];
    return mlRo;
  }
  return {
    oraclesToRust(oracles) {
      let [, o, pEval, openingPrechallenges, digestBeforeEvaluations] = oracles;
      return new Oracles(randomOraclesToRust(o), fieldToRust(pEval[1]), fieldToRust(pEval[2]), fieldsToRustFlat(openingPrechallenges), fieldToRust(digestBeforeEvaluations));
    },
    oraclesFromRust(oracles) {
      let mlOracles = [
        0,
        randomOraclesFromRust(oracles.o),
        [0, fieldFromRust(oracles.p_eval0), fieldFromRust(oracles.p_eval1)],
        fieldsFromRustFlat(oracles.opening_prechallenges),
        fieldFromRust(oracles.digest_before_evaluations)
      ];
      return mlOracles;
    }
  };
}

// dist/node/bindings/crypto/bindings/env.js
var jsEnvironment = "node";

// dist/node/lib/util/fs.js
var import_cachedir = __toESM(require("cachedir"), 1);
var import_node_fs = require("node:fs");
var import_node_path = require("node:path");

// dist/node/lib/proof-system/cache.js
var cacheHeaderVersion = 1;
function withVersion(header, version = cacheHeaderVersion) {
  let uniqueId = `${header.uniqueId}-${version}`;
  return { ...header, version, uniqueId };
}
function readCache(cache2, header, transform) {
  try {
    let result = cache2.read(header);
    if (result === void 0) {
      if (cache2.debug)
        console.trace("cache miss");
      return void 0;
    }
    if (transform === void 0)
      return result;
    return transform(result);
  } catch (e) {
    if (cache2.debug)
      console.log("Failed to read cache", e);
    return void 0;
  }
}
function writeCache(cache2, header, value) {
  if (!cache2.canWrite)
    return false;
  try {
    cache2.write(header, value);
    return true;
  } catch (e) {
    if (cache2.debug)
      console.log("Failed to write cache", e);
    return false;
  }
}
var None = {
  read() {
    throw Error("not available");
  },
  write() {
    throw Error("not available");
  },
  canWrite: false
};
var FileSystem = (cacheDirectory, debug) => ({
  read({ persistentId, uniqueId, dataType }) {
    if (jsEnvironment !== "node")
      throw Error("file system not available");
    let currentId = (0, import_node_fs.readFileSync)((0, import_node_path.resolve)(cacheDirectory, `${persistentId}.header`), "utf8");
    if (currentId !== uniqueId)
      return void 0;
    if (dataType === "string") {
      let string = (0, import_node_fs.readFileSync)((0, import_node_path.resolve)(cacheDirectory, persistentId), "utf8");
      return new TextEncoder().encode(string);
    } else {
      let buffer = (0, import_node_fs.readFileSync)((0, import_node_path.resolve)(cacheDirectory, persistentId));
      return new Uint8Array(buffer.buffer);
    }
  },
  write({ persistentId, uniqueId, dataType }, data) {
    if (jsEnvironment !== "node")
      throw Error("file system not available");
    (0, import_node_fs.mkdirSync)(cacheDirectory, { recursive: true });
    (0, import_node_fs.writeFileSync)((0, import_node_path.resolve)(cacheDirectory, `${persistentId}.header`), uniqueId, {
      encoding: "utf8"
    });
    (0, import_node_fs.writeFileSync)((0, import_node_path.resolve)(cacheDirectory, persistentId), data, {
      encoding: dataType === "string" ? "utf8" : void 0
    });
  },
  canWrite: jsEnvironment === "node",
  debug
});
var FileSystemDefault = FileSystem((0, import_cachedir.default)("o1js"));
var Cache = {
  /**
   * Store data on the file system, in a directory of your choice.
   *
   * Data will be stored in two files per cache entry: a data file and a `.header` file.
   * The header file just contains a unique string which is used to determine whether we can use the cached data.
   *
   * Note: this {@link Cache} only caches data in Node.js.
   */
  FileSystem,
  /**
   * Store data on the file system, in a standard cache directory depending on the OS.
   *
   * Data will be stored in two files per cache entry: a data file and a `.header` file.
   * The header file just contains a unique string which is used to determine whether we can use the cached data.
   *
   * Note: this {@link Cache} only caches data in Node.js.
   */
  FileSystemDefault,
  /**
   * Don't store anything.
   */
  None
};

// dist/node/bindings/crypto/bindings/srs.js
function empty() {
  return {};
}
var srsStore = { fp: empty(), fq: empty() };
var cache;
function setSrsCache(c) {
  cache = c;
}
function unsetSrsCache() {
  cache = void 0;
}
var srsVersion = 1;
function cacheHeaderLagrange(f, domainSize) {
  let id = `lagrange-basis-${f}-${domainSize}`;
  return withVersion({
    kind: "lagrange-basis",
    persistentId: id,
    uniqueId: id,
    dataType: "string"
  }, srsVersion);
}
function cacheHeaderSrs(f, domainSize) {
  let id = `srs-${f}-${domainSize}`;
  return withVersion({
    kind: "srs",
    persistentId: id,
    uniqueId: id,
    dataType: "string"
  }, srsVersion);
}
function srs(wasm2, conversion) {
  return {
    fp: srsPerField("fp", wasm2, conversion),
    fq: srsPerField("fq", wasm2, conversion)
  };
}
function srsPerField(f, wasm2, conversion) {
  let createSrs = (s) => wasm2[`caml_${f}_srs_create_parallel`](s);
  let getSrs = wasm2[`caml_${f}_srs_get`];
  let setSrs = wasm2[`caml_${f}_srs_set`];
  let maybeLagrangeCommitment = wasm2[`caml_${f}_srs_maybe_lagrange_commitment`];
  let lagrangeCommitment = wasm2[`caml_${f}_srs_lagrange_commitment`];
  let setLagrangeBasis = wasm2[`caml_${f}_srs_set_lagrange_basis`];
  let getLagrangeBasis = (srs2, n) => wasm2[`caml_${f}_srs_get_lagrange_basis`](srs2, n);
  return {
    /**
     * returns existing stored SRS or falls back to creating a new one
     */
    create(size) {
      let srs2 = srsStore[f][size];
      if (srs2 === void 0) {
        if (cache === void 0) {
          srs2 = createSrs(size);
        } else {
          let header = cacheHeaderSrs(f, size);
          srs2 = readCache(cache, header, (bytes) => {
            let jsonSrs = JSON.parse(new TextDecoder().decode(bytes));
            let mlSrs = MlArray.mapTo(jsonSrs, OrInfinity.fromJSON);
            let wasmSrs = conversion[f].pointsToRust(mlSrs);
            return setSrs(wasmSrs);
          });
          if (srs2 === void 0) {
            srs2 = createSrs(size);
            if (cache.canWrite) {
              let wasmSrs = getSrs(srs2);
              let mlSrs = conversion[f].pointsFromRust(wasmSrs);
              let jsonSrs = MlArray.mapFrom(mlSrs, OrInfinity.toJSON);
              let bytes = new TextEncoder().encode(JSON.stringify(jsonSrs));
              writeCache(cache, header, bytes);
            }
          }
        }
        srsStore[f][size] = srs2;
      }
      return srsStore[f][size];
    },
    /**
     * returns ith Lagrange basis commitment for a given domain size
     */
    lagrangeCommitment(srs2, domainSize, i2) {
      let commitment = maybeLagrangeCommitment(srs2, domainSize, i2);
      if (commitment === void 0) {
        if (cache === void 0) {
          commitment = lagrangeCommitment(srs2, domainSize, i2);
        } else {
          let header = cacheHeaderLagrange(f, domainSize);
          let didRead = readCache(cache, header, (bytes) => {
            let comms = JSON.parse(new TextDecoder().decode(bytes));
            let mlComms = polyCommsFromJSON(comms);
            let wasmComms = conversion[f].polyCommsToRust(mlComms);
            setLagrangeBasis(srs2, domainSize, wasmComms);
            return true;
          });
          if (didRead !== true) {
            let wasmComms = getLagrangeBasis(srs2, domainSize);
            if (cache.canWrite) {
              let mlComms = conversion[f].polyCommsFromRust(wasmComms);
              let comms = polyCommsToJSON(mlComms);
              let bytes = new TextEncoder().encode(JSON.stringify(comms));
              writeCache(cache, header, bytes);
            }
          }
          let c = maybeLagrangeCommitment(srs2, domainSize, i2);
          assert2(c !== void 0, "commitment exists after setting");
          commitment = c;
        }
      }
      return conversion[f].polyCommFromRust(commitment);
    },
    /**
     * adds Lagrange basis for a given domain size
     */
    addLagrangeBasis(srs2, logSize) {
      this.lagrangeCommitment(srs2, 1 << logSize, 0);
    }
  };
}
function polyCommsToJSON(comms) {
  return MlArray.mapFrom(comms, ([, shifted, unshifted]) => {
    return {
      shifted: MlArray.mapFrom(shifted, OrInfinity.toJSON),
      unshifted: MlOption.mapFrom(unshifted, OrInfinity.toJSON)
    };
  });
}
function polyCommsFromJSON(json) {
  return MlArray.mapTo(json, ({ shifted, unshifted }) => {
    return [
      0,
      MlArray.mapTo(shifted, OrInfinity.fromJSON),
      MlOption.mapTo(unshifted, OrInfinity.fromJSON)
    ];
  });
}

// dist/node/bindings/crypto/bindings.js
var tsBindings = {
  jsEnvironment,
  prefixHashes,
  prefixHashesLegacy,
  ...Bigint256Bindings,
  ...FpBindings,
  ...FqBindings,
  ...VestaBindings,
  ...PallasBindings,
  ...FpVectorBindings,
  ...FqVectorBindings,
  rustConversion: createRustConversion,
  srs: (wasm2) => srs(wasm2, getRustConversion(wasm2))
};
globalThis.__snarkyTsBindings = tsBindings;
function createRustConversion(wasm2) {
  let core = conversionCore(wasm2);
  let verifierIndex = verifierIndexConversion(wasm2, core);
  let oracles = oraclesConversion(wasm2);
  let proof = proofConversion(wasm2, core);
  return {
    fp: { ...core.fp, ...verifierIndex.fp, ...oracles.fp, ...proof.fp },
    fq: { ...core.fq, ...verifierIndex.fq, ...oracles.fq, ...proof.fq },
    fieldsToRustFlat,
    fieldsFromRustFlat,
    wireToRust: core.wireToRust,
    mapMlArrayToRustVector: core.mapMlArrayToRustVector
  };
}
var rustConversion;
function getRustConversion(wasm2) {
  return rustConversion ?? (rustConversion = createRustConversion(wasm2));
}

// dist/node/bindings/js/node/node-backend.js
var import_worker_threads = require("worker_threads");
var import_os = __toESM(require("os"), 1);
var import_plonk_wasm = __toESM(require("./bindings/compiled/_node_bindings/plonk_wasm.cjs"), 1);
var import_url = require("url");
var import_meta = {};
var url = import_meta.url;
var filename = url !== void 0 ? (0, import_url.fileURLToPath)(url) : __filename;
var wasm = import_plonk_wasm.default;
var workersReadyResolve;
var workersReady;
globalThis.startWorkers = startWorkers;
globalThis.terminateWorkers = terminateWorkers;
if (!import_worker_threads.isMainThread) {
  import_worker_threads.parentPort.postMessage({ type: "wasm_bindgen_worker_ready" });
  wasm.wbg_rayon_start_worker(import_worker_threads.workerData.receiver);
}
var state = "none";
var isNeededBy = 0;
var initializingPromise;
var exitingPromise;
async function withThreadPool(run) {
  isNeededBy++;
  switch (state) {
    case "none":
      initializingPromise = initThreadPool();
      state = "initializing";
      break;
    case "initializing":
    case "running":
      break;
    case "exiting":
      initializingPromise = exitingPromise.then(initThreadPool);
      state = "initializing";
      break;
  }
  await initializingPromise;
  initializingPromise = void 0;
  state = "running";
  let result;
  try {
    result = await run();
  } finally {
    isNeededBy--;
    switch (state) {
      case "none":
      case "initializing":
      case "exiting":
        console.error("bug in thread pool state machine");
        break;
      case "running":
        if (isNeededBy < 1) {
          exitingPromise = exitThreadPool();
          state = "exiting";
          await exitingPromise;
          if (state === "exiting") {
            exitingPromise = void 0;
            state = "none";
          }
        }
        break;
    }
  }
  return result;
}
async function initThreadPool() {
  if (!import_worker_threads.isMainThread)
    return;
  workersReady = new Promise((resolve2) => workersReadyResolve = resolve2);
  await wasm.initThreadPool(getEfficientNumWorkers(), filename);
  await workersReady;
  workersReady = void 0;
}
async function exitThreadPool() {
  if (!import_worker_threads.isMainThread)
    return;
  await wasm.exitThreadPool();
}
var wasmWorkers = [];
async function startWorkers(src, memory, builder) {
  wasmWorkers = [];
  await Promise.all(Array.from({ length: builder.numThreads() }, () => {
    let worker = new import_worker_threads.Worker(src, {
      workerData: { memory, receiver: builder.receiver() }
    });
    wasmWorkers.push(worker);
    let target = worker;
    let type = "wasm_bindgen_worker_ready";
    return new Promise((resolve2) => {
      let done = false;
      target.on("message", function onMsg(data) {
        if (data == null || data.type !== type || done)
          return;
        done = true;
        resolve2(worker);
      });
    });
  }));
  builder.build();
  workersReadyResolve();
}
async function terminateWorkers() {
  return Promise.all(wasmWorkers.map((w) => w.terminate())).then(() => wasmWorkers = void 0);
}
function getEfficientNumWorkers() {
  let cpus = import_os.default.cpus();
  let numCpus = cpus.length;
  let cpuModel = cpus[0].model;
  let numWorkers = {
    "Apple M1": 2,
    "Apple M1 Pro": numCpus === 10 ? 3 : 2,
    "Apple M1 Max": 3,
    "Apple M1 Ultra": 7,
    "Apple M2": 2,
    "Apple M2 Pro": 2
  }[cpuModel] || numCpus - 1;
  return numWorkers;
}

// dist/node/bindings/js/wrapper.js
var snarky;
CJS:
  if (typeof require !== "undefined") {
    snarky = require("./bindings/compiled/_node_bindings/o1js_node.bc.cjs");
  }
var getSnarky = () => snarky;
function getWasm() {
  return wasm;
}

// dist/node/bindings/js/snarky-class-spec.js
var snarky_class_spec_default = [
  {
    name: "Snarky",
    props: [
      { name: "exists", type: "function" },
      { name: "existsVar", type: "function" },
      {
        name: "run",
        type: "object"
      },
      {
        name: "field",
        type: "object"
      },
      {
        name: "gates",
        type: "object"
      },
      {
        name: "bool",
        type: "object"
      },
      {
        name: "group",
        type: "object"
      },
      {
        name: "circuit",
        type: "object"
      },
      {
        name: "poseidon",
        type: "object"
      }
    ]
  },
  {
    name: "Ledger",
    props: [
      {
        name: "create",
        type: "function"
      }
    ]
  },
  {
    name: "Pickles",
    props: [
      {
        name: "compile",
        type: "function"
      },
      {
        name: "verify",
        type: "function"
      },
      {
        name: "loadSrsFp",
        type: "function"
      },
      {
        name: "loadSrsFq",
        type: "function"
      },
      {
        name: "dummyProof",
        type: "function"
      },
      {
        name: "dummyVerificationKey",
        type: "function"
      },
      {
        name: "encodeVerificationKey",
        type: "function"
      },
      {
        name: "decodeVerificationKey",
        type: "function"
      },
      {
        name: "proofToBase64",
        type: "function"
      },
      {
        name: "proofOfBase64",
        type: "function"
      },
      {
        name: "proofToBase64Transaction",
        type: "function"
      },
      {
        name: "util",
        type: "object"
      }
    ]
  },
  {
    name: "Test",
    props: [
      {
        name: "encoding",
        type: "object"
      },
      {
        name: "tokenId",
        type: "object"
      },
      {
        name: "poseidon",
        type: "object"
      },
      {
        name: "signature",
        type: "object"
      },
      {
        name: "fieldsFromJson",
        type: "object"
      },
      {
        name: "hashFromJson",
        type: "object"
      },
      {
        name: "hashInputFromJson",
        type: "object"
      },
      {
        name: "transactionHash",
        type: "object"
      }
    ]
  }
];

// dist/node/bindings/js/proxy.js
function proxyClasses(getModuleObject, isItReady2, moduleSpec) {
  let moduleProxy = {};
  for (let classSpec of moduleSpec) {
    let className = classSpec.name;
    let Class = function(...args) {
      if (!isItReady2())
        throw Error(constructError(className));
      let moduleObject = getModuleObject();
      return new moduleObject[className](...args);
    };
    for (let prop2 of classSpec.props) {
      let propName = prop2.name;
      if (prop2.type === "function") {
        Class[propName] = function(...args) {
          if (!isItReady2())
            throw Error(methodError(className, propName));
          let moduleObject = getModuleObject();
          return moduleObject[className][propName].apply(this, args);
        };
      } else {
        Object.defineProperty(Class, propName, {
          get: function() {
            let moduleObject = getModuleObject();
            return moduleObject[className][propName];
          }
        });
      }
    }
    moduleProxy[className] = Class;
  }
  return moduleProxy;
}
var constructError = (className) => `Cannot call class constructor because o1js has not finished loading.
Try calling \`await isReady\` before \`new ${className}()\``;
var methodError = (className, methodName) => `Cannot call static method because o1js has not finished loading.
Try calling \`await isReady\` before \`${className}.${methodName}()\``;

// dist/node/snarky.js
var isReadyBoolean = true;
var isItReady = () => isReadyBoolean;
var { Snarky, Ledger, Pickles, Test } = proxyClasses(getSnarky, isItReady, snarky_class_spec_default);

// dist/node/bindings/lib/provable-generic.js
function createDerivers() {
  let complexTypes = /* @__PURE__ */ new Set(["object", "function"]);
  let primitives2 = /* @__PURE__ */ new Set([Number, String, Boolean, BigInt, null, void 0]);
  const HashInput3 = createHashInput();
  function provable3(typeObj, options) {
    let objectKeys = typeof typeObj === "object" && typeObj !== null ? Object.keys(typeObj) : [];
    if (!primitives2.has(typeObj) && !complexTypes.has(typeof typeObj)) {
      throw Error(`provable: unsupported type "${typeObj}"`);
    }
    function sizeInFields(typeObj2) {
      if (primitives2.has(typeObj2))
        return 0;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map(sizeInFields).reduce((a2, b2) => a2 + b2, 0);
      if ("sizeInFields" in typeObj2)
        return typeObj2.sizeInFields();
      return Object.values(typeObj2).map(sizeInFields).reduce((a2, b2) => a2 + b2, 0);
    }
    function toFields(typeObj2, obj, isToplevel = false) {
      if (primitives2.has(typeObj2))
        return [];
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toFields(t, obj[i2])).flat();
      if ("toFields" in typeObj2)
        return typeObj2.toFields(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2)).map((k) => toFields(typeObj2[k], obj[k])).flat();
    }
    function toAuxiliary(typeObj2, obj, isToplevel = false) {
      if (typeObj2 === Number)
        return [obj ?? 0];
      if (typeObj2 === String)
        return [obj ?? ""];
      if (typeObj2 === Boolean)
        return [obj ?? false];
      if (typeObj2 === BigInt)
        return [obj ?? 0n];
      if (typeObj2 === void 0 || typeObj2 === null)
        return [];
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toAuxiliary(t, obj?.[i2]));
      if ("toAuxiliary" in typeObj2)
        return typeObj2.toAuxiliary(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2)).map((k) => toAuxiliary(typeObj2[k], obj?.[k]));
    }
    function fromFields(typeObj2, fields, aux = [], isToplevel = false) {
      if (typeObj2 === Number || typeObj2 === String || typeObj2 === Boolean || typeObj2 === BigInt)
        return aux[0];
      if (typeObj2 === void 0 || typeObj2 === null)
        return typeObj2;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2)) {
        let array = [];
        let i2 = 0;
        let offset = 0;
        for (let subObj of typeObj2) {
          let size = sizeInFields(subObj);
          array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i2]));
          offset += size;
          i2++;
        }
        return array;
      }
      if ("fromFields" in typeObj2)
        return typeObj2.fromFields(fields, aux);
      let keys = isToplevel ? objectKeys : Object.keys(typeObj2);
      let values = fromFields(keys.map((k) => typeObj2[k]), fields, aux);
      return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
    }
    function check(typeObj2, obj, isToplevel = false) {
      if (primitives2.has(typeObj2))
        return;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.forEach((t, i2) => check(t, obj[i2]));
      if ("check" in typeObj2)
        return typeObj2.check(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2)).forEach((k) => check(typeObj2[k], obj[k]));
    }
    let { empty: empty4, fromJSON, toJSON, toInput } = signable2(typeObj);
    if (options?.isPure === true) {
      return {
        sizeInFields: () => sizeInFields(typeObj),
        toFields: (obj) => toFields(typeObj, obj, true),
        toAuxiliary: () => [],
        fromFields: (fields) => fromFields(typeObj, fields, [], true),
        toInput: (obj) => toInput(obj),
        toJSON: (obj) => toJSON(obj),
        fromJSON: (json) => fromJSON(json),
        check: (obj) => check(typeObj, obj, true),
        empty: () => empty4()
      };
    }
    return {
      sizeInFields: () => sizeInFields(typeObj),
      toFields: (obj) => toFields(typeObj, obj, true),
      toAuxiliary: (obj) => toAuxiliary(typeObj, obj, true),
      fromFields: (fields, aux) => fromFields(typeObj, fields, aux, true),
      toInput: (obj) => toInput(obj),
      toJSON: (obj) => toJSON(obj),
      fromJSON: (json) => fromJSON(json),
      check: (obj) => check(typeObj, obj, true),
      empty: () => empty4()
    };
  }
  function signable2(typeObj) {
    let objectKeys = typeof typeObj === "object" && typeObj !== null ? Object.keys(typeObj) : [];
    let primitives3 = /* @__PURE__ */ new Set([
      Number,
      String,
      Boolean,
      BigInt,
      null,
      void 0
    ]);
    if (!primitives3.has(typeObj) && !complexTypes.has(typeof typeObj)) {
      throw Error(`provable: unsupported type "${typeObj}"`);
    }
    function toInput(typeObj2, obj, isToplevel = false) {
      if (primitives3.has(typeObj2))
        return {};
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2)) {
        return typeObj2.map((t, i2) => toInput(t, obj[i2])).reduce(HashInput3.append, HashInput3.empty);
      }
      if ("toInput" in typeObj2)
        return typeObj2.toInput(obj);
      if ("toFields" in typeObj2) {
        return { fields: typeObj2.toFields(obj) };
      }
      return (isToplevel ? objectKeys : Object.keys(typeObj2)).map((k) => toInput(typeObj2[k], obj[k])).reduce(HashInput3.append, HashInput3.empty);
    }
    function toJSON(typeObj2, obj, isToplevel = false) {
      if (typeObj2 === BigInt)
        return obj.toString();
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return obj;
      if (typeObj2 === void 0 || typeObj2 === null)
        return null;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toJSON(t, obj[i2]));
      if ("toJSON" in typeObj2)
        return typeObj2.toJSON(obj);
      return Object.fromEntries((isToplevel ? objectKeys : Object.keys(typeObj2)).map((k) => [
        k,
        toJSON(typeObj2[k], obj[k])
      ]));
    }
    function fromJSON(typeObj2, json, isToplevel = false) {
      if (typeObj2 === BigInt)
        return BigInt(json);
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return json;
      if (typeObj2 === null || typeObj2 === void 0)
        return void 0;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => fromJSON(t, json[i2]));
      if ("fromJSON" in typeObj2)
        return typeObj2.fromJSON(json);
      let keys = isToplevel ? objectKeys : Object.keys(typeObj2);
      let values = fromJSON(keys.map((k) => typeObj2[k]), keys.map((k) => json[k]));
      return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
    }
    function empty4(typeObj2) {
      if (typeObj2 === Number)
        return 0;
      if (typeObj2 === String)
        return "";
      if (typeObj2 === Boolean)
        return false;
      if (typeObj2 === BigInt)
        return 0n;
      if (typeObj2 === null || typeObj2 === void 0)
        return typeObj2;
      if (!complexTypes.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map(empty4);
      if ("empty" in typeObj2)
        return typeObj2.empty();
      return Object.fromEntries(Object.keys(typeObj2).map((k) => [k, empty4(typeObj2[k])]));
    }
    return {
      toInput: (obj) => toInput(typeObj, obj, true),
      toJSON: (obj) => toJSON(typeObj, obj, true),
      fromJSON: (json) => fromJSON(typeObj, json, true),
      empty: () => empty4(typeObj)
    };
  }
  return { provable: provable3, signable: signable2 };
}
function createHashInput() {
  return {
    get empty() {
      return {};
    },
    append(input1, input2) {
      return {
        fields: (input1.fields ?? []).concat(input2.fields ?? []),
        packed: (input1.packed ?? []).concat(input2.packed ?? [])
      };
    }
  };
}

// dist/node/bindings/crypto/non-negative.js
function assertNonNegativeInteger(n, message) {
  if (!Number.isInteger(n) || n < 0)
    throw Error(message);
}
function assertPositiveInteger(n, message) {
  if (!Number.isInteger(n) || n <= 0)
    throw Error(message);
}

// dist/node/bindings/lib/binable.js
function defineBinable({ toBytes, readBytes }) {
  let readBytes_ = (bytes, offset) => {
    assertNonNegativeInteger(offset, "readBytes: offset must be integer >= 0");
    if (offset >= bytes.length)
      throw Error("readBytes: offset must be within bytes length");
    let [value, end] = readBytes(bytes, offset);
    if (end < offset)
      throw Error("offset returned by readBytes must be greater than initial offset");
    if (end > bytes.length)
      throw Error("offset returned by readBytes must not exceed bytes length");
    return [value, end];
  };
  return {
    toBytes,
    readBytes: readBytes_,
    // spec: fromBytes throws if the input bytes are not all used
    fromBytes(bytes) {
      let [value, offset] = readBytes_(bytes, 0);
      if (offset < bytes.length)
        throw Error("fromBytes: input bytes left over");
      return value;
    }
  };
}
function withVersionNumber(binable, versionNumber) {
  return defineBinable({
    toBytes(t) {
      let bytes = binable.toBytes(t);
      bytes.unshift(versionNumber);
      return bytes;
    },
    readBytes(bytes, offset) {
      let version = bytes[offset++];
      if (version !== versionNumber) {
        throw Error(`fromBytes: Invalid version byte. Expected ${versionNumber}, got ${version}.`);
      }
      return binable.readBytes(bytes, offset);
    }
  });
}
function withCheck({ toBytes, readBytes }, check) {
  return defineBinable({
    toBytes,
    readBytes(bytes, start) {
      let [value, end] = readBytes(bytes, start);
      check(value);
      return [value, end];
    }
  });
}
function record(binables, keys) {
  let binablesTuple = keys.map((key) => binables[key]);
  let tupleBinable = tuple(binablesTuple);
  return defineBinable({
    toBytes(t) {
      let array = keys.map((key) => t[key]);
      return tupleBinable.toBytes(array);
    },
    readBytes(bytes, start) {
      let [tupleValue, end] = tupleBinable.readBytes(bytes, start);
      let value = Object.fromEntries(keys.map((key, i2) => [key, tupleValue[i2]]));
      return [value, end];
    }
  });
}
function tuple(binables) {
  let n = binables.length;
  return defineBinable({
    toBytes(t) {
      let bytes = [];
      for (let i2 = 0; i2 < n; i2++) {
        let subBytes = binables[i2].toBytes(t[i2]);
        bytes.push(...subBytes);
      }
      return bytes;
    },
    readBytes(bytes, offset) {
      let values = [];
      for (let i2 = 0; i2 < n; i2++) {
        let [value, newOffset] = binables[i2].readBytes(bytes, offset);
        offset = newOffset;
        values.push(value);
      }
      return [values, offset];
    }
  });
}
var BinableString = defineBinable({
  toBytes(t) {
    return [stringLengthInBytes(t), ...stringToBytes(t)];
  },
  readBytes(bytes, offset) {
    let length = bytes[offset++];
    let end = offset + length;
    let string = stringFromBytes(bytes.slice(offset, end));
    return [string, end];
  }
});
var CODE_NEG_INT8 = 255;
var CODE_INT16 = 254;
var CODE_INT32 = 253;
var CODE_INT64 = 252;
function BinableInt(bits2) {
  let maxValue = 1n << BigInt(bits2 - 1);
  let nBytes = bits2 >> 3;
  if (nBytes * 8 !== bits2)
    throw Error("bits must be evenly divisible by 8");
  return defineBinable({
    toBytes(n) {
      if (n < -maxValue || n >= maxValue)
        throw Error(`int${bits2} out of range, got ${n}`);
      if (n >= 0) {
        if (n < 0x80n)
          return bigIntToBytes(n, 1);
        if (n < 0x8000n)
          return [CODE_INT16, ...bigIntToBytes(n, 2)];
        if (n < 2147483648)
          return [CODE_INT32, ...bigIntToBytes(n, 4)];
        else
          return [CODE_INT64, ...bigIntToBytes(n, 8)];
      } else {
        let M = 1n << 64n;
        if (n >= -0x80n)
          return [CODE_NEG_INT8, ...bigIntToBytes(M + n & 0xffn, 1)];
        if (n >= -0x8000n)
          return [CODE_INT16, ...bigIntToBytes(M + n & 0xffffn, 2)];
        if (n >= -2147483648)
          return [CODE_INT32, ...bigIntToBytes(M + n & 0xffffffffn, 4)];
        else
          return [CODE_INT64, ...bigIntToBytes(M + n, 8)];
      }
    },
    readBytes(bytes, offset) {
      let code = bytes[offset++];
      if (code < 128)
        return [BigInt(code), offset];
      let size = {
        [CODE_NEG_INT8]: 1,
        [CODE_INT16]: 2,
        [CODE_INT32]: 4,
        [CODE_INT64]: 8
      }[code];
      if (size === void 0) {
        throw Error("binable integer: invalid start byte");
      }
      let end = offset + size;
      let x = fillUInt(bytes.slice(offset, end), nBytes);
      if (x >= maxValue) {
        x -= 2n * maxValue;
      }
      if (x < -maxValue || x >= maxValue) {
        throw Error(`int${bits2} out of range, got ${x}`);
      }
      return [x, end];
    }
  });
}
function fillUInt(startBytes, nBytes) {
  let n = startBytes.length;
  let lastBit = startBytes[n - 1] >> 7;
  let fillByte = lastBit === 1 ? 255 : 0;
  let intBytes = startBytes.concat(Array(nBytes - n).fill(fillByte));
  let x = bytesToBigInt(intBytes);
  return x;
}
function BinableUint(bits2) {
  let binableInt = BinableInt(bits2);
  let maxValue = 1n << BigInt(bits2 - 1);
  return iso(binableInt, {
    to(uint) {
      if (uint < 0n || uint >= 2n * maxValue)
        throw Error(`uint${bits2} out of range, got ${uint}`);
      let ret = uint >= maxValue ? uint - 2n * maxValue : uint;
      return ret;
    },
    from(int) {
      let uint = int < 0n ? int + 2n * maxValue : int;
      if (uint < 0n || uint >= 2n * maxValue)
        throw Error(`uint${bits2} out of range, got ${uint}`);
      return uint;
    }
  });
}
var BinableInt64 = BinableInt(64);
var BinableInt32 = BinableInt(32);
var BinableUint64 = BinableUint(64);
var BinableUint32 = BinableUint(32);
function prefixToField(Field5, prefix) {
  let fieldSize = Field5.sizeInBytes;
  if (prefix.length >= fieldSize)
    throw Error("prefix too long");
  let stringBytes = stringToBytes(prefix);
  return Field5.fromBytes(stringBytes.concat(Array(fieldSize - stringBytes.length).fill(0)));
}
function bitsToBytes([...bits2]) {
  let bytes = [];
  while (bits2.length > 0) {
    let byteBits = bits2.splice(0, 8);
    let byte = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      if (!byteBits[i2])
        continue;
      byte |= 1 << i2;
    }
    bytes.push(byte);
  }
  return bytes;
}
function bytesToBits(bytes) {
  return bytes.map((byte) => {
    let bits2 = Array(8);
    for (let i2 = 0; i2 < 8; i2++) {
      bits2[i2] = !!(byte & 1);
      byte >>= 1;
    }
    return bits2;
  }).flat();
}
function withBits(binable, sizeInBits2) {
  return {
    ...binable,
    toBits(t) {
      return bytesToBits(binable.toBytes(t)).slice(0, sizeInBits2);
    },
    fromBits(bits2) {
      return binable.fromBytes(bitsToBytes(bits2));
    },
    sizeInBytes: Math.ceil(sizeInBits2 / 8),
    sizeInBits: sizeInBits2
  };
}
function iso(binable, { to, from }) {
  return defineBinable({
    toBytes(s) {
      return binable.toBytes(to(s));
    },
    readBytes(bytes, offset) {
      let [value, end] = binable.readBytes(bytes, offset);
      return [from(value), end];
    }
  });
}
var encoder2 = new TextEncoder();
var decoder = new TextDecoder();
function stringToBytes(s) {
  return [...encoder2.encode(s)];
}
function stringFromBytes(bytes) {
  return decoder.decode(Uint8Array.from(bytes));
}
function stringLengthInBytes(s) {
  return encoder2.encode(s).length;
}

// dist/node/bindings/lib/provable-bigint.js
var { signable } = createDerivers();
function ProvableBigint(check) {
  return {
    toInput(x) {
      return { fields: [x], packed: [] };
    },
    toJSON(x) {
      return x.toString();
    },
    fromJSON(json) {
      if (isNaN(json) || isNaN(parseFloat(json))) {
        throw Error(`fromJSON: expected a numeric string, got "${json}"`);
      }
      let x = BigInt(json);
      check(x);
      return x;
    },
    empty() {
      return 0n;
    }
  };
}
function BinableBigint(sizeInBits2, check) {
  let sizeInBytes = Math.ceil(sizeInBits2 / 8);
  return withBits(defineBinable({
    toBytes(x) {
      return bigIntToBytes(x, sizeInBytes);
    },
    readBytes(bytes, start) {
      let x = 0n;
      let bitPosition = 0n;
      let end = Math.min(start + sizeInBytes, bytes.length);
      for (let i2 = start; i2 < end; i2++) {
        x += BigInt(bytes[i2]) << bitPosition;
        bitPosition += 8n;
      }
      check(x);
      return [x, end];
    }
  }), sizeInBits2);
}

// dist/node/provable/field-bigint.js
var sizeInBits = Fp.sizeInBits;
var minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;
var checkField = checkRange(0n, Fp.modulus, "Field");
var checkBool = checkAllowList(/* @__PURE__ */ new Set([0n, 1n]), "Bool");
var checkSign = checkAllowList(/* @__PURE__ */ new Set([1n, minusOne]), "Sign");
var Field = pseudoClass(function Field2(value) {
  return mod(BigInt(value), Fp.modulus);
}, {
  ...ProvableBigint(checkField),
  ...BinableBigint(Fp.sizeInBits, checkField),
  ...Fp
});
var Bool = pseudoClass(function Bool2(value) {
  return BigInt(value);
}, {
  ...ProvableBigint(checkBool),
  ...BinableBigint(1, checkBool),
  toInput(x) {
    return { fields: [], packed: [[x, 1]] };
  },
  toBoolean(x) {
    return !!x;
  },
  toJSON(x) {
    return !!x;
  },
  fromJSON(b2) {
    let x = BigInt(b2);
    checkBool(x);
    return x;
  },
  sizeInBytes: 1,
  fromField(x) {
    checkBool(x);
    return x;
  }
});
function Unsigned(bits2) {
  let maxValue = (1n << BigInt(bits2)) - 1n;
  let checkUnsigned = checkRange(0n, 1n << BigInt(bits2), `UInt${bits2}`);
  let binable = BinableBigint(bits2, checkUnsigned);
  let bytes = Math.ceil(bits2 / 8);
  return pseudoClass(function Unsigned2(value) {
    let x = BigInt(value);
    checkUnsigned(x);
    return x;
  }, {
    ...ProvableBigint(checkUnsigned),
    ...binable,
    toInput(x) {
      return { fields: [], packed: [[x, bits2]] };
    },
    maxValue,
    random() {
      return binable.fromBytes([...randomBytes(bytes)]);
    }
  });
}
var UInt32 = Unsigned(32);
var UInt64 = Unsigned(64);
var Sign = pseudoClass(function Sign2(value) {
  if (value !== 1 && value !== -1)
    throw Error("Sign: input must be 1 or -1.");
  return mod(BigInt(value), Fp.modulus);
}, {
  ...ProvableBigint(checkSign),
  ...BinableBigint(1, checkSign),
  empty() {
    return 1n;
  },
  toInput(x) {
    return { fields: [], packed: [[x === 1n ? 1n : 0n, 1]] };
  },
  fromFields([x]) {
    if (x === 0n)
      return 1n;
    checkSign(x);
    return x;
  },
  toJSON(x) {
    return x === 1n ? "Positive" : "Negative";
  },
  fromJSON(x) {
    if (x !== "Positive" && x !== "Negative")
      throw Error("Sign: invalid input");
    return x === "Positive" ? 1n : minusOne;
  }
});
function pseudoClass(constructor, module2) {
  return Object.assign(constructor, module2);
}
function checkRange(lower, upper, name) {
  return (x) => {
    if (x < lower)
      throw Error(`${name}: inputs smaller than ${lower} are not allowed, got ${x}`);
    if (x >= upper)
      throw Error(`${name}: inputs larger than ${upper - 1n} are not allowed, got ${x}`);
  };
}
function checkAllowList(valid, name) {
  return (x) => {
    if (!valid.has(x)) {
      throw Error(`${name}: input must be one of ${[...valid].join(", ")}, got ${x}`);
    }
  };
}

// dist/node/lib/global-context.js
var Context = { create };
function create(options = {
  allowsNesting: true,
  default: void 0
}) {
  let t = Object.assign(function() {
    return t.data[t.data.length - 1]?.context;
  }, {
    data: [],
    allowsNesting: options.allowsNesting ?? true,
    get: () => get(t),
    has: () => t.data.length !== 0,
    runWith(context, func) {
      let id = enter(t, context);
      let result;
      let resultContext;
      try {
        result = func(context);
      } finally {
        resultContext = leave(t, id);
      }
      return [resultContext, result];
    },
    async runWithAsync(context, func) {
      let id = enter(t, context);
      let result;
      let resultContext;
      try {
        result = await func(context);
      } finally {
        resultContext = leave(t, id);
      }
      return [resultContext, result];
    },
    enter: (context) => enter(t, context),
    leave: (id) => leave(t, id),
    id: () => {
      if (t.data.length === 0)
        throw Error(contextConflictMessage);
      return t.data[t.data.length - 1].id;
    }
  });
  if (options.default !== void 0)
    enter(t, options.default);
  return t;
}
function enter(t, context) {
  if (t.data.length > 0 && !t.allowsNesting) {
    throw Error(contextConflictMessage);
  }
  let id = Math.random();
  t.data.push({ context, id });
  return id;
}
function leave(t, id) {
  let current = t.data.pop();
  if (current === void 0)
    throw Error(contextConflictMessage);
  if (current.id !== id)
    throw Error(contextConflictMessage);
  return current.context;
}
function get(t) {
  if (t.data.length === 0)
    throw Error(contextConflictMessage);
  let current = t.data[t.data.length - 1];
  return current.context;
}
var contextConflictMessage = "It seems you're running multiple provers concurrently within the same JavaScript thread, which, at the moment, is not supported and would lead to bugs.";

// dist/node/lib/provable-context.js
var snarkContext = Context.create({ default: {} });
function inProver() {
  return !!snarkContext.get().inProver;
}
function inCheckedComputation() {
  let ctx = snarkContext.get();
  return !!ctx.inCompile || !!ctx.inProver || !!ctx.inCheckedComputation;
}
function inCompile() {
  return !!snarkContext.get().inCompile;
}
function inAnalyze() {
  return !!snarkContext.get().inAnalyze;
}
function asProver(f) {
  if (inCheckedComputation()) {
    Snarky.run.asProver(f);
  } else {
    f();
  }
}
function runAndCheck(f) {
  let id = snarkContext.enter({ inCheckedComputation: true });
  try {
    Snarky.run.runAndCheck(f);
  } catch (error) {
    throw prettifyStacktrace(error);
  } finally {
    snarkContext.leave(id);
  }
}
function runUnchecked(f) {
  let id = snarkContext.enter({ inCheckedComputation: true });
  try {
    Snarky.run.runUnchecked(f);
  } catch (error) {
    throw prettifyStacktrace(error);
  } finally {
    snarkContext.leave(id);
  }
}
function constraintSystem(f) {
  let id = snarkContext.enter({ inAnalyze: true, inCheckedComputation: true });
  try {
    let result;
    let { rows, digest, json } = Snarky.run.constraintSystem(() => {
      result = f();
    });
    let { gates, publicInputSize } = gatesFromJson(json);
    return {
      rows,
      digest,
      result,
      gates,
      publicInputSize,
      print() {
        printGates(gates);
      },
      summary() {
        let gateTypes = {};
        gateTypes["Total rows"] = rows;
        for (let gate of gates) {
          gateTypes[gate.type] ??= 0;
          gateTypes[gate.type]++;
        }
        return gateTypes;
      }
    };
  } catch (error) {
    throw prettifyStacktrace(error);
  } finally {
    snarkContext.leave(id);
  }
}
function gatesFromJson(cs) {
  let gates = cs.gates.map(({ typ, wires, coeffs: hexCoeffs }) => {
    let coeffs = hexCoeffs.map((hex) => parseHexString32(hex).toString());
    return { type: typ, wires, coeffs };
  });
  return { publicInputSize: cs.public_input_size, gates };
}
function printGates(gates) {
  for (let i2 = 0, n = gates.length; i2 < n; i2++) {
    let { type, wires, coeffs } = gates[i2];
    console.log(i2.toString().padEnd(4, " "), type.padEnd(15, " "), coeffsToPretty(type, coeffs).padEnd(30, " "), wiresToPretty(wires, i2));
  }
  console.log();
}
var minusRange = Fp.modulus - (1n << 64n);
function coeffsToPretty(type, coeffs) {
  if (coeffs.length === 0)
    return "";
  if (type === "Generic" && coeffs.length > 5) {
    let first = coeffsToPretty(type, coeffs.slice(0, 5));
    let second = coeffsToPretty(type, coeffs.slice(5));
    return `${first} ${second}`;
  }
  if (type === "Poseidon" && coeffs.length > 3) {
    return `${coeffsToPretty(type, coeffs.slice(0, 3)).slice(0, -1)} ...]`;
  }
  let str = coeffs.map((c) => {
    let c0 = BigInt(c);
    if (c0 > minusRange)
      c0 -= Fp.modulus;
    let cStr = c0.toString();
    if (cStr.length > 4)
      return `${cStr.slice(0, 4)}..`;
    return cStr;
  }).join(" ");
  return `[${str}]`;
}
function wiresToPretty(wires, row) {
  let strWires = [];
  let n = wires.length;
  for (let col = 0; col < n; col++) {
    let wire = wires[col];
    if (wire.row === row && wire.col === col)
      continue;
    if (wire.row === row) {
      strWires.push(`${col}->${wire.col}`);
    } else {
      strWires.push(`${col}->(${wire.row},${wire.col})`);
    }
  }
  return strWires.join(", ");
}

// dist/node/lib/bool.js
var Bool3 = class _Bool {
  constructor(x) {
    if (x instanceof _Bool) {
      this.value = x.value;
      return;
    }
    if (Array.isArray(x)) {
      this.value = x;
      return;
    }
    this.value = FieldVar.constant(Bool(x));
  }
  isConstant() {
    return this.value[0] === FieldType.Constant;
  }
  /**
   * Converts a {@link Bool} to a {@link Field}. `false` becomes 0 and `true` becomes 1.
   */
  toField() {
    return _Bool.toField(this);
  }
  /**
   * @returns a new {@link Bool} that is the negation of this {@link Bool}.
   */
  not() {
    if (this.isConstant()) {
      return new _Bool(!this.toBoolean());
    }
    return new _Bool(Snarky.bool.not(this.value));
  }
  /**
   * @param y A {@link Bool} to AND with this {@link Bool}.
   * @returns a new {@link Bool} that is set to true only if
   * this {@link Bool} and `y` are also true.
   */
  and(y) {
    if (this.isConstant() && isConstant(y)) {
      return new _Bool(this.toBoolean() && toBoolean(y));
    }
    return new _Bool(Snarky.bool.and(this.value, toFieldVar(y)));
  }
  /**
   * @param y a {@link Bool} to OR with this {@link Bool}.
   * @returns a new {@link Bool} that is set to true if either
   * this {@link Bool} or `y` is true.
   */
  or(y) {
    if (this.isConstant() && isConstant(y)) {
      return new _Bool(this.toBoolean() || toBoolean(y));
    }
    return new _Bool(Snarky.bool.or(this.value, toFieldVar(y)));
  }
  /**
   * Proves that this {@link Bool} is equal to `y`.
   * @param y a {@link Bool}.
   */
  assertEquals(y, message) {
    try {
      if (this.isConstant() && isConstant(y)) {
        if (this.toBoolean() !== toBoolean(y)) {
          throw Error(`Bool.assertEquals(): ${this} != ${y}`);
        }
        return;
      }
      Snarky.bool.assertEqual(this.value, toFieldVar(y));
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Proves that this {@link Bool} is `true`.
   */
  assertTrue(message) {
    try {
      if (this.isConstant() && !this.toBoolean()) {
        throw Error(`Bool.assertTrue(): ${this} != ${true}`);
      }
      this.assertEquals(true);
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Proves that this {@link Bool} is `false`.
   */
  assertFalse(message) {
    try {
      if (this.isConstant() && this.toBoolean()) {
        throw Error(`Bool.assertFalse(): ${this} != ${false}`);
      }
      this.assertEquals(false);
    } catch (err) {
      throw withMessage(err, message);
    }
  }
  /**
   * Returns true if this {@link Bool} is equal to `y`.
   * @param y a {@link Bool}.
   */
  equals(y) {
    if (this.isConstant() && isConstant(y)) {
      return new _Bool(this.toBoolean() === toBoolean(y));
    }
    return new _Bool(Snarky.bool.equals(this.value, toFieldVar(y)));
  }
  /**
   * Returns the size of this type.
   */
  sizeInFields() {
    return 1;
  }
  /**
   * Serializes this {@link Bool} into {@link Field} elements.
   */
  toFields() {
    return _Bool.toFields(this);
  }
  /**
   * Serialize the {@link Bool} to a string, e.g. for printing.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  toString() {
    return this.toBoolean().toString();
  }
  /**
   * Serialize the {@link Bool} to a JSON string.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  toJSON() {
    return this.toBoolean();
  }
  /**
   * This converts the {@link Bool} to a javascript [[boolean]].
   * This can only be called on non-witness values.
   */
  toBoolean() {
    let value;
    if (this.isConstant()) {
      value = this.value[1];
    } else if (Snarky.run.inProverBlock()) {
      value = Snarky.field.readVar(this.value);
    } else {
      throw Error(readVarMessage("toBoolean", "b", "Bool"));
    }
    return FieldConst.equal(value, FieldConst[1]);
  }
  static toField(x) {
    return new Field3(toFieldVar(x));
  }
  /**
   * Boolean negation.
   */
  static not(x) {
    if (x instanceof _Bool) {
      return x.not();
    }
    return new _Bool(!x);
  }
  /**
   * Boolean AND operation.
   */
  static and(x, y) {
    if (x instanceof _Bool) {
      return x.and(y);
    }
    return new _Bool(x).and(y);
  }
  /**
   * Boolean OR operation.
   */
  static or(x, y) {
    if (x instanceof _Bool) {
      return x.or(y);
    }
    return new _Bool(x).or(y);
  }
  /**
   * Asserts if both {@link Bool} are equal.
   */
  static assertEqual(x, y) {
    if (x instanceof _Bool) {
      x.assertEquals(y);
      return;
    }
    new _Bool(x).assertEquals(y);
  }
  /**
   * Checks two {@link Bool} for equality.
   */
  static equal(x, y) {
    if (x instanceof _Bool) {
      return x.equals(y);
    }
    return new _Bool(x).equals(y);
  }
  /**
   * Static method to serialize a {@link Bool} into an array of {@link Field} elements.
   */
  static toFields(x) {
    return [_Bool.toField(x)];
  }
  /**
   * Static method to serialize a {@link Bool} into its auxiliary data.
   */
  static toAuxiliary(_) {
    return [];
  }
  /**
   * Creates a data structure from an array of serialized {@link Field} elements.
   */
  static fromFields(fields) {
    if (fields.length !== 1) {
      throw Error(`Bool.fromFields(): expected 1 field, got ${fields.length}`);
    }
    return new _Bool(fields[0].value);
  }
  /**
   * Serialize a {@link Bool} to a JSON string.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  static toJSON(x) {
    return x.toBoolean();
  }
  /**
   * Deserialize a JSON structure into a {@link Bool}.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.
   */
  static fromJSON(b2) {
    return new _Bool(b2);
  }
  /**
   * Returns the size of this type.
   */
  static sizeInFields() {
    return 1;
  }
  static empty() {
    return new _Bool(false);
  }
  static toInput(x) {
    return { packed: [[x.toField(), 1]] };
  }
  static toBytes(b2) {
    return BoolBinable.toBytes(b2);
  }
  static fromBytes(bytes) {
    return BoolBinable.fromBytes(bytes);
  }
  static readBytes(bytes, offset) {
    return BoolBinable.readBytes(bytes, offset);
  }
  static check(x) {
    Snarky.field.assertBoolean(x.value);
  }
};
Bool3.sizeInBytes = 1;
Bool3.Unsafe = {
  /**
   * Converts a {@link Field} into a {@link Bool}. This is a **dangerous** operation
   * as it assumes that the field element is either 0 or 1 (which might not be true).
   *
   * Only use this with constants or if you have already constrained the Field element to be 0 or 1.
   *
   * @param x a {@link Field}
   */
  ofField(x) {
    asProver(() => {
      let x0 = x.toBigInt();
      if (x0 !== 0n && x0 !== 1n)
        throw Error(`Bool.Unsafe.ofField(): Expected 0 or 1, got ${x0}`);
    });
    return new Bool3(x.value);
  }
};
var BoolBinable = defineBinable({
  toBytes(b2) {
    return [Number(b2.toBoolean())];
  },
  readBytes(bytes, offset) {
    return [new Bool3(!!bytes[offset]), offset + 1];
  }
});
function isConstant(x) {
  if (typeof x === "boolean") {
    return true;
  }
  return x.isConstant();
}
function toBoolean(x) {
  if (typeof x === "boolean") {
    return x;
  }
  return x.toBoolean();
}
function toFieldVar(x) {
  if (x instanceof Bool3)
    return x.value;
  return FieldVar.constant(Bool(x));
}
function withMessage(error, message) {
  if (message === void 0 || !(error instanceof Error))
    return error;
  error.message = `${message}
${error.message}`;
  return error;
}

// dist/node/lib/field.js
function constToBigint(x) {
  return x[1];
}
function constFromBigint(x) {
  return [0, Field(x)];
}
var FieldConst = {
  fromBigint: constFromBigint,
  toBigint: constToBigint,
  equal(x, y) {
    return x[1] === y[1];
  },
  [0]: constFromBigint(0n),
  [1]: constFromBigint(1n),
  [-1]: constFromBigint(-1n)
};
var FieldType;
(function(FieldType2) {
  FieldType2[FieldType2["Constant"] = 0] = "Constant";
  FieldType2[FieldType2["Var"] = 1] = "Var";
  FieldType2[FieldType2["Add"] = 2] = "Add";
  FieldType2[FieldType2["Scale"] = 3] = "Scale";
})(FieldType || (FieldType = {}));
var FieldVar = {
  constant(x) {
    let x0 = typeof x === "bigint" ? FieldConst.fromBigint(x) : x;
    return [FieldType.Constant, x0];
  },
  isConstant(x) {
    return x[0] === FieldType.Constant;
  },
  isVar(x) {
    return x[0] === FieldType.Var;
  },
  add(x, y) {
    if (FieldVar.isConstant(x) && x[1][1] === 0n)
      return y;
    if (FieldVar.isConstant(y) && y[1][1] === 0n)
      return x;
    if (FieldVar.isConstant(x) && FieldVar.isConstant(y)) {
      return FieldVar.constant(Field.add(x[1][1], y[1][1]));
    }
    return [FieldType.Add, x, y];
  },
  scale(c, x) {
    let c0 = typeof c === "bigint" ? FieldConst.fromBigint(c) : c;
    if (c0[1] === 0n)
      return FieldVar.constant(0n);
    if (c0[1] === 1n)
      return x;
    if (FieldVar.isConstant(x)) {
      return FieldVar.constant(Field.mul(c0[1], x[1][1]));
    }
    return [FieldType.Scale, c0, x];
  },
  [0]: [FieldType.Constant, FieldConst[0]],
  [1]: [FieldType.Constant, FieldConst[1]],
  [-1]: [FieldType.Constant, FieldConst[-1]]
};
var Field3 = class _Field {
  /**
   * Coerce anything "field-like" (bigint, number, string, and {@link Field}) to a Field.
   */
  constructor(x) {
    if (x instanceof _Field) {
      this.value = x.value;
      return;
    }
    if (Array.isArray(x)) {
      if (typeof x[1] === "bigint") {
        this.value = FieldVar.constant(x);
        return;
      } else {
        this.value = x;
        return;
      }
    }
    this.value = FieldVar.constant(Field(x));
  }
  // helpers
  static from(x) {
    if (x instanceof _Field)
      return x;
    return new _Field(x);
  }
  /**
   * Check whether this {@link Field} element is a hard-coded constant in the constraint system.
   * If a {@link Field} is constructed outside a zkApp method, it is a constant.
   *
   * @example
   * ```ts
   * console.log(Field(42).isConstant()); // true
   * ```
   *
   * @example
   * ```ts
   * \@method myMethod(x: Field) {
   *    console.log(x.isConstant()); // false
   * }
   * ```
   *
   * @return A `boolean` showing if this {@link Field} is a constant or not.
   */
  isConstant() {
    return this.value[0] === FieldType.Constant;
  }
  /**
   * Create a {@link Field} element equivalent to this {@link Field} element's value,
   * but is a constant.
   * See {@link Field.isConstant} for more information about what is a constant {@link Field}.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * someField.toConstant().assertEquals(someField); // Always true
   * ```
   *
   * @return A constant {@link Field} element equivalent to this {@link Field} element.
   */
  toConstant() {
    return toConstant(this, "toConstant");
  }
  /**
   * Serialize the {@link Field} to a bigint, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the bigint representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(someField.toBigInt());
   * ```
   *
   * @return A bigint equivalent to the bigint representation of the Field.
   */
  toBigInt() {
    let x = toConstant(this, "toBigInt");
    return FieldConst.toBigint(x.value[1]);
  }
  /**
   * Serialize the {@link Field} to a string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(someField.toString());
   * ```
   *
   * @return A string equivalent to the string representation of the Field.
   */
  toString() {
    return toConstant(this, "toString").toBigInt().toString();
  }
  /**
   * Assert that this {@link Field} is equal another "field-like" value.
   * Calling this function is equivalent to `Field(...).equals(...).assertEquals(Bool(true))`.
   * See {@link Field.equals} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertEquals(y, message) {
    try {
      if (this.isConstant() && isConstant2(y)) {
        if (this.toBigInt() !== toFp(y)) {
          throw Error(`Field.assertEquals(): ${this} != ${y}`);
        }
        return;
      }
      Snarky.field.assertEqual(this.value, toFieldVar2(y));
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  /**
   * Add a "field-like" value to this {@link Field} element.
   *
   * @example
   * ```ts
   * const x = Field(3);
   * const sum = x.add(5);
   *
   * sum.assertEquals(Field(8));
   * ```
   *
   * **Warning**: This is a modular addition in the pasta field.
   * @example
   * ```ts
   * const x = Field(1);
   * const sum = x.add(Field(-7));
   *
   * // If you try to print sum - `console.log(sum.toBigInt())` - you will realize that it prints a very big integer because this is modular arithmetic, and 1 + (-7) circles around the field to become p - 6.
   * // You can use the reverse operation of addition (subtraction) to prove the sum is calculated correctly.
   *
   * sum.sub(x).assertEquals(Field(-7));
   * sum.sub(Field(-7)).assertEquals(x);
   * ```
   *
   * @param value - a "field-like" value to add to the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular addition of the two value.
   */
  add(y) {
    if (this.isConstant() && isConstant2(y)) {
      return new _Field(Field.add(this.toBigInt(), toFp(y)));
    }
    let z = Snarky.field.add(this.value, toFieldVar2(y));
    return new _Field(z);
  }
  /**
   * Negate a {@link Field}. This is equivalent to multiplying the {@link Field} by -1.
   *
   * @example
   * ```ts
   * const negOne = Field(1).neg();
   * negOne.assertEquals(-1);
   * ```
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * someField.neg().assertEquals(someField.mul(Field(-1))); // This statement is always true regardless of the value of `someField`
   * ```
   *
   * **Warning**: This is a modular negation. For details, see the {@link sub} method.
   *
   * @return A {@link Field} element that is equivalent to the element multiplied by -1.
   */
  neg() {
    if (this.isConstant()) {
      return new _Field(Field.negate(this.toBigInt()));
    }
    let z = Snarky.field.scale(FieldConst[-1], this.value);
    return new _Field(z);
  }
  /**
   * Subtract another "field-like" value from this {@link Field} element.
   *
   * @example
   * ```ts
   * const x = Field(3);
   * const difference = x.sub(5);
   *
   * difference.assertEquals(Field(-2));
   * ```
   *
   * **Warning**: This is a modular subtraction in the pasta field.
   *
   * @example
   * ```ts
   * const x = Field(1);
   * const difference = x.sub(Field(2));
   *
   * // If you try to print difference - `console.log(difference.toBigInt())` - you will realize that it prints a very big integer because this is modular arithmetic, and 1 - 2 circles around the field to become p - 1.
   * // You can use the reverse operation of subtraction (addition) to prove the difference is calculated correctly.
   * difference.add(Field(2)).assertEquals(x);
   * ```
   *
   * @param value - a "field-like" value to subtract from the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular difference of the two value.
   */
  sub(y) {
    return this.add(_Field.from(y).neg());
  }
  /**
   * Checks if this {@link Field} is even. Returns `true` for even elements and `false` for odd elements.
   *
   * @example
   * ```ts
   * let a = Field(5);
   * a.isEven(); // false
   * a.isEven().assertTrue(); // throws, as expected!
   *
   * let b = Field(4);
   * b.isEven(); // true
   * b.isEven().assertTrue(); // does not throw, as expected!
   * ```
   */
  isEven() {
    if (this.isConstant())
      return new Bool3(this.toBigInt() % 2n === 0n);
    let [, isOddVar, xDiv2Var] = Snarky.exists(2, () => {
      let bits2 = Field.toBits(this.toBigInt());
      let isOdd2 = bits2.shift() ? 1n : 0n;
      return [
        0,
        FieldConst.fromBigint(isOdd2),
        FieldConst.fromBigint(Field.fromBits(bits2))
      ];
    });
    let isOdd = new _Field(isOddVar);
    let xDiv2 = new _Field(xDiv2Var);
    xDiv2.toBits(253);
    xDiv2.mul(2).add(isOdd).assertEquals(this);
    return new Bool3(isOddVar).not();
  }
  /**
   * Multiply another "field-like" value with this {@link Field} element.
   *
   * @example
   * ```ts
   * const x = Field(3);
   * const product = x.mul(Field(5));
   *
   * product.assertEquals(Field(15));
   * ```
   *
   * @param value - a "field-like" value to multiply with the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular difference of the two value.
   */
  mul(y) {
    if (this.isConstant() && isConstant2(y)) {
      return new _Field(Field.mul(this.toBigInt(), toFp(y)));
    }
    if (isConstant2(y)) {
      let z2 = Snarky.field.scale(toFieldConst(y), this.value);
      return new _Field(z2);
    }
    if (this.isConstant()) {
      let z2 = Snarky.field.scale(this.value[1], y.value);
      return new _Field(z2);
    }
    let z = Snarky.existsVar(() => FieldConst.fromBigint(Field.mul(this.toBigInt(), toFp(y))));
    Snarky.field.assertMul(this.value, y.value, z);
    return new _Field(z);
  }
  /**
   * [Modular inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of this {@link Field} element.
   * Equivalent to 1 divided by this {@link Field}, in the sense of modular arithmetic.
   *
   * Proves that this Field is non-zero, or throws a "Division by zero" error.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * const inverse = someField.inv();
   * inverse.assertEquals(Field(1).div(example)); // This statement is always true regardless of the value of `someField`
   * ```
   *
   * **Warning**: This is a modular inverse. See {@link div} method for more details.
   *
   * @return A {@link Field} element that is equivalent to one divided by this element.
   */
  inv() {
    if (this.isConstant()) {
      let z2 = Field.inverse(this.toBigInt());
      if (z2 === void 0)
        throw Error("Field.inv(): Division by zero");
      return new _Field(z2);
    }
    let z = Snarky.existsVar(() => {
      let z2 = Field.inverse(this.toBigInt()) ?? 0n;
      return FieldConst.fromBigint(z2);
    });
    Snarky.field.assertMul(this.value, z, FieldVar[1]);
    return new _Field(z);
  }
  /**
   * Divide another "field-like" value through this {@link Field}.
   *
   * Proves that the denominator is non-zero, or throws a "Division by zero" error.
   *
   * @example
   * ```ts
   * const x = Field(6);
   * const quotient = x.div(Field(3));
   *
   * quotient.assertEquals(Field(2));
   * ```
   *
   * **Warning**: This is a modular division in the pasta field. You can think this as the reverse operation of modular multiplication.
   *
   * @example
   * ```ts
   * const x = Field(2);
   * const y = Field(5);
   *
   * const quotient = x.div(y);
   *
   * // If you try to print quotient - `console.log(quotient.toBigInt())` - you will realize that it prints a very big integer because this is a modular inverse.
   * // You can use the reverse operation of division (multiplication) to prove the quotient is calculated correctly.
   *
   * quotient.mul(y).assertEquals(x);
   * ```
   *
   * @param value - a "field-like" value to divide with the {@link Field}.
   *
   * @return A {@link Field} element equivalent to the modular division of the two value.
   */
  div(y) {
    return this.mul(_Field.from(y).inv());
  }
  /**
   * Square this {@link Field} element.
   *
   * @example
   * ```ts
   * const someField = Field(7);
   * const square = someField.square();
   *
   * square.assertEquals(someField.mul(someField)); // This statement is always true regardless of the value of `someField`
   * ```
   *
   * ** Warning: This is a modular multiplication. See `mul()` method for more details.
   *
   * @return A {@link Field} element equivalent to the multiplication of the {@link Field} element with itself.
   */
  square() {
    if (this.isConstant()) {
      return new _Field(Field.square(this.toBigInt()));
    }
    let z = Snarky.existsVar(() => FieldConst.fromBigint(Field.square(this.toBigInt())));
    Snarky.field.assertSquare(this.value, z);
    return new _Field(z);
  }
  /**
   * Take the square root of this {@link Field} element.
   *
   * Proves that the Field element has a square root in the finite field, or throws if it doesn't.
   *
   * @example
   * ```ts
   * let z = x.sqrt();
   * z.mul(z).assertEquals(x); // true for every `x`
   * ```
   *
   * **Warning**: This is a modular square root, which is any number z that satisfies z*z = x (mod p).
   * Note that, if a square root z exists, there also exists a second one, -z (which is different if z != 0).
   * Therefore, this method leaves an adversarial prover the choice between two different values to return.
   *
   * @return A {@link Field} element equivalent to the square root of the {@link Field} element.
   */
  sqrt() {
    if (this.isConstant()) {
      let z2 = Field.sqrt(this.toBigInt());
      if (z2 === void 0)
        throw Error(`Field.sqrt(): input ${this} has no square root in the field.`);
      return new _Field(z2);
    }
    let z = Snarky.existsVar(() => {
      let z2 = Field.sqrt(this.toBigInt()) ?? 0n;
      return FieldConst.fromBigint(z2);
    });
    Snarky.field.assertSquare(z, this.value);
    return new _Field(z);
  }
  /**
   * @deprecated use `x.equals(0)` which is equivalent
   */
  isZero() {
    if (this.isConstant()) {
      return new Bool3(this.toBigInt() === 0n);
    }
    let [, b2, z] = Snarky.exists(2, () => {
      let x = this.toBigInt();
      let z2 = Field.inverse(x) ?? 0n;
      let b3 = Field.sub(1n, Field.mul(z2, x));
      return [0, FieldConst.fromBigint(b3), FieldConst.fromBigint(z2)];
    });
    Snarky.field.assertMul(b2, this.value, FieldVar[0]);
    Snarky.field.assertMul(z, this.value, Snarky.field.add(FieldVar[1], Snarky.field.scale(FieldConst[-1], b2)));
    return new Bool3(b2);
  }
  /**
   * Check if this {@link Field} is equal another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * Field(5).equals(5).assertEquals(Bool(true));
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is equal another "field-like" value.
   */
  equals(y) {
    if (this.isConstant() || isConstant2(y)) {
      return this.sub(y).isZero();
    }
    let xMinusY = Snarky.existsVar(() => FieldConst.fromBigint(Field.sub(this.toBigInt(), toFp(y))));
    Snarky.field.assertEqual(this.sub(y).value, xMinusY);
    return new _Field(xMinusY).isZero();
  }
  /**
   * Check if this {@link Field} is less than another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used prove to the validity of this statement.
   *
   * @example
   * ```ts
   * Field(2).lessThan(3).assertEquals(Bool(true));
   * ```
   *
   * **Warning**: Comparison methods only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behavior when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * Field(1).div(Field(3)).lessThan(Field(1).div(Field(2))).assertEquals(Bool(true)); // This code will throw an error
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is less than another "field-like" value.
   */
  lessThan(y) {
    if (this.isConstant() && isConstant2(y)) {
      return new Bool3(this.toBigInt() < toFp(y));
    }
    return compare(this, toFieldVar2(y)).less;
  }
  /**
   * Check if this {@link Field} is less than or equal to another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * Field(3).lessThanOrEqual(3).assertEquals(Bool(true));
   * ```
   *
   * **Warning**: Comparison methods only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * Field(1).div(Field(3)).lessThanOrEqual(Field(1).div(Field(2))).assertEquals(Bool(true)); // This code will throw an error
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is less than or equal another "field-like" value.
   */
  lessThanOrEqual(y) {
    if (this.isConstant() && isConstant2(y)) {
      return new Bool3(this.toBigInt() <= toFp(y));
    }
    return compare(this, toFieldVar2(y)).lessOrEqual;
  }
  /**
   * Check if this {@link Field} is greater than another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * Field(5).greaterThan(3).assertEquals(Bool(true));
   * ```
   *
   * **Warning**: Comparison methods currently only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * Field(1).div(Field(2)).greaterThan(Field(1).div(Field(3))).assertEquals(Bool(true)); // This code will throw an error
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is greater than another "field-like" value.
   */
  greaterThan(y) {
    return _Field.from(y).lessThan(this);
  }
  /**
   * Check if this {@link Field} is greater than or equal another "field-like" value.
   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.
   *
   * @example
   * ```ts
   * Field(3).greaterThanOrEqual(3).assertEquals(Bool(true));
   * ```
   *
   * **Warning**: Comparison methods only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.
   *
   * @example
   * ```ts
   * Field(1).div(Field(2)).greaterThanOrEqual(Field(1).div(Field(3))).assertEquals(Bool(true)); // This code will throw an error
   * ```
   *
   * @param value - the "field-like" value to compare with this {@link Field}.
   *
   * @return A {@link Bool} representing if this {@link Field} is greater than or equal another "field-like" value.
   */
  greaterThanOrEqual(y) {
    return _Field.from(y).lessThanOrEqual(this);
  }
  /**
   * Assert that this {@link Field} is less than another "field-like" value.
   * Calling this function is equivalent to `Field(...).lessThan(...).assertEquals(Bool(true))`.
   * See {@link Field.lessThan} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * **Warning**: Comparison methods only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThan(y, message) {
    try {
      if (this.isConstant() && isConstant2(y)) {
        if (!(this.toBigInt() < toFp(y))) {
          throw Error(`Field.assertLessThan(): expected ${this} < ${y}`);
        }
        return;
      }
      let { less } = compare(this, toFieldVar2(y));
      less.assertTrue();
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  /**
   * Assert that this {@link Field} is less than or equal to another "field-like" value.
   * Calling this function is equivalent to `Field(...).lessThanOrEqual(...).assertEquals(Bool(true))`.
   * See {@link Field.lessThanOrEqual} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * **Warning**: Comparison methods only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThanOrEqual(y, message) {
    try {
      if (this.isConstant() && isConstant2(y)) {
        if (!(this.toBigInt() <= toFp(y))) {
          throw Error(`Field.assertLessThan(): expected ${this} <= ${y}`);
        }
        return;
      }
      let { lessOrEqual } = compare(this, toFieldVar2(y));
      lessOrEqual.assertTrue();
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  /**
   * Assert that this {@link Field} is greater than another "field-like" value.
   * Calling this function is equivalent to `Field(...).greaterThan(...).assertEquals(Bool(true))`.
   * See {@link Field.greaterThan} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * **Warning**: Comparison methods only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThan(y, message) {
    _Field.from(y).assertLessThan(this, message);
  }
  /**
   * Assert that this {@link Field} is greater than or equal to another "field-like" value.
   * Calling this function is equivalent to `Field(...).greaterThanOrEqual(...).assertEquals(Bool(true))`.
   * See {@link Field.greaterThanOrEqual} for more details.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * **Warning**: Comparison methods only support Field elements of size <= 253 bits in provable code.
   * The method will throw if one of the inputs exceeds 253 bits.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThanOrEqual(y, message) {
    _Field.from(y).assertLessThanOrEqual(this, message);
  }
  /**
   * Assert that this {@link Field} does not equal another field-like value.
   *
   * Note: This uses fewer constraints than `x.equals(y).assertFalse()`.
   *
   * @example
   * ```ts
   * x.assertNotEquals(0, "expect x to be non-zero");
   * ```
   */
  assertNotEquals(y, message) {
    try {
      if (this.isConstant() && isConstant2(y)) {
        if (this.toBigInt() === toFp(y)) {
          throw Error(`Field.assertNotEquals(): ${this} = ${y}`);
        }
        return;
      }
      this.sub(y).inv();
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  /**
   * Assert that this {@link Field} is equal to 1 or 0 as a "field-like" value.
   * Calling this function is equivalent to `Bool.or(Field(...).equals(1), Field(...).equals(0)).assertEquals(Bool(true))`.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param value - the "field-like" value to compare & assert with this {@link Field}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertBool(message) {
    try {
      if (this.isConstant()) {
        let x = this.toBigInt();
        if (x !== 0n && x !== 1n) {
          throw Error(`Field.assertBool(): expected ${x} to be 0 or 1`);
        }
        return;
      }
      Snarky.field.assertBoolean(this.value);
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  /**
   * Returns an array of {@link Bool} elements representing [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of this {@link Field} element.
   *
   * If you use the optional `length` argument, proves that the field element fits in `length` bits.
   * The `length` has to be between 0 and 255 and the method throws if it isn't.
   *
   * **Warning**: The cost of this operation in a zk proof depends on the `length` you specify,
   * which by default is 255 bits. Prefer to pass a smaller `length` if possible.
   *
   * @param length - the number of bits to fit the element. If the element does not fit in `length` bits, the functions throws an error.
   *
   * @return An array of {@link Bool} element representing little endian binary representation of this {@link Field}.
   */
  toBits(length) {
    if (length !== void 0)
      checkBitLength("Field.toBits()", length);
    if (this.isConstant()) {
      let bits3 = Field.toBits(this.toBigInt());
      if (length !== void 0) {
        if (bits3.slice(length).some((bit) => bit))
          throw Error(`Field.toBits(): ${this} does not fit in ${length} bits`);
        return bits3.slice(0, length).map((b2) => new Bool3(b2));
      }
      return bits3.map((b2) => new Bool3(b2));
    }
    let [, ...bits2] = Snarky.field.toBits(length ?? Field.sizeInBits, this.value);
    return bits2.map((b2) => new Bool3(b2));
  }
  /**
   * Convert a bit array into a {@link Field} element using [little endian binary representation](https://en.wikipedia.org/wiki/Endianness)
   *
   * The method throws if the given bits do not fit in a single Field element. A Field element can be at most 255 bits.
   *
   * **Important**: If the given `bytes` array is an array of `booleans` or {@link Bool} elements that all are `constant`, the resulting {@link Field} element will be a constant as well. Or else, if the given array is a mixture of constants and variables of {@link Bool} type, the resulting {@link Field} will be a variable as well.
   *
   * @param bytes - An array of {@link Bool} or `boolean` type.
   *
   * @return A {@link Field} element matching the [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of the given `bytes` array.
   */
  static fromBits(bits2) {
    let length = bits2.length;
    checkBitLength("Field.fromBits()", length);
    if (bits2.every((b2) => typeof b2 === "boolean" || b2.toField().isConstant())) {
      let bits_ = bits2.map((b2) => typeof b2 === "boolean" ? b2 : b2.toBoolean()).concat(Array(Field.sizeInBits - length).fill(false));
      return new _Field(Field.fromBits(bits_));
    }
    let bitsVars = bits2.map((b2) => {
      if (typeof b2 === "boolean")
        return b2 ? FieldVar[1] : FieldVar[0];
      return b2.toField().value;
    });
    let x = Snarky.field.fromBits([0, ...bitsVars]);
    return new _Field(x);
  }
  /**
   * Create a new {@link Field} element from the first `length` bits of this {@link Field} element.
   *
   * The `length` has to be a multiple of 16, and has to be between 0 and 255, otherwise the method throws.
   *
   * As {@link Field} elements are represented using [little endian binary representation](https://en.wikipedia.org/wiki/Endianness),
   * the resulting {@link Field} element will equal the original one if it fits in `length` bits.
   *
   * @param length - The number of bits to take from this {@link Field} element.
   *
   * @return A {@link Field} element that is equal to the `length` of this {@link Field} element.
   */
  rangeCheckHelper(length) {
    checkBitLength("Field.rangeCheckHelper()", length);
    if (length % 16 !== 0)
      throw Error("Field.rangeCheckHelper(): `length` has to be a multiple of 16.");
    let lengthDiv16 = length / 16;
    if (this.isConstant()) {
      let bits2 = Field.toBits(this.toBigInt()).slice(0, length).concat(Array(Field.sizeInBits - length).fill(false));
      return new _Field(Field.fromBits(bits2));
    }
    let x = Snarky.field.truncateToBits16(lengthDiv16, this.value);
    return new _Field(x);
  }
  /**
   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.
   *
   * In o1js, addition and scaling (multiplication of variables by a constant) of variables is represented as an AST - [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree). For example, the expression `x.add(y).mul(2)` is represented as `Scale(2, Add(x, y))`.
   *
   *  A new internal variable is created only when the variable is needed in a multiplicative or any higher level constraint (for example multiplication of two {@link Field} elements) to represent the operation.
   *
   * The `seal()` function tells o1js to stop building an AST and create a new variable right away.
   *
   * @return A {@link Field} element that is equal to the result of AST that was previously on this {@link Field} element.
   */
  seal() {
    if (this.isConstant())
      return this;
    let x = Snarky.field.seal(this.value);
    return VarField(x);
  }
  /**
   * A random {@link Field} element.
   *
   * @example
   * ```ts
   * console.log(Field.random().toBigInt()); // Run this code twice!
   * ```
   *
   * @return A random {@link Field} element.
   */
  static random() {
    return new _Field(Field.random());
  }
  // internal stuff
  // Provable<Field>
  /**
   * This function is the implementation of {@link Provable.toFields} for the {@link Field} type.
   *
   * Static function to serializes a {@link Field} into an array of {@link Field} elements.
   * This will be always an array of length 1, where the first and only element equals the given parameter itself.
   *
   * @param value - the {@link Field} element to cast the array from.
   *
   * @return A {@link Field} array of length 1 created from this {@link Field}.
   */
  static toFields(x) {
    return [x];
  }
  /**
   * This function is the implementation of {@link Provable.toAuxiliary} for the {@link Field} type.
   *
   * As the primitive {@link Field} type has no auxiliary data associated with it, this function will always return an empty array.
   *
   * @param value - The {@link Field} element to get the auxiliary data of, optional. If not provided, the function returns an empty array.
   */
  static toAuxiliary() {
    return [];
  }
  /**
   * This function is the implementation of {@link Provable.sizeInFields} for the {@link Field} type.
   *
   * Size of the {@link Field} type is 1, as it is the primitive type.
   * This function returns a regular number, so you cannot use it to prove something on chain. You can use it during debugging or to understand the memory complexity of some type.
   *
   * @example
   * ```ts
   * console.log(Field.sizeInFields()); // Prints 1
   * ```
   *
   * @return A number representing the size of the {@link Field} type in terms of {@link Field} type itself.
   */
  static sizeInFields() {
    return 1;
  }
  /**
   * Implementation of {@link Provable.fromFields} for the {@link Field} type.
   *
   * **Warning**: This function is designed for internal use. It is not intended to be used by a zkApp developer.
   *
   * Creates a {@link Field} from an array of Fields of length 1.
   *
   * @param fields - an array of length 1 serialized from {@link Field} elements.
   *
   * @return The first {@link Field} element of the given array.
   */
  static fromFields([x]) {
    return x;
  }
  /**
   * This function is the implementation of {@link Provable.check} in {@link Field} type.
   *
   * As any field element can be a {@link Field}, this function does not create any assertions, so it does nothing.
   *
   * @param value - the {@link Field} element to check.
   */
  static check() {
  }
  /**
   * This function is the implementation of {@link Provable.toFields} for the {@link Field} type.
   *
   * The result will be always an array of length 1, where the first and only element equals the {@link Field} itself.
   *
   * @return A {@link Field} array of length 1 created from this {@link Field}.
   */
  toFields() {
    return _Field.toFields(this);
  }
  /**
   * This function is the implementation of {@link Provable.toAuxiliary} for the {@link Field} type.
   *
   * As the primitive {@link Field} type has no auxiliary data associated with it, this function will always return an empty array.
   */
  toAuxiliary() {
    return _Field.toAuxiliary();
  }
  // ProvableExtended<Field>
  static empty() {
    return new _Field(0n);
  }
  /**
   * Serialize the {@link Field} to a JSON string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the JSON string representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(someField.toJSON());
   * ```
   *
   * @return A string equivalent to the JSON representation of the {@link Field}.
   */
  toJSON() {
    return toConstant(this, "toJSON").toString();
  }
  /**
   * Serialize the given {@link Field} element to a JSON string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the JSON string representation of the {@link Field}. Use the operation only during debugging.
   *
   * @example
   * ```ts
   * const someField = Field(42);
   * console.log(Field.toJSON(someField));
   * ```
   *
   * @param value - The JSON string to coerce the {@link Field} from.
   *
   * @return A string equivalent to the JSON representation of the given {@link Field}.
   */
  static toJSON(x) {
    return x.toJSON();
  }
  /**
   * Deserialize a JSON string containing a "field-like" value into a {@link Field} element.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the {@link Field}.
   *
   * @param value - the "field-like" value to coerce the {@link Field} from.
   *
   * @return A {@link Field} coerced from the given JSON string.
   */
  static fromJSON(json) {
    return new _Field(Field.fromJSON(json));
  }
  /**
   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.
   *
   * This function is the implementation of `ProvableExtended.toInput()` for the {@link Field} type.
   *
   * @param value - The {@link Field} element to get the `input` array.
   *
   * @return An object where the `fields` key is a {@link Field} array of length 1 created from this {@link Field}.
   *
   */
  static toInput(x) {
    return { fields: [x] };
  }
  // Binable<Field>
  /**
   * Create an array of digits equal to the [little-endian](https://en.wikipedia.org/wiki/Endianness) byte order of the given {@link Field} element.
   * Note that the array has always 32 elements as the {@link Field} is a `finite-field` in the order of {@link Field.ORDER}.
   *
   * @param value - The {@link Field} element to generate the array of bytes of.
   *
   * @return An array of digits equal to the [little-endian](https://en.wikipedia.org/wiki/Endianness) byte order of the given {@link Field} element.
   *
   */
  static toBytes(x) {
    return FieldBinable.toBytes(x);
  }
  /**
   * Part of the `Binable` interface.
   *
   * **Warning**: This function is for internal use. It is not intended to be used by a zkApp developer.
   */
  static readBytes(bytes, offset) {
    return FieldBinable.readBytes(bytes, offset);
  }
  /**
   * Coerce a new {@link Field} element using the [little-endian](https://en.wikipedia.org/wiki/Endianness) representation of the given `bytes` array.
   * Note that the given `bytes` array may have at most 32 elements as the {@link Field} is a `finite-field` in the order of {@link Field.ORDER}.
   *
   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the byte representation of the {@link Field}.
   *
   * @param bytes - The bytes array to coerce the {@link Field} from.
   *
   * @return A new {@link Field} element created using the [little-endian](https://en.wikipedia.org/wiki/Endianness) representation of the given `bytes` array.
   */
  static fromBytes(bytes) {
    return FieldBinable.fromBytes(bytes);
  }
};
Field3.ORDER = Field.modulus;
Field3.sizeInBytes = Field.sizeInBytes;
Field3.sizeInBits = Field.sizeInBits;
var FieldBinable = defineBinable({
  toBytes(t) {
    let t0 = toConstantField(t, "toBytes").toBigInt();
    return Field.toBytes(t0);
  },
  readBytes(bytes, offset) {
    let uint8array = new Uint8Array(32);
    uint8array.set(bytes.slice(offset, offset + 32));
    let x = Field.fromBytes([...uint8array]);
    return [new Field3(x), offset + 32];
  }
});
function isConstant2(x) {
  let type = typeof x;
  if (type === "bigint" || type === "number" || type === "string") {
    return true;
  }
  return x.isConstant();
}
function toFp(x) {
  let type = typeof x;
  if (type === "bigint" || type === "number" || type === "string") {
    return Field(x);
  }
  return x.toBigInt();
}
function toFieldConst(x) {
  if (x instanceof Field3)
    return x.value[1];
  return FieldConst.fromBigint(Field(x));
}
function toFieldVar2(x) {
  if (x instanceof Field3)
    return x.value;
  return FieldVar.constant(Field(x));
}
function withMessage2(error, message) {
  if (message === void 0 || !(error instanceof Error))
    return error;
  error.message = `${message}
${error.message}`;
  return error;
}
function compare(x, y) {
  let maxLength = Field.sizeInBits - 2;
  asProver(() => {
    let actualLength = Math.max(x.toBigInt().toString(2).length, new Field3(y).toBigInt().toString(2).length);
    if (actualLength > maxLength)
      throw Error(`Provable comparison functions can only be used on Fields of size <= ${maxLength} bits, got ${actualLength} bits.`);
  });
  let [, less, lessOrEqual] = Snarky.field.compare(maxLength, x.value, y);
  return { less: new Bool3(less), lessOrEqual: new Bool3(lessOrEqual) };
}
function checkBitLength(name, length, maxLength = Field.sizeInBits) {
  if (length > maxLength)
    throw Error(`${name}: bit length must be ${maxLength} or less, got ${length}`);
  if (length < 0)
    throw Error(`${name}: bit length must be non-negative, got ${length}`);
}
function toConstant(x, name) {
  return toConstantField(x, name, "x", "field element");
}
function toConstantField(x, methodName, varName = "x", varDescription = "field element") {
  if (x.isConstant())
    return x;
  assert2(inCheckedComputation(), "variables only exist inside checked computations");
  if (Snarky.run.inProverBlock()) {
    let value = Snarky.field.readVar(x.value);
    return new Field3(value);
  }
  throw Error(readVarMessage(methodName, varName, varDescription));
}
function readVarMessage(methodName, varName, varDescription) {
  return `${varName}.${methodName}() was called on a variable ${varDescription} \`${varName}\` in provable code.
This is not supported, because variables represent an abstract computation, 
which only carries actual values during proving, but not during compiling.

Also, reading out JS values means that whatever you're doing with those values will no longer be
linked to the original variable in the proof, which makes this pattern prone to security holes.

You can check whether your ${varDescription} is a variable or a constant by using ${varName}.isConstant().

To inspect values for debugging, use Provable.log(${varName}). For more advanced use cases,
there is \`Provable.asProver(() => { ... })\` which allows you to use ${varName}.${methodName}() inside the callback.
Warning: whatever happens inside asProver() will not be part of the zk proof.
`;
}
function VarField(x) {
  return new Field3(x);
}

// dist/node/lib/base58.js
var import_js_sha256 = require("js-sha256");
var alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
var inverseAlphabet = {};
alphabet.forEach((c, i2) => {
  inverseAlphabet[c] = i2;
});
function toBase58Check(input, versionByte) {
  let withVersion2 = [versionByte, ...input];
  let checksum = computeChecksum(withVersion2);
  let withChecksum = withVersion2.concat(checksum);
  return toBase58(withChecksum);
}
function fromBase58Check(base582, versionByte) {
  let bytes = fromBase58(base582);
  let checksum = bytes.slice(-4);
  let originalBytes = bytes.slice(0, -4);
  let actualChecksum = computeChecksum(originalBytes);
  if (!arrayEqual(checksum, actualChecksum))
    throw Error("fromBase58Check: invalid checksum");
  if (originalBytes[0] !== versionByte)
    throw Error(`fromBase58Check: input version byte ${versionByte} does not match encoded version byte ${originalBytes[0]}`);
  return originalBytes.slice(1);
}
function toBase58(bytes) {
  let z = 0;
  while (bytes[z] === 0)
    z++;
  let digits = [...bytes].map(BigInt).reverse();
  let base58Digits = changeBase(digits, 256n, 58n).reverse();
  base58Digits = Array(z).fill(0n).concat(base58Digits);
  return base58Digits.map((x) => alphabet[Number(x)]).join("");
}
function fromBase58(base582) {
  let base58Digits = [...base582].map((c) => {
    let digit = inverseAlphabet[c];
    if (digit === void 0)
      throw Error("fromBase58: invalid character");
    return BigInt(digit);
  });
  let z = 0;
  while (base58Digits[z] === 0n)
    z++;
  let digits = changeBase(base58Digits.reverse(), 58n, 256n).reverse();
  digits = Array(z).fill(0n).concat(digits);
  return digits.map(Number);
}
function computeChecksum(input) {
  let hash1 = import_js_sha256.sha256.create();
  hash1.update(input);
  let hash22 = import_js_sha256.sha256.create();
  hash22.update(hash1.array());
  return hash22.array().slice(0, 4);
}
function base58(binable, versionByte) {
  return {
    toBase58(t) {
      let bytes = binable.toBytes(t);
      return toBase58Check(bytes, versionByte);
    },
    fromBase58(base582) {
      let bytes = fromBase58Check(base582, versionByte);
      return binable.fromBytes(bytes);
    }
  };
}
function withBase58(binable, versionByte) {
  return { ...binable, ...base58(binable, versionByte) };
}
function customEncoding(Field5, versionByte, versionNumber) {
  let customField = versionNumber !== void 0 ? withVersionNumber(Field5, versionNumber) : Field5;
  return base58(customField, versionByte);
}
var RECEIPT_CHAIN_HASH_VERSION = 1;
var LEDGER_HASH_VERSION = 1;
var EPOCH_SEED_VERSION = 1;
var STATE_HASH_VERSION = 1;
function fieldEncodings(Field5) {
  const TokenId5 = customEncoding(Field5, versionBytes.tokenIdKey);
  const ReceiptChainHash4 = customEncoding(Field5, versionBytes.receiptChainHash, RECEIPT_CHAIN_HASH_VERSION);
  const LedgerHash2 = customEncoding(Field5, versionBytes.ledgerHash, LEDGER_HASH_VERSION);
  const EpochSeed2 = customEncoding(Field5, versionBytes.epochSeed, EPOCH_SEED_VERSION);
  const StateHash4 = customEncoding(Field5, versionBytes.stateHash, STATE_HASH_VERSION);
  return { TokenId: TokenId5, ReceiptChainHash: ReceiptChainHash4, LedgerHash: LedgerHash2, EpochSeed: EpochSeed2, StateHash: StateHash4 };
}
function arrayEqual(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    if (a2[i2] !== b2[i2])
      return false;
  }
  return true;
}

// dist/node/provable/curve-bigint.js
var versionNumbers = {
  field: 1,
  scalar: 1,
  publicKey: 1,
  signature: 1
};
var Group = {
  toProjective({ x, y }) {
    return Pallas.fromAffine({ x, y, infinity: false });
  },
  /**
   * Convert a projective point to a non-zero affine point.
   * Throws an error if the point is zero / infinity, i.e. if z === 0
   */
  fromProjective(point) {
    let { x, y, infinity } = Pallas.toAffine(point);
    if (infinity)
      throw Error("Group.fromProjective: point is infinity");
    return { x, y };
  },
  get generatorMina() {
    return Group.fromProjective(Pallas.one);
  },
  scale(point, scalar) {
    return Group.fromProjective(Pallas.scale(Group.toProjective(point), scalar));
  },
  b: Pallas.b,
  toFields({ x, y }) {
    return [x, y];
  }
};
var FieldWithVersion = withVersionNumber(Field, versionNumbers.field);
var BinablePublicKey = withVersionNumber(withCheck(record({ x: FieldWithVersion, isOdd: Bool }, ["x", "isOdd"]), ({ x }) => {
  let { mul, add: add2 } = Field;
  let ySquared = add2(mul(x, mul(x, x)), Pallas.b);
  if (!Field.isSquare(ySquared)) {
    throw Error("PublicKey: not a valid group element");
  }
}), versionNumbers.publicKey);
var PublicKey = {
  ...signable({ x: Field, isOdd: Bool }),
  ...withBase58(BinablePublicKey, versionBytes.publicKey),
  toJSON(publicKey) {
    return PublicKey.toBase58(publicKey);
  },
  fromJSON(json) {
    return PublicKey.fromBase58(json);
  },
  toGroup({ x, isOdd }) {
    let { mul, add: add2 } = Field;
    let ySquared = add2(mul(x, mul(x, x)), Pallas.b);
    let y = Field.sqrt(ySquared);
    if (y === void 0) {
      throw Error("PublicKey.toGroup: not a valid group element");
    }
    if (isOdd !== (y & 1n))
      y = Field.negate(y);
    return { x, y };
  },
  fromGroup({ x, y }) {
    let isOdd = y & 1n;
    return { x, isOdd };
  },
  equal(pk1, pk2) {
    return pk1.x === pk2.x && pk1.isOdd === pk2.isOdd;
  },
  toInputLegacy({ x, isOdd }) {
    return { fields: [x], bits: [!!isOdd] };
  }
};
var checkScalar = checkRange(0n, Fq.modulus, "Scalar");
var Scalar = pseudoClass(function Scalar2(value) {
  return mod(BigInt(value), Fq.modulus);
}, {
  ...ProvableBigint(checkScalar),
  ...BinableBigint(Fq.sizeInBits, checkScalar),
  ...Fq
});
var BinablePrivateKey = withVersionNumber(Scalar, versionNumbers.scalar);
var Base58PrivateKey = base58(BinablePrivateKey, versionBytes.privateKey);
var PrivateKey = {
  ...Scalar,
  ...signable(Scalar),
  ...Base58PrivateKey,
  ...BinablePrivateKey,
  toPublicKey(key) {
    return PublicKey.fromGroup(Group.scale(Group.generatorMina, key));
  }
};

// dist/node/lib/scalar.js
var ScalarConst = {
  fromBigint: constFromBigint2,
  toBigint: constToBigint2,
  is(x) {
    return Array.isArray(x) && x[0] === 0 && typeof x[1] === "bigint";
  }
};
var scalarShift = Scalar(1n + 2n ** 255n);
var oneHalf = Scalar.inverse(2n);
var Scalar3 = class _Scalar {
  constructor(bits2, constantValue) {
    this.value = bits2;
    constantValue ??= toConstantScalar(bits2);
    if (constantValue !== void 0) {
      this.constantValue = ScalarConst.fromBigint(constantValue);
    }
  }
  /**
   * Create a constant {@link Scalar} from a bigint, number, string or Scalar.
   *
   * If the input is too large, it is reduced modulo the scalar field size.
   */
  static from(x) {
    if (x instanceof _Scalar)
      return x;
    if (ScalarConst.is(x))
      x = constToBigint2(x);
    let scalar = Scalar(x);
    let bits2 = toBits(scalar);
    return new _Scalar(bits2, scalar);
  }
  /**
   * Check whether this {@link Scalar} is a hard-coded constant in the constraint system.
   * If a {@link Scalar} is constructed outside provable code, it is a constant.
   */
  isConstant() {
    return this.constantValue !== void 0;
  }
  /**
   * Convert this {@link Scalar} into a constant if it isn't already.
   *
   * If the scalar is a variable, this only works inside `asProver` or `witness` blocks.
   *
   * See {@link FieldVar} for an explanation of constants vs. variables.
   */
  toConstant() {
    if (this.constantValue !== void 0)
      return this;
    let [, ...bits2] = this.value;
    let constBits = bits2.map((b2) => FieldVar.constant(Snarky.field.readVar(b2)));
    return new _Scalar([0, ...constBits]);
  }
  /**
   * @deprecated use {@link Scalar.from}
   */
  static fromBigInt(x) {
    return _Scalar.from(x);
  }
  /**
   * Convert this {@link Scalar} into a bigint
   */
  toBigInt() {
    return assertConstant(this, "toBigInt");
  }
  // TODO: fix this API. we should represent "shifted status" internally and use
  // and use shifted Group.scale only if the scalar bits representation is shifted
  /**
   * Creates a data structure from an array of serialized {@link Bool}.
   *
   * **Warning**: The bits are interpreted as the bits of 2s + 1 + 2^255, where s is the Scalar.
   */
  static fromBits(bits2) {
    return _Scalar.fromFields(bits2.map((b2) => b2.toField()));
  }
  /**
   * Returns a random {@link Scalar}.
   * Randomness can not be proven inside a circuit!
   */
  static random() {
    return _Scalar.from(Scalar.random());
  }
  // operations on constant scalars
  /**
   * Negate a scalar field element.
   *
   * **Warning**: This method is not available for provable code.
   */
  neg() {
    let x = assertConstant(this, "neg");
    let z = Scalar.negate(x);
    return _Scalar.from(z);
  }
  /**
   * Add scalar field elements.
   *
   * **Warning**: This method is not available for provable code.
   */
  add(y) {
    let x = assertConstant(this, "add");
    let y0 = assertConstant(y, "add");
    let z = Scalar.add(x, y0);
    return _Scalar.from(z);
  }
  /**
   * Subtract scalar field elements.
   *
   * **Warning**: This method is not available for provable code.
   */
  sub(y) {
    let x = assertConstant(this, "sub");
    let y0 = assertConstant(y, "sub");
    let z = Scalar.sub(x, y0);
    return _Scalar.from(z);
  }
  /**
   * Multiply scalar field elements.
   *
   * **Warning**: This method is not available for provable code.
   */
  mul(y) {
    let x = assertConstant(this, "mul");
    let y0 = assertConstant(y, "mul");
    let z = Scalar.mul(x, y0);
    return _Scalar.from(z);
  }
  /**
   * Divide scalar field elements.
   * Throws if the denominator is zero.
   *
   * **Warning**: This method is not available for provable code.
   */
  div(y) {
    let x = assertConstant(this, "div");
    let y0 = assertConstant(y, "div");
    let z = Scalar.div(x, y0);
    if (z === void 0)
      throw Error("Scalar.div(): Division by zero");
    return _Scalar.from(z);
  }
  // TODO don't leak 'shifting' to the user and remove these methods
  shift() {
    let x = assertConstant(this, "shift");
    return _Scalar.from(shift(x));
  }
  unshift() {
    let x = assertConstant(this, "unshift");
    return _Scalar.from(unshift(x));
  }
  /**
   * Serialize a Scalar into a Field element plus one bit, where the bit is represented as a Bool.
   *
   * **Warning**: This method is not available for provable code.
   *
   * Note: Since the Scalar field is slightly larger than the base Field, an additional high bit
   * is needed to represent all Scalars. However, for a random Scalar, the high bit will be `false` with overwhelming probability.
   */
  toFieldsCompressed() {
    let s = assertConstant(this, "toFieldsCompressed");
    let lowBitSize = BigInt(Scalar.sizeInBits - 1);
    let lowBitMask = (1n << lowBitSize) - 1n;
    return {
      field: new Field3(s & lowBitMask),
      highBit: new Bool3(s >> lowBitSize === 1n)
    };
  }
  // internal stuff
  // Provable<Scalar>
  /**
   * Part of the {@link Provable} interface.
   *
   * Serialize a {@link Scalar} into an array of {@link Field} elements.
   *
   * **Warning**: This function is for internal usage. It returns 255 field elements
   * which represent the Scalar in a shifted, bitwise format.
   * The fields are not constrained to be boolean.
   */
  static toFields(x) {
    let [, ...bits2] = x.value;
    return bits2.map((b2) => new Field3(b2));
  }
  /**
   * Serialize this Scalar to Field elements.
   *
   * **Warning**: This function is for internal usage. It returns 255 field elements
   * which represent the Scalar in a shifted, bitwise format.
   * The fields are not constrained to be boolean.
   *
   * Check out {@link Scalar.toFieldsCompressed} for a user-friendly serialization
   * that can be used outside proofs.
   */
  toFields() {
    return _Scalar.toFields(this);
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Serialize a {@link Scalar} into its auxiliary data, which are empty.
   */
  static toAuxiliary() {
    return [];
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Creates a data structure from an array of serialized {@link Field} elements.
   */
  static fromFields(fields) {
    return new _Scalar([0, ...fields.map((x) => x.value)]);
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns the size of this type in {@link Field} elements.
   */
  static sizeInFields() {
    return Scalar.sizeInBits;
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Does nothing.
   */
  static check() {
  }
  // ProvableExtended<Scalar>
  /**
   * Serialize a {@link Scalar} to a JSON string.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Scalar.
   */
  static toJSON(x) {
    let s = assertConstant(x, "toJSON");
    return s.toString();
  }
  /**
   * Serializes this Scalar to a string
   */
  toJSON() {
    return _Scalar.toJSON(this);
  }
  /**
   * Deserialize a JSON structure into a {@link Scalar}.
   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Scalar.
   */
  static fromJSON(x) {
    return _Scalar.from(Scalar.fromJSON(x));
  }
};
Scalar3.ORDER = Scalar.modulus;
function assertConstant(x, name) {
  return constantScalarToBigint(x, `Scalar.${name}`);
}
function toConstantScalar([, ...bits2]) {
  if (bits2.length !== Scalar.sizeInBits)
    throw Error(`Scalar: expected bits array of length ${Scalar.sizeInBits}, got ${bits2.length}`);
  let constantBits = Array(bits2.length);
  for (let i2 = 0; i2 < bits2.length; i2++) {
    let bool = bits2[i2];
    if (!FieldVar.isConstant(bool))
      return void 0;
    constantBits[i2] = FieldConst.equal(bool[1], FieldConst[1]);
  }
  let sShifted = Scalar.fromBits(constantBits);
  return shift(sShifted);
}
function toBits(constantValue) {
  return [
    0,
    ...Scalar.toBits(unshift(constantValue)).map((b2) => FieldVar.constant(BigInt(b2)))
  ];
}
function shift(s) {
  return Scalar.add(Scalar.add(s, s), scalarShift);
}
function unshift(s) {
  return Scalar.mul(Scalar.sub(s, scalarShift), oneHalf);
}
function constToBigint2(x) {
  return x[1];
}
function constFromBigint2(x) {
  return [0, x];
}
function constantScalarToBigint(s, name) {
  if (s.constantValue === void 0)
    throw Error(`${name}() is not available in provable code.
That means it can't be called in a @method or similar environment, and there's no alternative implemented to achieve that.`);
  return ScalarConst.toBigint(s.constantValue);
}

// dist/node/bindings/lib/provable-snarky.js
var HashInput = createHashInput();
var { provable } = createDerivers();
function provablePure(typeObj) {
  return provable(typeObj, { isPure: true });
}
function provableTuple(types) {
  return provable(types);
}
function provableFromClass(Class, typeObj) {
  let raw2 = provable(typeObj);
  return {
    sizeInFields: raw2.sizeInFields,
    toFields: raw2.toFields,
    toAuxiliary: raw2.toAuxiliary,
    fromFields(fields, aux) {
      return construct(Class, raw2.fromFields(fields, aux));
    },
    check(value) {
      if (Class.check !== void 0) {
        Class.check(value);
      } else {
        raw2.check(value);
      }
    },
    toInput: raw2.toInput,
    toJSON: raw2.toJSON,
    fromJSON(x) {
      return construct(Class, raw2.fromJSON(x));
    },
    empty() {
      return construct(Class, raw2.empty());
    }
  };
}
function construct(Class, value) {
  let instance = Object.create(Class.prototype);
  return Object.assign(instance, value);
}

// dist/node/lib/provable.js
var Provable = {
  /**
   * Create a new witness. A witness, or variable, is a value that is provided as input
   * by the prover. This provides a flexible way to introduce values from outside into the circuit.
   * However, note that nothing about how the value was created is part of the proof - `Provable.witness`
   * behaves exactly like user input. So, make sure that after receiving the witness you make any assertions
   * that you want to associate with it.
   * @example
   * Example for re-implementing `Field.inv` with the help of `witness`:
   * ```ts
   * let invX = Provable.witness(Field, () => {
   *   // compute the inverse of `x` outside the circuit, however you like!
   *   return Field.inv(x));
   * }
   * // prove that `invX` is really the inverse of `x`:
   * invX.mul(x).assertEquals(1);
   * ```
   */
  witness,
  /**
   * Proof-compatible if-statement.
   * This behaves like a ternary conditional statement in JS.
   *
   * **Warning**: Since `Provable.if()` is a normal JS function call, both the if and the else branch
   * are evaluated before calling it. Therefore, you can't use this function
   * to guard against execution of one of the branches. It only allows you to pick one of two values.
   *
   * @example
   * ```ts
   * const condition = Bool(true);
   * const result = Provable.if(condition, Field(1), Field(2)); // returns Field(1)
   * ```
   */
  if: if_,
  /**
   * Generalization of {@link Provable.if} for choosing between more than two different cases.
   * It takes a "mask", which is an array of `Bool`s that contains only one `true` element, a type/constructor, and an array of values of that type.
   * The result is that value which corresponds to the true element of the mask.
   * @example
   * ```ts
   * let x = Provable.switch([Bool(false), Bool(true)], Field, [Field(1), Field(2)]);
   * x.assertEquals(2);
   * ```
   */
  switch: switch_,
  /**
   * Asserts that two values are equal.
   * @example
   * ```ts
   * class MyStruct extends Struct({ a: Field, b: Bool }) {};
   * const a: MyStruct = { a: Field(0), b: Bool(false) };
   * const b: MyStruct = { a: Field(1), b: Bool(true) };
   * Provable.assertEqual(MyStruct, a, b);
   * ```
   */
  assertEqual,
  /**
   * Checks if two elements are equal.
   * @example
   * ```ts
   * class MyStruct extends Struct({ a: Field, b: Bool }) {};
   * const a: MyStruct = { a: Field(0), b: Bool(false) };
   * const b: MyStruct = { a: Field(1), b: Bool(true) };
   * const isEqual = Provable.equal(MyStruct, a, b);
   * ```
   */
  equal,
  /**
   * Creates a {@link Provable} for a generic array.
   * @example
   * ```ts
   * const ProvableArray = Provable.Array(Field, 5);
   * ```
   */
  Array: provableArray,
  /**
   * Check whether a value is constant.
   * See {@link FieldVar} for more information about constants and variables.
   *
   * @example
   * ```ts
   * let x = Field(42);
   * Provable.isConstant(Field, x); // true
   * ```
   */
  isConstant: isConstant3,
  /**
   * Interface to log elements within a circuit. Similar to `console.log()`.
   * @example
   * ```ts
   * const element = Field(42);
   * Provable.log(element);
   * ```
   */
  log,
  /**
   * Runs code as a prover.
   * @example
   * ```ts
   * Provable.asProver(() => {
   *   // Your prover code here
   * });
   * ```
   */
  asProver,
  /**
   * Runs provable code quickly, without creating a proof, but still checking whether constraints are satisfied.
   * @example
   * ```ts
   * Provable.runAndCheck(() => {
   *   // Your code to check here
   * });
   * ```
   */
  runAndCheck,
  /**
   * Runs provable code quickly, without creating a proof, and not checking whether constraints are satisfied.
   * @example
   * ```ts
   * Provable.runUnchecked(() => {
   *   // Your code to run here
   * });
   * ```
   */
  runUnchecked,
  /**
   * Returns information about the constraints created by the callback function.
   * @example
   * ```ts
   * const result = Provable.constraintSystem(circuit);
   * console.log(result);
   * ```
   */
  constraintSystem,
  /**
   * Checks if the code is run in prover mode.
   * @example
   * ```ts
   * if (Provable.inProver()) {
   *   // Prover-specific code
   * }
   * ```
   */
  inProver,
  /**
   * Checks if the code is run in checked computation mode.
   * @example
   * ```ts
   * if (Provable.inCheckedComputation()) {
   *   // Checked computation-specific code
   * }
   * ```
   */
  inCheckedComputation
};
function witness(type, compute) {
  let ctx = snarkContext.get();
  if (!inCheckedComputation() || ctx.inWitnessBlock) {
    return clone(type, compute());
  }
  let proverValue = void 0;
  let fields;
  let id = snarkContext.enter({ ...ctx, inWitnessBlock: true });
  try {
    let [, ...fieldVars] = Snarky.exists(type.sizeInFields(), () => {
      proverValue = compute();
      let fields2 = type.toFields(proverValue);
      let fieldConstants = fields2.map((x) => x.toConstant().value[1]);
      return [0, ...fieldConstants];
    });
    fields = fieldVars.map(Field4);
  } finally {
    snarkContext.leave(id);
  }
  let aux = type.toAuxiliary(proverValue);
  let value = type.fromFields(fields, aux);
  type.check(value);
  return value;
}
function assertEqual(typeOrX, xOrY, yOrUndefined) {
  if (yOrUndefined === void 0) {
    return assertEqualImplicit(typeOrX, xOrY);
  } else {
    return assertEqualExplicit(typeOrX, xOrY, yOrUndefined);
  }
}
function assertEqualImplicit(x, y) {
  let xs = x.toFields();
  let ys = y.toFields();
  let n = checkLength("Provable.assertEqual", xs, ys);
  for (let i2 = 0; i2 < n; i2++) {
    xs[i2].assertEquals(ys[i2]);
  }
}
function assertEqualExplicit(type, x, y) {
  let xs = type.toFields(x);
  let ys = type.toFields(y);
  for (let i2 = 0; i2 < xs.length; i2++) {
    xs[i2].assertEquals(ys[i2]);
  }
}
function equal(typeOrX, xOrY, yOrUndefined) {
  if (yOrUndefined === void 0) {
    return equalImplicit(typeOrX, xOrY);
  } else {
    return equalExplicit(typeOrX, xOrY, yOrUndefined);
  }
}
function equalImplicit(x, y) {
  let xs = x.toFields();
  let ys = y.toFields();
  checkLength("Provable.equal", xs, ys);
  return xs.map((x2, i2) => x2.equals(ys[i2])).reduce(Bool4.and);
}
function equalExplicit(type, x, y) {
  let xs = type.toFields(x);
  let ys = type.toFields(y);
  return xs.map((x2, i2) => x2.equals(ys[i2])).reduce(Bool4.and);
}
function if_(condition, typeOrX, xOrY, yOrUndefined) {
  if (yOrUndefined === void 0) {
    return ifImplicit(condition, typeOrX, xOrY);
  } else {
    return ifExplicit(condition, typeOrX, xOrY, yOrUndefined);
  }
}
function ifField(b2, x, y) {
  return b2.mul(x.sub(y)).add(y).seal();
}
function ifExplicit(condition, type, x, y) {
  let xs = type.toFields(x);
  let ys = type.toFields(y);
  let b2 = condition.toField();
  if (b2.isConstant()) {
    return clone(type, condition.toBoolean() ? x : y);
  }
  let fields = xs.map((xi, i2) => ifField(b2, xi, ys[i2]));
  let aux = auxiliary(type, () => condition.toBoolean() ? x : y);
  return type.fromFields(fields, aux);
}
function ifImplicit(condition, x, y) {
  let type = x.constructor;
  if (type === void 0)
    throw Error(`You called Provable.if(bool, x, y) with an argument x that has no constructor, which is not supported.
If x, y are Structs or other custom types, you can use the following:
Provable.if(bool, MyType, x, y)`);
  if (type !== y.constructor) {
    throw Error(`Provable.if: Mismatched argument types. Try using an explicit type argument:
Provable.if(bool, MyType, x, y)`);
  }
  if (!("fromFields" in type && "toFields" in type)) {
    throw Error(`Provable.if: Invalid argument type. Try using an explicit type argument:
Provable.if(bool, MyType, x, y)`);
  }
  return ifExplicit(condition, type, x, y);
}
function switch_(mask, type, values) {
  let nValues = values.length;
  if (mask.length !== nValues)
    throw Error(`Provable.switch: \`values\` and \`mask\` have different lengths (${values.length} vs. ${mask.length}), which is not allowed.`);
  let checkMask = () => {
    let nTrue = mask.filter((b2) => b2.toBoolean()).length;
    if (nTrue > 1) {
      throw Error(`Provable.switch: \`mask\` must have 0 or 1 true element, found ${nTrue}.`);
    }
  };
  if (mask.every((b2) => b2.toField().isConstant()))
    checkMask();
  else
    Provable.asProver(checkMask);
  let size = type.sizeInFields();
  let fields = Array(size).fill(Field4(0));
  for (let i2 = 0; i2 < nValues; i2++) {
    let valueFields = type.toFields(values[i2]);
    let maskField = mask[i2].toField();
    for (let j = 0; j < size; j++) {
      let maybeField = valueFields[j].mul(maskField);
      fields[j] = fields[j].add(maybeField);
    }
  }
  let aux = auxiliary(type, () => {
    let i2 = mask.findIndex((b2) => b2.toBoolean());
    if (i2 === -1)
      return void 0;
    return values[i2];
  });
  return type.fromFields(fields, aux);
}
function isConstant3(type, x) {
  return type.toFields(x).every((x2) => x2.isConstant());
}
function log(...args) {
  asProver(() => {
    let prettyArgs = [];
    for (let arg of args) {
      if (arg?.toPretty !== void 0)
        prettyArgs.push(arg.toPretty());
      else {
        try {
          prettyArgs.push(JSON.parse(JSON.stringify(arg)));
        } catch {
          prettyArgs.push(arg);
        }
      }
    }
    console.log(...prettyArgs);
  });
}
function checkLength(name, xs, ys) {
  let n = xs.length;
  let m = ys.length;
  if (n !== m) {
    throw Error(`${name}: inputs must contain the same number of field elements, got ${n} !== ${m}`);
  }
  return n;
}
function clone(type, value) {
  let fields = type.toFields(value);
  let aux = type.toAuxiliary?.(value) ?? [];
  return type.fromFields(fields, aux);
}
function auxiliary(type, compute) {
  let aux;
  Provable.asProver(() => {
    let value = compute();
    if (value !== void 0) {
      aux = type.toAuxiliary?.(value);
    }
  });
  return aux ?? type.toAuxiliary?.() ?? [];
}
var memoizationContext = Context.create();
function memoizeWitness(type, compute) {
  return Provable.witness(type, () => {
    if (!memoizationContext.has())
      return compute();
    let context = memoizationContext.get();
    let { memoized, currentIndex } = context;
    let currentValue = memoized[currentIndex];
    if (currentValue === void 0) {
      let value = compute();
      let fields = type.toFields(value).map((x) => x.toConstant());
      let aux = type.toAuxiliary(value);
      currentValue = { fields, aux };
      memoized[currentIndex] = currentValue;
    }
    context.currentIndex += 1;
    return type.fromFields(currentValue.fields, currentValue.aux);
  });
}
function getBlindingValue() {
  if (!memoizationContext.has())
    return Field4.random();
  let context = memoizationContext.get();
  if (context.blindingValue === void 0) {
    context.blindingValue = Field4.random();
  }
  return context.blindingValue;
}
function provableArray(elementType, length) {
  let type = elementType;
  return {
    /**
     * Returns the size of this structure in {@link Field} elements.
     * @returns size of this structure
     */
    sizeInFields() {
      let elementLength = type.sizeInFields();
      return elementLength * length;
    },
    /**
     * Serializes this structure into {@link Field} elements.
     * @returns an array of {@link Field} elements
     */
    toFields(array) {
      return array.map((e) => type.toFields(e)).flat();
    },
    /**
     * Serializes this structure's auxiliary data.
     * @returns auxiliary data
     */
    toAuxiliary(array) {
      let array_ = array ?? Array(length).fill(void 0);
      return array_?.map((e) => type.toAuxiliary(e));
    },
    /**
     * Deserializes an array of {@link Field} elements into this structure.
     */
    fromFields(fields, aux) {
      let array = [];
      let size = type.sizeInFields();
      let n = length;
      for (let i2 = 0, offset = 0; i2 < n; i2++, offset += size) {
        array[i2] = type.fromFields(fields.slice(offset, offset + size), aux?.[i2]);
      }
      return array;
    },
    check(array) {
      for (let i2 = 0; i2 < length; i2++) {
        type.check(array[i2]);
      }
    },
    /**
     * Encodes this structure into a JSON-like object.
     */
    toJSON(array) {
      if (!("toJSON" in type)) {
        throw Error("circuitArray.toJSON: element type has no toJSON method");
      }
      return array.map((v) => type.toJSON(v));
    },
    /**
     * Decodes a JSON-like object into this structure.
     */
    fromJSON(json) {
      if (!("fromJSON" in type)) {
        throw Error("circuitArray.fromJSON: element type has no fromJSON method");
      }
      return json.map((a2) => type.fromJSON(a2));
    },
    toInput(array) {
      if (!("toInput" in type)) {
        throw Error("circuitArray.toInput: element type has no toInput method");
      }
      return array.reduce((curr, value) => HashInput.append(curr, type.toInput(value)), HashInput.empty);
    },
    empty() {
      if (!("empty" in type)) {
        throw Error("circuitArray.empty: element type has no empty() method");
      }
      return Array.from({ length }, () => type.empty());
    }
  };
}

// dist/node/lib/group.js
var Group2 = class _Group {
  /**
   * The generator `g` of the Group.
   */
  static get generator() {
    return new _Group({ x: Pallas.one.x, y: Pallas.one.y });
  }
  /**
   * Unique representation of the `zero` element of the Group (the identity element of addition in this Group).
   *
   * **Note**: The `zero` element is represented as `(0, 0)`.
   *
   * ```typescript
   * // g + -g = 0
   * g.add(g.neg()).assertEquals(zero);
   * // g + 0 = g
   * g.add(zero).assertEquals(g);
   * ```
   */
  static get zero() {
    return new _Group({ x: 0, y: 0 });
  }
  /**
   * Coerces anything group-like to a {@link Group}.
   */
  constructor({ x, y }) {
    this.x = x instanceof Field3 ? x : new Field3(x);
    this.y = y instanceof Field3 ? y : new Field3(y);
    if (isConstant4(this)) {
      if (this.x.equals(0).and(this.y.equals(0)).toBoolean())
        return;
      const { add: add2, mul, square } = Field;
      let x_bigint = this.x.toBigInt();
      let y_bigint = this.y.toBigInt();
      let onCurve = add2(mul(x_bigint, mul(x_bigint, x_bigint)), Pallas.b) === square(y_bigint);
      if (!onCurve) {
        throw Error(`(x: ${x_bigint}, y: ${y_bigint}) is not a valid group element`);
      }
    }
  }
  /**
   * Checks if this element is the `zero` element `{x: 0, y: 0}`.
   */
  isZero() {
    return this.x.equals(0);
  }
  /**
   * Adds this {@link Group} element to another {@link Group} element.
   *
   * ```ts
   * let g1 = Group({ x: -1, y: 2})
   * let g2 = g1.add(g1)
   * ```
   */
  add(g) {
    if (isConstant4(this) && isConstant4(g)) {
      if (this.isZero().toBoolean()) {
        return g;
      } else if (g.isZero().toBoolean()) {
        return this;
      } else {
        let g_proj = Pallas.add(toProjective(this), toProjective(g));
        return fromProjective(g_proj);
      }
    } else {
      const { x: x1, y: y1 } = this;
      const { x: x2, y: y2 } = g;
      let zero2 = new Field3(0);
      let same_x = Provable.witness(Field3, () => x1.equals(x2).toField());
      let inf = Provable.witness(Bool3, () => x1.equals(x2).and(y1.equals(y2).not()));
      let inf_z = Provable.witness(Field3, () => {
        if (y1.equals(y2).toBoolean())
          return zero2;
        else if (x1.equals(x2).toBoolean())
          return y2.sub(y1).inv();
        else
          return zero2;
      });
      let x21_inv = Provable.witness(Field3, () => {
        if (x1.equals(x2).toBoolean())
          return zero2;
        else
          return x2.sub(x1).inv();
      });
      let s = Provable.witness(Field3, () => {
        if (x1.equals(x2).toBoolean()) {
          let x1_squared = x1.square();
          return x1_squared.add(x1_squared).add(x1_squared).div(y1.add(y1));
        } else
          return y2.sub(y1).div(x2.sub(x1));
      });
      let x3 = Provable.witness(Field3, () => {
        return s.square().sub(x1.add(x2));
      });
      let y3 = Provable.witness(Field3, () => {
        return s.mul(x1.sub(x3)).sub(y1);
      });
      let [, x, y] = Snarky.gates.ecAdd(toTuple(_Group.from(x1.seal(), y1.seal())), toTuple(_Group.from(x2.seal(), y2.seal())), toTuple(_Group.from(x3, y3)), inf.toField().value, same_x.value, s.value, inf_z.value, x21_inv.value);
      let gIsZero = g.isZero();
      let onlyThisIsZero = this.isZero().and(gIsZero.not());
      let isNegation = inf;
      let isNormalAddition = gIsZero.or(onlyThisIsZero).or(isNegation).not();
      return Provable.switch([gIsZero, onlyThisIsZero, isNegation, isNormalAddition], _Group, [this, g, _Group.zero, new _Group({ x, y })]);
    }
  }
  /**
   * Subtracts another {@link Group} element from this one.
   */
  sub(g) {
    return this.add(g.neg());
  }
  /**
   * Negates this {@link Group}. Under the hood, it simply negates the `y` coordinate and leaves the `x` coordinate as is.
   */
  neg() {
    let { x, y } = this;
    return new _Group({ x, y: y.neg() });
  }
  /**
   * Elliptic curve scalar multiplication. Scales the {@link Group} element `n`-times by itself, where `n` is the {@link Scalar}.
   *
   * ```typescript
   * let s = Scalar(5);
   * let 5g = g.scale(s);
   * ```
   */
  scale(s) {
    let scalar = Scalar3.from(s);
    if (isConstant4(this) && scalar.isConstant()) {
      let g_proj = Pallas.scale(toProjective(this), scalar.toBigInt());
      return fromProjective(g_proj);
    } else {
      let [, ...bits2] = scalar.value;
      bits2.reverse();
      let [, x, y] = Snarky.group.scale(toTuple(this), [0, ...bits2]);
      return new _Group({ x, y });
    }
  }
  /**
   * Assert that this {@link Group} element equals another {@link Group} element.
   * Throws an error if the assertion fails.
   *
   * ```ts
   * g1.assertEquals(g2);
   * ```
   */
  assertEquals(g, message) {
    let { x: x1, y: y1 } = this;
    let { x: x2, y: y2 } = g;
    x1.assertEquals(x2, message);
    y1.assertEquals(y2, message);
  }
  /**
   * Check if this {@link Group} element equals another {@link Group} element.
   * Returns a {@link Bool}.
   *
   * ```ts
   * g1.equals(g1); // Bool(true)
   * ```
   */
  equals(g) {
    let { x: x1, y: y1 } = this;
    let { x: x2, y: y2 } = g;
    return x1.equals(x2).and(y1.equals(y2));
  }
  /**
   * Serializes this {@link Group} element to a JSON object.
   *
   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.
   */
  toJSON() {
    return {
      x: this.x.toString(),
      y: this.y.toString()
    };
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns an array containing this {@link Group} element as an array of {@link Field} elements.
   */
  toFields() {
    return [this.x, this.y];
  }
  /**
   * Coerces two x and y coordinates into a {@link Group} element.
   */
  static from(x, y) {
    return new _Group({ x, y });
  }
  /**
   * @deprecated Please use the method `.add` on the instance instead
   *
   * Adds a {@link Group} element to another one.
   */
  static add(g1, g2) {
    return g1.add(g2);
  }
  /**
   * @deprecated Please use the method `.sub` on the instance instead
   *
   * Subtracts a {@link Group} element from another one.
   */
  static sub(g1, g2) {
    return g1.sub(g2);
  }
  /**
   * @deprecated Please use the method `.neg` on the instance instead
   *
   * Negates a {@link Group} element. Under the hood, it simply negates the `y` coordinate and leaves the `x` coordinate as is.
   *
   * ```typescript
   * let gNeg = Group.neg(g);
   * ```
   */
  static neg(g) {
    return g.neg();
  }
  /**
   * @deprecated Please use the method `.scale` on the instance instead
   *
   * Elliptic curve scalar multiplication. Scales a {@link Group} element `n`-times by itself, where `n` is the {@link Scalar}.
   *
   * ```typescript
   * let s = Scalar(5);
   * let 5g = Group.scale(g, s);
   * ```
   */
  static scale(g, s) {
    return g.scale(s);
  }
  /**
   * @deprecated Please use the method `.assertEqual` on the instance instead.
   *
   * Assert that two {@link Group} elements are equal to another.
   * Throws an error if the assertion fails.
   *
   * ```ts
   * Group.assertEquals(g1, g2);
   * ```
   */
  static assertEqual(g1, g2) {
    g1.assertEquals(g2);
  }
  /**
   * @deprecated Please use the method `.equals` on the instance instead.
   *
   * Checks if a {@link Group} element is equal to another {@link Group} element.
   * Returns a {@link Bool}.
   *
   * ```ts
   * Group.equal(g1, g2); // Bool(true)
   * ```
   */
  static equal(g1, g2) {
    return g1.equals(g2);
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns an array containing a {@link Group} element as an array of {@link Field} elements.
   */
  static toFields(g) {
    return g.toFields();
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns an empty array.
   */
  static toAuxiliary(g) {
    return [];
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Deserializes a {@link Group} element from a list of field elements.
   */
  static fromFields([x, y]) {
    return new _Group({ x, y });
  }
  /**
   * Part of the {@link Provable} interface.
   *
   * Returns 2.
   */
  static sizeInFields() {
    return 2;
  }
  /**
   * Serializes a {@link Group} element to a JSON object.
   *
   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.
   */
  static toJSON(g) {
    return g.toJSON();
  }
  /**
   * Deserializes a JSON-like structure to a {@link Group} element.
   *
   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.
   */
  static fromJSON({ x, y }) {
    return new _Group({ x, y });
  }
  /**
   * Checks that a {@link Group} element is constraint properly by checking that the element is on the curve.
   */
  static check(g) {
    try {
      const { x, y } = g;
      let x2 = x.square();
      let x3 = x2.mul(x);
      let ax = x.mul(Pallas.a);
      let isZero = x.equals(0).and(y.equals(0));
      isZero.or(x3.add(ax).add(Pallas.b).equals(y.square())).assertTrue();
    } catch (error) {
      if (!(error instanceof Error))
        return error;
      throw `${`Element (x: ${g.x}, y: ${g.y}) is not an element of the group.`}
${error.message}`;
    }
  }
};
function isConstant4(g) {
  return g.x.isConstant() && g.y.isConstant();
}
function toTuple(g) {
  return [0, g.x.value, g.y.value];
}
function toProjective(g) {
  return Pallas.fromAffine({
    x: g.x.toBigInt(),
    y: g.y.toBigInt(),
    infinity: false
  });
}
function fromProjective({ x, y, z }) {
  return fromAffine(Pallas.toAffine({ x, y, z }));
}
function fromAffine({ x, y, infinity }) {
  return infinity ? Group2.zero : new Group2({ x, y });
}

// dist/node/lib/core.js
var Field4 = toFunctionConstructor(Field3);
var Bool4 = toFunctionConstructor(Bool3);
var Group3 = toFunctionConstructor(Group2);
function toFunctionConstructor(Class) {
  function Constructor(...args) {
    return new Class(...args);
  }
  Object.defineProperties(Constructor, Object.getOwnPropertyDescriptors(Class));
  return Constructor;
}

// dist/node/lib/util/types.js
var Tuple = {
  map(tuple2, f) {
    return tuple2.map(f);
  }
};
var TupleN = {
  map(tuple2, f) {
    return tuple2.map(f);
  },
  fromArray(n, arr) {
    assert2(arr.length === n, `Expected array of length ${n}, got ${arr.length}`);
    return arr;
  },
  hasLength(n, tuple2) {
    return tuple2.length === n;
  }
};

// dist/node/lib/gadgets/foreign-field.js
var import_tslib2 = require("tslib");

// dist/node/lib/circuit_value.js
var import_reflect_metadata = require("reflect-metadata");

// dist/node/bindings/lib/generic.js
var emptyType = {
  sizeInFields: () => 0,
  toFields: () => [],
  toAuxiliary: () => [],
  fromFields: () => null,
  check: () => {
  },
  toInput: () => ({}),
  toJSON: () => null,
  fromJSON: () => null,
  empty: () => null
};
var undefinedType = {
  ...emptyType,
  fromFields: () => void 0,
  toJSON: () => null,
  fromJSON: () => void 0,
  empty: () => void 0
};
var primitiveTypes = /* @__PURE__ */ new Set(["number", "string", "null"]);
function EmptyNull() {
  return emptyType;
}
function EmptyUndefined() {
  return undefinedType;
}
function EmptyVoid() {
  return undefinedType;
}
var primitiveTypeMap = {
  number: {
    ...emptyType,
    toAuxiliary: (value = 0) => [value],
    toJSON: (value) => value,
    fromJSON: (value) => value,
    fromFields: (_, [value]) => value,
    empty: () => 0
  },
  string: {
    ...emptyType,
    toAuxiliary: (value = "") => [value],
    toJSON: (value) => value,
    fromJSON: (value) => value,
    fromFields: (_, [value]) => value,
    empty: () => ""
  },
  null: emptyType
};

// dist/node/lib/hash.js
var import_tslib = require("tslib");

// dist/node/lib/hash-generic.js
function createHashHelpers(Field5, Hash2) {
  function salt2(prefix) {
    return Hash2.update(Hash2.initialState(), [prefixToField(Field5, prefix)]);
  }
  function emptyHashWithPrefix2(prefix) {
    return salt2(prefix)[0];
  }
  function hashWithPrefix3(prefix, input) {
    let init = salt2(prefix);
    return Hash2.update(init, input)[0];
  }
  return { salt: salt2, emptyHashWithPrefix: emptyHashWithPrefix2, hashWithPrefix: hashWithPrefix3 };
}

// dist/node/lib/ml/fields.js
var MlFieldArray = {
  to(arr) {
    return MlArray.to(arr.map((x) => x.value));
  },
  from([, ...arr]) {
    return arr.map((x) => new Field3(x));
  }
};
var MlFieldConstArray = {
  to(arr) {
    return MlArray.to(arr.map((x) => x.toConstant().value[1]));
  },
  from([, ...arr]) {
    return arr.map((x) => new Field3(x));
  }
};

// dist/node/bindings/crypto/poseidon.js
function fieldToGroup(x) {
  const { potentialXs, tryDecode } = GroupMapPallas;
  const xs = potentialXs(x);
  return xs.map((x2) => tryDecode(x2)).find((x2) => x2);
}
function makeHashToGroup(hash3) {
  return (input) => {
    let digest = hash3(input);
    let g = fieldToGroup(digest);
    if (g === void 0)
      return void 0;
    let isEven = g.y % 2n === 0n;
    let gy_neg = Fp.negate(g.y);
    return {
      x: g.x,
      y: {
        x0: isEven ? g.y : gy_neg,
        x1: isEven ? gy_neg : g.y
      }
    };
  };
}
var PoseidonSpec = createPoseidon(Fp, poseidonParamsKimchiFp);
var Poseidon = {
  ...PoseidonSpec,
  hashToGroup: makeHashToGroup(PoseidonSpec.hash)
};
var PoseidonLegacy = createPoseidon(Fp, poseidonParamsLegacyFp);
function createPoseidon(Fp2, { fullRounds, partialRounds, hasInitialRoundConstant, stateSize, rate, power: power_, roundConstants: roundConstants_, mds: mds_ }) {
  if (partialRounds !== 0) {
    throw Error("we don't support partial rounds");
  }
  assertPositiveInteger(rate, "rate must be a positive integer");
  assertPositiveInteger(fullRounds, "fullRounds must be a positive integer");
  assertPositiveInteger(power_, "power must be a positive integer");
  let power2 = BigInt(power_);
  let roundConstants = roundConstants_.map((arr) => arr.map(BigInt));
  let mds = mds_.map((arr) => arr.map(BigInt));
  function initialState() {
    return Array(stateSize).fill(0n);
  }
  function hash3(input) {
    let state3 = update(initialState(), input);
    return state3[0];
  }
  function update([...state3], input) {
    if (input.length === 0) {
      permutation2(state3);
      return state3;
    }
    let n = Math.ceil(input.length / rate) * rate;
    input = input.concat(Array(n - input.length).fill(0n));
    for (let blockIndex = 0; blockIndex < n; blockIndex += rate) {
      for (let i2 = 0; i2 < rate; i2++) {
        state3[i2] = Fp2.add(state3[i2], input[blockIndex + i2]);
      }
      permutation2(state3);
    }
    return state3;
  }
  function permutation2(state3) {
    let offset = 0;
    if (hasInitialRoundConstant) {
      for (let i2 = 0; i2 < stateSize; i2++) {
        state3[i2] = Fp2.add(state3[i2], roundConstants[0][i2]);
      }
      offset = 1;
    }
    for (let round2 = 0; round2 < fullRounds; round2++) {
      for (let i2 = 0; i2 < stateSize; i2++) {
        state3[i2] = Fp2.power(state3[i2], power2);
      }
      let oldState = [...state3];
      for (let i2 = 0; i2 < stateSize; i2++) {
        state3[i2] = Fp2.dot(mds[i2], oldState);
        state3[i2] = Fp2.add(state3[i2], roundConstants[round2 + offset][i2]);
      }
    }
  }
  return { initialState, update, hash: hash3 };
}

// dist/node/lib/gadgets/common.js
var MAX_BITS = 64;
function existsOne(compute) {
  let varMl = Snarky.existsVar(() => FieldConst.fromBigint(compute()));
  return VarField(varMl);
}
function exists(n, compute) {
  let varsMl = Snarky.exists(n, () => MlArray.mapTo(compute(), FieldConst.fromBigint));
  let vars = MlArray.mapFrom(varsMl, VarField);
  return TupleN.fromArray(n, vars);
}
function toVar(x) {
  if (isVar(x))
    return x;
  let xVar = existsOne(() => Field3.from(x).toBigInt());
  xVar.assertEquals(x);
  return xVar;
}
function isVar(x) {
  return x instanceof Field3 && FieldVar.isVar(x.value);
}
function toVars(fields) {
  return Tuple.map(fields, toVar);
}
function assert3(stmt, message) {
  if (stmt instanceof Bool3) {
    stmt.assertTrue(message ?? "Assertion failed");
  } else if (!stmt) {
    throw Error(message ?? "Assertion failed");
  }
}
function bitSlice(x, start, length) {
  return x >> BigInt(start) & (1n << BigInt(length)) - 1n;
}
function divideWithRemainder(numerator, denominator) {
  const quotient = numerator / denominator;
  const remainder = numerator - denominator * quotient;
  return { quotient, remainder };
}

// dist/node/lib/gates.js
var Gates = {
  rangeCheck0,
  rangeCheck1,
  xor,
  zero,
  rotate,
  generic,
  foreignFieldAdd,
  foreignFieldMul,
  raw
};
function rangeCheck0(x, xLimbs12, xLimbs2, isCompact) {
  Snarky.gates.rangeCheck0(x.value, MlTuple2.mapTo(xLimbs12, (x2) => x2.value), MlTuple2.mapTo(xLimbs2, (x2) => x2.value), isCompact ? FieldConst[1] : FieldConst[0]);
}
function rangeCheck1(v2, v12, vCurr, vNext) {
  Snarky.gates.rangeCheck1(v2.value, v12.value, MlTuple2.mapTo(vCurr, (x) => x.value), MlTuple2.mapTo(vNext, (x) => x.value));
}
function rotate(field, rotated, excess, limbs, crumbs, two_to_rot) {
  Snarky.gates.rotate(field.value, rotated.value, excess.value, MlArray.to(limbs.map((x) => x.value)), MlArray.to(crumbs.map((x) => x.value)), FieldConst.fromBigint(two_to_rot));
}
function xor(input1, input2, outputXor, in1_0, in1_1, in1_2, in1_3, in2_0, in2_1, in2_2, in2_3, out0, out1, out2, out3) {
  Snarky.gates.xor(input1.value, input2.value, outputXor.value, in1_0.value, in1_1.value, in1_2.value, in1_3.value, in2_0.value, in2_1.value, in2_2.value, in2_3.value, out0.value, out1.value, out2.value, out3.value);
}
function generic(coefficients, inputs) {
  Snarky.gates.generic(FieldConst.fromBigint(coefficients.left), inputs.left.value, FieldConst.fromBigint(coefficients.right), inputs.right.value, FieldConst.fromBigint(coefficients.out), inputs.out.value, FieldConst.fromBigint(coefficients.mul), FieldConst.fromBigint(coefficients.const));
}
function zero(a2, b2, c) {
  raw(KimchiGateType.Zero, [a2, b2, c], []);
}
function foreignFieldAdd({ left, right, overflow, carry, modulus, sign: sign3 }) {
  Snarky.gates.foreignFieldAdd(MlTuple2.mapTo(left, (x) => x.value), MlTuple2.mapTo(right, (x) => x.value), overflow.value, carry.value, MlTuple2.mapTo(modulus, FieldConst.fromBigint), FieldConst.fromBigint(sign3));
}
function foreignFieldMul(inputs) {
  let { left, right, remainder, quotient, quotientHiBound, product1, carry0, carry1p, carry1c, foreignFieldModulus2, negForeignFieldModulus } = inputs;
  Snarky.gates.foreignFieldMul(MlTuple2.mapTo(left, (x) => x.value), MlTuple2.mapTo(right, (x) => x.value), MlTuple2.mapTo(remainder, (x) => x.value), MlTuple2.mapTo(quotient, (x) => x.value), quotientHiBound.value, MlTuple2.mapTo(product1, (x) => x.value), carry0.value, MlTuple2.mapTo(carry1p, (x) => x.value), MlTuple2.mapTo(carry1c, (x) => x.value), FieldConst.fromBigint(foreignFieldModulus2), MlTuple2.mapTo(negForeignFieldModulus, FieldConst.fromBigint));
}
function raw(kind, values, coefficients) {
  let n = values.length;
  let padding2 = exists(15 - n, () => Array(15 - n).fill(0n));
  Snarky.gates.raw(kind, MlArray.to(values.concat(padding2).map((x) => x.value)), MlArray.to(coefficients.map(FieldConst.fromBigint)));
}
var KimchiGateType;
(function(KimchiGateType2) {
  KimchiGateType2[KimchiGateType2["Zero"] = 0] = "Zero";
  KimchiGateType2[KimchiGateType2["Generic"] = 1] = "Generic";
  KimchiGateType2[KimchiGateType2["Poseidon"] = 2] = "Poseidon";
  KimchiGateType2[KimchiGateType2["CompleteAdd"] = 3] = "CompleteAdd";
  KimchiGateType2[KimchiGateType2["VarBaseMul"] = 4] = "VarBaseMul";
  KimchiGateType2[KimchiGateType2["EndoMul"] = 5] = "EndoMul";
  KimchiGateType2[KimchiGateType2["EndoMulScalar"] = 6] = "EndoMulScalar";
  KimchiGateType2[KimchiGateType2["Lookup"] = 7] = "Lookup";
  KimchiGateType2[KimchiGateType2["CairoClaim"] = 8] = "CairoClaim";
  KimchiGateType2[KimchiGateType2["CairoInstruction"] = 9] = "CairoInstruction";
  KimchiGateType2[KimchiGateType2["CairoFlags"] = 10] = "CairoFlags";
  KimchiGateType2[KimchiGateType2["CairoTransition"] = 11] = "CairoTransition";
  KimchiGateType2[KimchiGateType2["RangeCheck0"] = 12] = "RangeCheck0";
  KimchiGateType2[KimchiGateType2["RangeCheck1"] = 13] = "RangeCheck1";
  KimchiGateType2[KimchiGateType2["ForeignFieldAdd"] = 14] = "ForeignFieldAdd";
  KimchiGateType2[KimchiGateType2["ForeignFieldMul"] = 15] = "ForeignFieldMul";
  KimchiGateType2[KimchiGateType2["Xor16"] = 16] = "Xor16";
  KimchiGateType2[KimchiGateType2["Rot64"] = 17] = "Rot64";
})(KimchiGateType || (KimchiGateType = {}));

// dist/node/lib/gadgets/range-check.js
function rangeCheck32(x) {
  if (x.isConstant()) {
    if (x.toBigInt() >= 1n << 32n) {
      throw Error(`rangeCheck32: expected field to fit in 32 bits, got ${x}`);
    }
    return;
  }
  let actual = rangeCheckHelper(32, x);
  actual.assertEquals(x);
}
function rangeCheck64(x) {
  if (x.isConstant()) {
    if (x.toBigInt() >= 1n << 64n) {
      throw Error(`rangeCheck64: expected field to fit in 64 bits, got ${x}`);
    }
    return;
  }
  let [x0, x2, x4, x6, x8, x10, x12, x14] = exists(8, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 0, 2),
      bitSlice(xx, 2, 2),
      bitSlice(xx, 4, 2),
      bitSlice(xx, 6, 2),
      bitSlice(xx, 8, 2),
      bitSlice(xx, 10, 2),
      bitSlice(xx, 12, 2),
      bitSlice(xx, 14, 2)
    ];
  });
  let [x16, x28, x40, x52] = exists(4, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 16, 12),
      bitSlice(xx, 28, 12),
      bitSlice(xx, 40, 12),
      bitSlice(xx, 52, 12)
    ];
  });
  Gates.rangeCheck0(
    x,
    [new Field3(0), new Field3(0), x52, x40, x28, x16],
    [x14, x12, x10, x8, x6, x4, x2, x0],
    false
    // not using compact mode
  );
}
var l = 88n;
var l2 = 2n * l;
var l3 = 3n * l;
var lMask = (1n << l) - 1n;
var l2Mask = (1n << l2) - 1n;
function multiRangeCheck([x, y, z]) {
  if (x.isConstant() && y.isConstant() && z.isConstant()) {
    if (x.toBigInt() >> l || y.toBigInt() >> l || z.toBigInt() >> l) {
      throw Error(`Expected fields to fit in ${l} bits, got ${x}, ${y}, ${z}`);
    }
    return;
  }
  [x, y, z] = toVars([x, y, z]);
  let zero2 = toVar(0n);
  let [x64, x76] = rangeCheck0Helper(x);
  let [y64, y76] = rangeCheck0Helper(y);
  rangeCheck1Helper({ x64, x76, y64, y76, z, yz: zero2 });
}
function compactMultiRangeCheck(xy, z) {
  if (xy.isConstant() && z.isConstant()) {
    if (xy.toBigInt() >> l2 || z.toBigInt() >> l) {
      throw Error(`Expected fields to fit in ${l2} and ${l} bits respectively, got ${xy}, ${z}`);
    }
    let [x2, y2] = splitCompactLimb(xy.toBigInt());
    return [new Field3(x2), new Field3(y2), z];
  }
  [xy, z] = toVars([xy, z]);
  let [x, y] = exists(2, () => splitCompactLimb(xy.toBigInt()));
  let [z64, z76] = rangeCheck0Helper(z, false);
  let [x64, x76] = rangeCheck0Helper(x, true);
  rangeCheck1Helper({ x64: z64, x76: z76, y64: x64, y76: x76, z: y, yz: xy });
  return [x, y, z];
}
function splitCompactLimb(x01) {
  return [x01 & lMask, x01 >> l];
}
function rangeCheck0Helper(x, isCompact = false) {
  let [x0, x2, x4, x6, x8, x10, x12, x14] = exists(8, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 0, 2),
      bitSlice(xx, 2, 2),
      bitSlice(xx, 4, 2),
      bitSlice(xx, 6, 2),
      bitSlice(xx, 8, 2),
      bitSlice(xx, 10, 2),
      bitSlice(xx, 12, 2),
      bitSlice(xx, 14, 2)
    ];
  });
  let [x16, x28, x40, x52, x64, x76] = exists(6, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 16, 12),
      bitSlice(xx, 28, 12),
      bitSlice(xx, 40, 12),
      bitSlice(xx, 52, 12),
      bitSlice(xx, 64, 12),
      bitSlice(xx, 76, 12)
    ];
  });
  Gates.rangeCheck0(x, [x76, x64, x52, x40, x28, x16], [x14, x12, x10, x8, x6, x4, x2, x0], isCompact);
  return [x64, x76];
}
function rangeCheck1Helper(inputs) {
  let { x64, x76, y64, y76, z, yz } = inputs;
  let [z22, z24, z26, z28, z30, z32, z34, z36, z38, z50, z62, z74, z86] = exists(13, () => {
    let zz = z.toBigInt();
    return [
      bitSlice(zz, 22, 2),
      bitSlice(zz, 24, 2),
      bitSlice(zz, 26, 2),
      bitSlice(zz, 28, 2),
      bitSlice(zz, 30, 2),
      bitSlice(zz, 32, 2),
      bitSlice(zz, 34, 2),
      bitSlice(zz, 36, 2),
      bitSlice(zz, 38, 12),
      bitSlice(zz, 50, 12),
      bitSlice(zz, 62, 12),
      bitSlice(zz, 74, 12),
      bitSlice(zz, 86, 2)
    ];
  });
  let [z0, z2, z4, z6, z8, z10, z12, z14, z16, z18, z20] = exists(11, () => {
    let zz = z.toBigInt();
    return [
      bitSlice(zz, 0, 2),
      bitSlice(zz, 2, 2),
      bitSlice(zz, 4, 2),
      bitSlice(zz, 6, 2),
      bitSlice(zz, 8, 2),
      bitSlice(zz, 10, 2),
      bitSlice(zz, 12, 2),
      bitSlice(zz, 14, 2),
      bitSlice(zz, 16, 2),
      bitSlice(zz, 18, 2),
      bitSlice(zz, 20, 2)
    ];
  });
  Gates.rangeCheck1(z, yz, [z86, z74, z62, z50, z38, z36, z34, z32, z30, z28, z26, z24, z22], [z20, z18, z16, x76, x64, y76, y64, z14, z12, z10, z8, z6, z4, z2, z0]);
}
function rangeCheckHelper(length, x) {
  assert3(length <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${length}`);
  assert3(length > 0, `bit length must be positive, got ${length}`);
  assert3(length % 16 === 0, "`length` has to be a multiple of 16.");
  let lengthDiv16 = length / 16;
  if (x.isConstant()) {
    let bits2 = Field.toBits(x.toBigInt()).slice(0, length).concat(Array(Fp.sizeInBits - length).fill(false));
    return new Field3(Field.fromBits(bits2));
  }
  let y = Snarky.field.truncateToBits16(lengthDiv16, x.value);
  return new Field3(y);
}
function rangeCheckN(n, x, message = "") {
  assert3(n <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${n}`);
  assert3(n > 0, `bit length must be positive, got ${n}`);
  assert3(n % 16 === 0, "`length` has to be a multiple of 16.");
  if (x.isConstant()) {
    if (x.toBigInt() >= 1n << BigInt(n)) {
      throw Error(`rangeCheckN: expected field to fit in ${n} bits, got ${x}.
${message}`);
    }
    return;
  }
  let actual = rangeCheckHelper(n, x);
  actual.assertEquals(x, message);
}
function isInRangeN(n, x) {
  assert3(n <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${n}`);
  assert3(n > 0, `bit length must be positive, got ${n}`);
  assert3(n % 16 === 0, "`length` has to be a multiple of 16.");
  if (x.isConstant()) {
    return new Bool3(x.toBigInt() < 1n << BigInt(n));
  }
  let actual = rangeCheckHelper(n, x);
  return actual.equals(x);
}
function rangeCheck16(x) {
  if (x.isConstant()) {
    assert3(x.toBigInt() < 1n << 16n, `rangeCheck16: expected field to fit in 8 bits, got ${x}`);
    return;
  }
  x.rangeCheckHelper(16).assertEquals(x);
}
function rangeCheck8(x) {
  if (x.isConstant()) {
    assert3(x.toBigInt() < 1n << 8n, `rangeCheck8: expected field to fit in 8 bits, got ${x}`);
    return;
  }
  x.rangeCheckHelper(16).assertEquals(x);
  let x256 = x.mul(1 << 8).seal();
  x256.rangeCheckHelper(16).assertEquals(x256);
}

// dist/node/lib/hash.js
var _Sponge_sponge;
var Sponge = class {
  constructor() {
    _Sponge_sponge.set(this, void 0);
    let isChecked = Provable.inCheckedComputation();
    (0, import_tslib.__classPrivateFieldSet)(this, _Sponge_sponge, Snarky.poseidon.sponge.create(isChecked), "f");
  }
  absorb(x) {
    Snarky.poseidon.sponge.absorb((0, import_tslib.__classPrivateFieldGet)(this, _Sponge_sponge, "f"), x.value);
  }
  squeeze() {
    return Field4(Snarky.poseidon.sponge.squeeze((0, import_tslib.__classPrivateFieldGet)(this, _Sponge_sponge, "f")));
  }
};
_Sponge_sponge = /* @__PURE__ */ new WeakMap();
var Poseidon2 = {
  hash(input) {
    if (isConstant5(input)) {
      return Field4(Poseidon.hash(toBigints(input)));
    }
    return Poseidon2.update(Poseidon2.initialState(), input)[0];
  },
  update(state3, input) {
    if (isConstant5(state3) && isConstant5(input)) {
      let newState2 = Poseidon.update(toBigints(state3), toBigints(input));
      return TupleN.fromArray(3, newState2.map(Field4));
    }
    let newState = Snarky.poseidon.update(MlFieldArray.to(state3), MlFieldArray.to(input));
    return MlFieldArray.from(newState);
  },
  hashToGroup(input) {
    if (isConstant5(input)) {
      let result = Poseidon.hashToGroup(toBigints(input));
      assert2(result !== void 0, "hashToGroup works on all inputs");
      let { x: x2, y: y2 } = result;
      return {
        x: Field4(x2),
        y: { x0: Field4(y2.x0), x1: Field4(y2.x1) }
      };
    }
    let [, xv, yv] = Snarky.poseidon.hashToGroup(MlFieldArray.to(input));
    let x = Field4(xv);
    let y = Field4(yv);
    let x0 = Provable.witness(Field4, () => {
      let isEven = y.toBigInt() % 2n === 0n;
      return isEven ? y : y.mul(-1);
    });
    let x1 = x0.mul(-1);
    y.equals(x0).or(y.equals(x1)).assertTrue();
    return { x, y: { x0, x1 } };
  },
  initialState() {
    return [Field4(0), Field4(0), Field4(0)];
  },
  Sponge
};
function hashConstant(input) {
  return Field4(Poseidon.hash(toBigints(input)));
}
var HashHelpers = createHashHelpers(Field4, Poseidon2);
var { salt, emptyHashWithPrefix, hashWithPrefix } = HashHelpers;
function prefixToField2(prefix) {
  if (prefix.length * 8 >= 255)
    throw Error("prefix too long");
  let bits2 = [...prefix].map((char) => {
    let bits3 = [];
    for (let j = 0, c = char.charCodeAt(0); j < 8; j++, c >>= 1) {
      bits3.push(!!(c & 1));
    }
    return bits3;
  }).flat();
  return Field4.fromBits(bits2);
}
function packToFields({ fields = [], packed = [] }) {
  if (packed.length === 0)
    return fields;
  let packedBits = [];
  let currentPackedField = Field4(0);
  let currentSize = 0;
  for (let [field, size] of packed) {
    currentSize += size;
    if (currentSize < 255) {
      currentPackedField = currentPackedField.mul(Field4(1n << BigInt(size))).add(field);
    } else {
      packedBits.push(currentPackedField);
      currentSize = size;
      currentPackedField = field;
    }
  }
  packedBits.push(currentPackedField);
  return fields.concat(packedBits);
}
var TokenSymbolPure = {
  toFields({ field }) {
    return [field];
  },
  toAuxiliary(value) {
    return [value?.symbol ?? ""];
  },
  fromFields([field], [symbol]) {
    return { symbol, field };
  },
  sizeInFields() {
    return 1;
  },
  check({ field }) {
    rangeCheckN(48, field);
  },
  toJSON({ symbol }) {
    return symbol;
  },
  fromJSON(symbol) {
    let field = prefixToField2(symbol);
    return { symbol, field };
  },
  toInput({ field }) {
    return { packed: [[field, 48]] };
  },
  empty() {
    return { symbol: "", field: Field4(0n) };
  }
};
var TokenSymbol = class extends Struct(TokenSymbolPure) {
  static from(symbol) {
    let bytesLength = new TextEncoder().encode(symbol).length;
    if (bytesLength > 6)
      throw Error(`Token symbol ${symbol} should be a maximum of 6 bytes, but is ${bytesLength}`);
    let field = prefixToField2(symbol);
    return { symbol, field };
  }
};
function emptyReceiptChainHash() {
  return emptyHashWithPrefix("CodaReceiptEmpty");
}
function isConstant5(fields) {
  return fields.every((x) => x.isConstant());
}
function toBigints(fields) {
  return fields.map((x) => x.toBigInt());
}

// dist/node/lib/proof-system/prover-keys.js
var KeyType;
(function(KeyType2) {
  KeyType2[KeyType2["StepProvingKey"] = 0] = "StepProvingKey";
  KeyType2[KeyType2["StepVerificationKey"] = 1] = "StepVerificationKey";
  KeyType2[KeyType2["WrapProvingKey"] = 2] = "WrapProvingKey";
  KeyType2[KeyType2["WrapVerificationKey"] = 3] = "WrapVerificationKey";
})(KeyType || (KeyType = {}));
function parseHeader(programName, methods, header) {
  let hash3 = Pickles.util.fromMlString(header[1][2][8]);
  switch (header[0]) {
    case KeyType.StepProvingKey:
    case KeyType.StepVerificationKey: {
      let kind = snarkKeyStringKind[header[0]];
      let methodIndex = header[1][3];
      let methodName = methods[methodIndex].methodName;
      let persistentId = sanitize(`${kind}-${programName}-${methodName}`);
      let uniqueId = sanitize(`${kind}-${programName}-${methodIndex}-${methodName}-${hash3}`);
      return {
        version: cacheHeaderVersion,
        uniqueId,
        kind,
        persistentId,
        programName,
        methodName,
        methodIndex,
        hash: hash3,
        dataType: snarkKeySerializationType[header[0]]
      };
    }
    case KeyType.WrapProvingKey:
    case KeyType.WrapVerificationKey: {
      let kind = snarkKeyStringKind[header[0]];
      let dataType = snarkKeySerializationType[header[0]];
      let persistentId = sanitize(`${kind}-${programName}`);
      let uniqueId = sanitize(`${kind}-${programName}-${hash3}`);
      return {
        version: cacheHeaderVersion,
        uniqueId,
        kind,
        persistentId,
        programName,
        hash: hash3,
        dataType
      };
    }
  }
}
function encodeProverKey(value) {
  let wasm2 = getWasm();
  switch (value[0]) {
    case KeyType.StepProvingKey: {
      let index = value[1][1];
      let encoded = wasm2.caml_pasta_fp_plonk_index_encode(index);
      return encoded;
    }
    case KeyType.StepVerificationKey: {
      let vkMl = value[1];
      const rustConversion2 = getRustConversion(getWasm());
      let vkWasm = rustConversion2.fp.verifierIndexToRust(vkMl);
      let string = wasm2.caml_pasta_fp_plonk_verifier_index_serialize(vkWasm);
      return new TextEncoder().encode(string);
    }
    case KeyType.WrapProvingKey: {
      let index = value[1][1];
      let encoded = wasm2.caml_pasta_fq_plonk_index_encode(index);
      return encoded;
    }
    case KeyType.WrapVerificationKey: {
      let vk = value[1];
      let string = Pickles.encodeVerificationKey(vk);
      return new TextEncoder().encode(string);
    }
    default:
      value;
      throw Error("todo");
  }
}
function decodeProverKey(header, bytes) {
  let wasm2 = getWasm();
  switch (header[0]) {
    case KeyType.StepProvingKey: {
      let srs2 = Pickles.loadSrsFp();
      let index = wasm2.caml_pasta_fp_plonk_index_decode(bytes, srs2);
      let cs = header[1][4];
      return [KeyType.StepProvingKey, [0, index, cs]];
    }
    case KeyType.StepVerificationKey: {
      let srs2 = Pickles.loadSrsFp();
      let string = new TextDecoder().decode(bytes);
      let vkWasm = wasm2.caml_pasta_fp_plonk_verifier_index_deserialize(srs2, string);
      const rustConversion2 = getRustConversion(getWasm());
      let vkMl = rustConversion2.fp.verifierIndexFromRust(vkWasm);
      return [KeyType.StepVerificationKey, vkMl];
    }
    case KeyType.WrapProvingKey: {
      let srs2 = Pickles.loadSrsFq();
      let index = wasm2.caml_pasta_fq_plonk_index_decode(bytes, srs2);
      let cs = header[1][3];
      return [KeyType.WrapProvingKey, [0, index, cs]];
    }
    case KeyType.WrapVerificationKey: {
      let string = new TextDecoder().decode(bytes);
      let vk = Pickles.decodeVerificationKey(string);
      return [KeyType.WrapVerificationKey, vk];
    }
    default:
      header;
      throw Error("todo");
  }
}
function sanitize(string) {
  return string.toLowerCase().replace(/[^a-z0-9_-]/g, "_");
}
var snarkKeyStringKind = {
  [KeyType.StepProvingKey]: "step-pk",
  [KeyType.StepVerificationKey]: "step-vk",
  [KeyType.WrapProvingKey]: "wrap-pk",
  [KeyType.WrapVerificationKey]: "wrap-vk"
};
var snarkKeySerializationType = {
  [KeyType.StepProvingKey]: "bytes",
  [KeyType.StepVerificationKey]: "string",
  [KeyType.WrapProvingKey]: "bytes",
  [KeyType.WrapVerificationKey]: "string"
};

// dist/node/lib/proof_system.js
var Undefined = EmptyUndefined();
var Empty = Undefined;
var Void = EmptyVoid();
var Proof = class {
  verify() {
    this.shouldVerify = Bool4(true);
  }
  verifyIf(condition) {
    this.shouldVerify = condition;
  }
  toJSON() {
    let type = getStatementType(this.constructor);
    return {
      publicInput: type.input.toFields(this.publicInput).map(String),
      publicOutput: type.output.toFields(this.publicOutput).map(String),
      maxProofsVerified: this.maxProofsVerified,
      proof: Pickles.proofToBase64([this.maxProofsVerified, this.proof])
    };
  }
  static fromJSON({ maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson }) {
    let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);
    let type = getStatementType(this);
    let publicInput = type.input.fromFields(publicInputJson.map(Field4));
    let publicOutput = type.output.fromFields(publicOutputJson.map(Field4));
    return new this({
      publicInput,
      publicOutput,
      proof,
      maxProofsVerified
    });
  }
  constructor({ proof, publicInput, publicOutput, maxProofsVerified }) {
    this.shouldVerify = Bool4(false);
    this.publicInput = publicInput;
    this.publicOutput = publicOutput;
    this.proof = proof;
    this.maxProofsVerified = maxProofsVerified;
  }
  /**
   * Dummy proof. This can be useful for ZkPrograms that handle the base case in the same
   * method as the inductive case, using a pattern like this:
   *
   * ```ts
   * method(proof: SelfProof<I, O>, isRecursive: Bool) {
   *   proof.verifyIf(isRecursive);
   *   // ...
   * }
   * ```
   *
   * To use such a method in the base case, you need a dummy proof:
   *
   * ```ts
   * let dummy = await MyProof.dummy(publicInput, publicOutput, 1);
   * await myProgram.myMethod(dummy, Bool(false));
   * ```
   *
   * **Note**: The types of `publicInput` and `publicOutput`, as well as the `maxProofsVerified` parameter,
   * must match your ZkProgram. `maxProofsVerified` is the maximum number of proofs that any of your methods take as arguments.
   */
  static async dummy(publicInput, publicOutput, maxProofsVerified, domainLog2 = 14) {
    let dummyRaw = await dummyProof(maxProofsVerified, domainLog2);
    return new this({
      publicInput,
      publicOutput,
      proof: dummyRaw,
      maxProofsVerified
    });
  }
};
Proof.publicInputType = void 0;
Proof.publicOutputType = void 0;
Proof.tag = () => {
  throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput, PublicOutput> { ... }`);
};
async function verify(proof, verificationKey) {
  let picklesProof;
  let statement;
  if (typeof proof.proof === "string") {
    [, picklesProof] = Pickles.proofOfBase64(proof.proof, proof.maxProofsVerified);
    let input = MlFieldConstArray.to(proof.publicInput.map(Field4));
    let output = MlFieldConstArray.to(proof.publicOutput.map(Field4));
    statement = MlPair(input, output);
  } else {
    picklesProof = proof.proof;
    let type = getStatementType(proof.constructor);
    let input = toFieldConsts(type.input, proof.publicInput);
    let output = toFieldConsts(type.output, proof.publicOutput);
    statement = MlPair(input, output);
  }
  let vk = typeof verificationKey === "string" ? verificationKey : verificationKey.data;
  return prettifyStacktracePromise(withThreadPool(() => Pickles.verify(statement, picklesProof, vk)));
}
var compiledTags = /* @__PURE__ */ new WeakMap();
var CompiledTag = {
  get(tag) {
    return compiledTags.get(tag);
  },
  store(tag, compiledTag) {
    compiledTags.set(tag, compiledTag);
  }
};
function ZkProgram(config) {
  let methods = config.methods;
  let publicInputType = config.publicInput ?? Undefined;
  let publicOutputType = config.publicOutput ?? Void;
  let selfTag = { name: config.name };
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = publicInputType;
  SelfProof2.publicOutputType = publicOutputType;
  SelfProof2.tag = () => selfTag;
  let methodKeys = Object.keys(methods).sort();
  let methodIntfs = methodKeys.map((key) => sortMethodArguments("program", key, methods[key].privateInputs, SelfProof2));
  let methodFunctions = methodKeys.map((key) => methods[key].method);
  let maxProofsVerified = getMaxProofsVerified(methodIntfs);
  function analyzeMethods() {
    return Object.fromEntries(methodIntfs.map((methodEntry, i2) => [
      methodEntry.methodName,
      analyzeMethod(publicInputType, methodEntry, methodFunctions[i2])
    ]));
  }
  let compileOutput;
  async function compile({ cache: cache2 = Cache.FileSystemDefault, forceRecompile = false } = {}) {
    let methodsMeta = methodIntfs.map((methodEntry, i2) => analyzeMethod(publicInputType, methodEntry, methodFunctions[i2]));
    let gates = methodsMeta.map((m) => m.gates);
    let { provers: provers2, verify: verify4, verificationKey } = await compileProgram({
      publicInputType,
      publicOutputType,
      methodIntfs,
      methods: methodFunctions,
      gates,
      proofSystemTag: selfTag,
      cache: cache2,
      forceRecompile,
      overrideWrapDomain: config.overrideWrapDomain
    });
    compileOutput = { provers: provers2, verify: verify4 };
    return { verificationKey };
  }
  function toProver(key, i2) {
    async function prove_(publicInput, ...args) {
      let picklesProver = compileOutput?.provers?.[i2];
      if (picklesProver === void 0) {
        throw Error(`Cannot prove execution of program.${key}(), no prover found. Try calling \`await program.compile()\` first, this will cache provers in the background.`);
      }
      let publicInputFields = toFieldConsts(publicInputType, publicInput);
      let previousProofs = MlArray.to(getPreviousProofsForProver(args, methodIntfs[i2]));
      let id = snarkContext.enter({ witnesses: args, inProver: true });
      let result;
      try {
        result = await picklesProver(publicInputFields, previousProofs);
      } finally {
        snarkContext.leave(id);
      }
      let [publicOutputFields, proof] = MlPair.from(result);
      let publicOutput = fromFieldConsts(publicOutputType, publicOutputFields);
      class ProgramProof extends Proof {
      }
      ProgramProof.publicInputType = publicInputType;
      ProgramProof.publicOutputType = publicOutputType;
      ProgramProof.tag = () => selfTag;
      return new ProgramProof({
        publicInput,
        publicOutput,
        proof,
        maxProofsVerified
      });
    }
    let prove;
    if (publicInputType === Undefined || publicInputType === Void) {
      prove = (...args) => prove_(void 0, ...args);
    } else {
      prove = prove_;
    }
    return [key, prove];
  }
  let provers = Object.fromEntries(methodKeys.map(toProver));
  function verify3(proof) {
    if (compileOutput?.verify === void 0) {
      throw Error(`Cannot verify proof, verification key not found. Try calling \`await program.compile()\` first.`);
    }
    let statement = MlPair(toFieldConsts(publicInputType, proof.publicInput), toFieldConsts(publicOutputType, proof.publicOutput));
    return compileOutput.verify(statement, proof.proof);
  }
  function digest() {
    let methodData = methodIntfs.map((methodEntry, i2) => analyzeMethod(publicInputType, methodEntry, methodFunctions[i2]));
    let hash3 = hashConstant(Object.values(methodData).map((d) => Field4(BigInt("0x" + d.digest))));
    return hash3.toBigInt().toString(16);
  }
  return Object.assign(selfTag, {
    compile,
    verify: verify3,
    digest,
    analyzeMethods,
    publicInputType,
    publicOutputType,
    privateInputTypes: Object.fromEntries(methodKeys.map((key) => [key, methods[key].privateInputs])),
    rawMethods: Object.fromEntries(methodKeys.map((key) => [key, methods[key].method]))
  }, provers);
}
var i = 0;
var SelfProof = class extends Proof {
};
var VerificationKey = class extends Struct({
  ...provable({ data: String, hash: Field4 }),
  toJSON({ data }) {
    return data;
  }
}) {
};
function sortMethodArguments(programName, methodName, privateInputs, selfProof) {
  let witnessArgs = [];
  let proofArgs = [];
  let allArgs = [];
  let genericArgs = [];
  for (let i2 = 0; i2 < privateInputs.length; i2++) {
    let privateInput = privateInputs[i2];
    if (isProof(privateInput)) {
      if (privateInput === Proof) {
        throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput, PublicOutput> { ... }`);
      }
      allArgs.push({ type: "proof", index: proofArgs.length });
      if (privateInput === SelfProof) {
        proofArgs.push(selfProof);
      } else {
        proofArgs.push(privateInput);
      }
    } else if (isAsFields(privateInput)) {
      allArgs.push({ type: "witness", index: witnessArgs.length });
      witnessArgs.push(privateInput);
    } else if (isAsFields(privateInput?.provable)) {
      allArgs.push({ type: "witness", index: witnessArgs.length });
      witnessArgs.push(privateInput.provable);
    } else if (isGeneric(privateInput)) {
      allArgs.push({ type: "generic", index: genericArgs.length });
      genericArgs.push(privateInput);
    } else {
      throw Error(`Argument ${i2 + 1} of method ${methodName} is not a provable type: ${privateInput}`);
    }
  }
  if (proofArgs.length > 2) {
    throw Error(`${programName}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  return {
    methodName,
    witnessArgs,
    proofArgs,
    allArgs,
    genericArgs
  };
}
function isAsFields(type) {
  return (typeof type === "function" || typeof type === "object") && type !== null && ["toFields", "fromFields", "sizeInFields", "toAuxiliary"].every((s) => s in type);
}
function isProof(type) {
  return type === Proof || typeof type === "function" && type.prototype instanceof Proof;
}
var GenericArgument = class {
  constructor(isEmpty = false) {
    this.isEmpty = isEmpty;
  }
};
var emptyGeneric = () => new GenericArgument(true);
function isGeneric(type) {
  return type === GenericArgument || typeof type === "function" && type.prototype instanceof GenericArgument;
}
function getPreviousProofsForProver(methodArgs, { allArgs }) {
  let previousProofs = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = allArgs[i2];
    if (arg.type === "proof") {
      previousProofs[arg.index] = methodArgs[i2].proof;
    }
  }
  return previousProofs;
}
var maxProofsToWrapDomain = { 0: 0, 1: 1, 2: 1 };
async function compileProgram({ publicInputType, publicOutputType, methodIntfs, methods, gates, proofSystemTag, cache: cache2, forceRecompile, overrideWrapDomain }) {
  let rules = methodIntfs.map((methodEntry, i2) => picklesRuleFromFunction(publicInputType, publicOutputType, methods[i2], proofSystemTag, methodEntry, gates[i2]));
  let maxProofs = getMaxProofsVerified(methodIntfs);
  overrideWrapDomain ??= maxProofsToWrapDomain[maxProofs];
  let picklesCache = [
    0,
    function read_(mlHeader) {
      if (forceRecompile)
        return MlResult.unitError();
      let header = parseHeader(proofSystemTag.name, methodIntfs, mlHeader);
      let result = readCache(cache2, header, (bytes) => decodeProverKey(mlHeader, bytes));
      if (result === void 0)
        return MlResult.unitError();
      return MlResult.ok(result);
    },
    function write_(mlHeader, value) {
      if (!cache2.canWrite)
        return MlResult.unitError();
      let header = parseHeader(proofSystemTag.name, methodIntfs, mlHeader);
      let didWrite = writeCache(cache2, header, encodeProverKey(value));
      if (!didWrite)
        return MlResult.unitError();
      return MlResult.ok(void 0);
    },
    MlBool(cache2.canWrite)
  ];
  let { verificationKey, provers, verify: verify3, tag } = await prettifyStacktracePromise(withThreadPool(async () => {
    let result;
    let id = snarkContext.enter({ inCompile: true });
    setSrsCache(cache2);
    try {
      result = Pickles.compile(MlArray.to(rules), {
        publicInputSize: publicInputType.sizeInFields(),
        publicOutputSize: publicOutputType.sizeInFields(),
        storable: picklesCache,
        overrideWrapDomain
      });
    } finally {
      snarkContext.leave(id);
      unsetSrsCache();
    }
    let { getVerificationKey, provers: provers2, verify: verify4, tag: tag2 } = result;
    CompiledTag.store(proofSystemTag, tag2);
    let [, data, hash3] = getVerificationKey();
    let verificationKey2 = { data, hash: Field4(hash3) };
    return { verificationKey: verificationKey2, provers: MlArray.from(provers2), verify: verify4, tag: tag2 };
  }));
  let wrappedProvers = provers.map((prover) => async function picklesProver(publicInput, previousProofs) {
    return prettifyStacktracePromise(withThreadPool(() => prover(publicInput, previousProofs)));
  });
  let wrappedVerify = async function picklesVerify(statement, proof) {
    return prettifyStacktracePromise(withThreadPool(() => verify3(statement, proof)));
  };
  return {
    verificationKey,
    provers: wrappedProvers,
    verify: wrappedVerify,
    tag
  };
}
function analyzeMethod(publicInputType, methodIntf, method2) {
  return Provable.constraintSystem(() => {
    let args = synthesizeMethodArguments(methodIntf, true);
    let publicInput = emptyWitness(publicInputType);
    if (publicInputType === Undefined || publicInputType === Void)
      return method2(...args);
    return method2(publicInput, ...args);
  });
}
function picklesRuleFromFunction(publicInputType, publicOutputType, func, proofSystemTag, { methodName, witnessArgs, proofArgs, allArgs }, gates) {
  function main(publicInput) {
    let { witnesses: argsWithoutPublicInput, inProver: inProver2 } = snarkContext.get();
    assert2(!(inProver2 && argsWithoutPublicInput === void 0));
    let finalArgs = [];
    let proofs = [];
    let previousStatements = [];
    for (let i2 = 0; i2 < allArgs.length; i2++) {
      let arg = allArgs[i2];
      if (arg.type === "witness") {
        let type = witnessArgs[arg.index];
        finalArgs[i2] = Provable.witness(type, () => {
          return argsWithoutPublicInput?.[i2] ?? emptyValue(type);
        });
      } else if (arg.type === "proof") {
        let Proof3 = proofArgs[arg.index];
        let type = getStatementType(Proof3);
        let proof_ = argsWithoutPublicInput?.[i2] ?? {
          proof: void 0,
          publicInput: emptyValue(type.input),
          publicOutput: emptyValue(type.output)
        };
        let { proof, publicInput: publicInput2, publicOutput: publicOutput2 } = proof_;
        publicInput2 = Provable.witness(type.input, () => publicInput2);
        publicOutput2 = Provable.witness(type.output, () => publicOutput2);
        let proofInstance = new Proof3({ publicInput: publicInput2, publicOutput: publicOutput2, proof });
        finalArgs[i2] = proofInstance;
        proofs.push(proofInstance);
        let input = toFieldVars(type.input, publicInput2);
        let output = toFieldVars(type.output, publicOutput2);
        previousStatements.push(MlPair(input, output));
      } else if (arg.type === "generic") {
        finalArgs[i2] = argsWithoutPublicInput?.[i2] ?? emptyGeneric();
      }
    }
    let result;
    if (publicInputType === Undefined || publicInputType === Void) {
      result = func(...finalArgs);
    } else {
      let input = fromFieldVars(publicInputType, publicInput);
      result = func(input, ...finalArgs);
    }
    let hasPublicOutput = publicOutputType.sizeInFields() !== 0;
    let publicOutput = hasPublicOutput ? publicOutputType.toFields(result) : [];
    return {
      publicOutput: MlFieldArray.to(publicOutput),
      previousStatements: MlArray.to(previousStatements),
      shouldVerify: MlArray.to(proofs.map((proof) => proof.shouldVerify.toField().value))
    };
  }
  if (proofArgs.length > 2) {
    throw Error(`${proofSystemTag.name}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  let proofsToVerify = proofArgs.map((Proof3) => {
    let tag = Proof3.tag();
    if (tag === proofSystemTag)
      return { isSelf: true };
    else {
      let compiledTag = CompiledTag.get(tag);
      if (compiledTag === void 0) {
        throw Error(`${proofSystemTag.name}.compile() depends on ${tag.name}, but we cannot find compilation output for ${tag.name}.
Try to run ${tag.name}.compile() first.`);
      }
      return { isSelf: false, tag: compiledTag };
    }
  });
  let featureFlags = computeFeatureFlags(gates);
  return {
    identifier: methodName,
    main,
    featureFlags,
    proofsToVerify: MlArray.to(proofsToVerify)
  };
}
function synthesizeMethodArguments({ allArgs, proofArgs, witnessArgs }, asVariables = false) {
  let args = [];
  let empty4 = asVariables ? emptyWitness : emptyValue;
  for (let arg of allArgs) {
    if (arg.type === "witness") {
      args.push(empty4(witnessArgs[arg.index]));
    } else if (arg.type === "proof") {
      let Proof3 = proofArgs[arg.index];
      let type = getStatementType(Proof3);
      let publicInput = empty4(type.input);
      let publicOutput = empty4(type.output);
      args.push(new Proof3({ publicInput, publicOutput, proof: void 0 }));
    } else if (arg.type === "generic") {
      args.push(emptyGeneric());
    }
  }
  return args;
}
function methodArgumentsToConstant({ allArgs, proofArgs, witnessArgs }, args) {
  let constArgs = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = args[i2];
    let { type, index } = allArgs[i2];
    if (type === "witness") {
      constArgs.push(toConstant2(witnessArgs[index], arg));
    } else if (type === "proof") {
      let Proof3 = proofArgs[index];
      let type2 = getStatementType(Proof3);
      let publicInput = toConstant2(type2.input, arg.publicInput);
      let publicOutput = toConstant2(type2.output, arg.publicOutput);
      constArgs.push(new Proof3({ publicInput, publicOutput, proof: arg.proof }));
    } else if (type === "generic") {
      constArgs.push(arg);
    }
  }
  return constArgs;
}
var Generic = EmptyNull();
function methodArgumentTypesAndValues({ allArgs, proofArgs, witnessArgs }, args) {
  let typesAndValues = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = args[i2];
    let { type, index } = allArgs[i2];
    if (type === "witness") {
      typesAndValues.push({ type: witnessArgs[index], value: arg });
    } else if (type === "proof") {
      let Proof3 = proofArgs[index];
      let proof = arg;
      let types = getStatementType(Proof3);
      let type2 = provablePure({ input: types.input, output: types.output });
      let value = { input: proof.publicInput, output: proof.publicOutput };
      typesAndValues.push({ type: type2, value });
    } else if (type === "generic") {
      typesAndValues.push({ type: Generic, value: arg });
    }
  }
  return typesAndValues;
}
function emptyValue(type) {
  return type.fromFields(Array(type.sizeInFields()).fill(Field4(0)), type.toAuxiliary());
}
function emptyWitness(type) {
  return Provable.witness(type, () => emptyValue(type));
}
function getStatementType(Proof3) {
  if (Proof3.publicInputType === void 0 || Proof3.publicOutputType === void 0) {
    throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput, PublicOutput> { ... }`);
  }
  return {
    input: Proof3.publicInputType,
    output: Proof3.publicOutputType
  };
}
function getMaxProofsVerified(methodIntfs) {
  return methodIntfs.reduce((acc, { proofArgs }) => Math.max(acc, proofArgs.length), 0);
}
function fromFieldVars(type, fields) {
  return type.fromFields(MlFieldArray.from(fields));
}
function toFieldVars(type, value) {
  return MlFieldArray.to(type.toFields(value));
}
function fromFieldConsts(type, fields) {
  return type.fromFields(MlFieldConstArray.from(fields));
}
function toFieldConsts(type, value) {
  return MlFieldConstArray.to(type.toFields(value));
}
ZkProgram.Proof = function(program) {
  var _a;
  return _a = class ZkProgramProof extends Proof {
  }, _a.publicInputType = program.publicInputType, _a.publicOutputType = program.publicOutputType, _a.tag = () => program, _a;
};
ExperimentalZkProgram.Proof = ZkProgram.Proof;
function dummyProof(maxProofsVerified, domainLog2) {
  return withThreadPool(async () => Pickles.dummyProof(maxProofsVerified, domainLog2)[1]);
}
async function dummyBase64Proof() {
  let proof = await dummyProof(2, 15);
  return Pickles.proofToBase64([2, proof]);
}
var gateToFlag = {
  RangeCheck0: "rangeCheck0",
  RangeCheck1: "rangeCheck1",
  ForeignFieldAdd: "foreignFieldAdd",
  ForeignFieldMul: "foreignFieldMul",
  Xor16: "xor",
  Rot64: "rot",
  Lookup: "lookup"
};
function computeFeatureFlags(gates) {
  let flags = {
    rangeCheck0: false,
    rangeCheck1: false,
    foreignFieldAdd: false,
    foreignFieldMul: false,
    xor: false,
    rot: false,
    lookup: false,
    runtimeTables: false
  };
  for (let gate of gates) {
    let flag = gateToFlag[gate.type];
    if (flag !== void 0)
      flags[flag] = true;
  }
  return [
    0,
    MlBool(flags.rangeCheck0),
    MlBool(flags.rangeCheck1),
    MlBool(flags.foreignFieldAdd),
    MlBool(flags.foreignFieldMul),
    MlBool(flags.xor),
    MlBool(flags.rot),
    MlBool(flags.lookup),
    MlBool(flags.runtimeTables)
  ];
}
function Prover() {
  return {
    async run(witnesses, proverData, callback) {
      let id = snarkContext.enter({ witnesses, proverData, inProver: true });
      try {
        return await callback();
      } finally {
        snarkContext.leave(id);
      }
    },
    getData() {
      return snarkContext.get().proverData;
    }
  };
}
function ExperimentalZkProgram(config) {
  let config_ = { ...config, name: config.name ?? `Program${i++}` };
  return ZkProgram(config_);
}

// dist/node/lib/circuit_value.js
var CircuitValue = class {
  constructor(...props) {
    if (props.length === 0)
      return;
    let fields = this.constructor.prototype._fields;
    if (fields === void 0)
      return;
    if (props.length !== fields.length) {
      throw Error(`${this.constructor.name} constructor called with ${props.length} arguments, but expected ${fields.length}`);
    }
    for (let i2 = 0; i2 < fields.length; ++i2) {
      let [key] = fields[i2];
      this[key] = props[i2];
    }
  }
  static fromObject(value) {
    return Object.assign(Object.create(this.prototype), value);
  }
  static sizeInFields() {
    const fields = this.prototype._fields;
    return fields.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);
  }
  static toFields(v) {
    const res = [];
    const fields = this.prototype._fields;
    if (fields === void 0 || fields === null) {
      return res;
    }
    for (let i2 = 0, n = fields.length; i2 < n; ++i2) {
      const [key, propType] = fields[i2];
      const subElts = propType.toFields(v[key]);
      subElts.forEach((x) => res.push(x));
    }
    return res;
  }
  static toAuxiliary() {
    return [];
  }
  static toInput(v) {
    let input = { fields: [], packed: [] };
    let fields = this.prototype._fields;
    if (fields === void 0)
      return input;
    for (let i2 = 0, n = fields.length; i2 < n; ++i2) {
      let [key, type] = fields[i2];
      if ("toInput" in type) {
        input = HashInput.append(input, type.toInput(v[key]));
        continue;
      }
      let xs = type.toFields(v[key]);
      input.fields.push(...xs);
    }
    return input;
  }
  toFields() {
    return this.constructor.toFields(this);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
  toConstant() {
    return this.constructor.toConstant(this);
  }
  equals(x) {
    return Provable.equal(this, x);
  }
  assertEquals(x) {
    Provable.assertEqual(this, x);
  }
  isConstant() {
    return this.toFields().every((x) => x.isConstant());
  }
  static fromFields(xs) {
    const fields = this.prototype._fields;
    if (xs.length < fields.length) {
      throw Error(`${this.name}.fromFields: Expected ${fields.length} field elements, got ${xs?.length}`);
    }
    let offset = 0;
    const props = {};
    for (let i2 = 0; i2 < fields.length; ++i2) {
      const [key, propType] = fields[i2];
      const propSize = propType.sizeInFields();
      const propVal = propType.fromFields(xs.slice(offset, offset + propSize), []);
      props[key] = propVal;
      offset += propSize;
    }
    return Object.assign(Object.create(this.prototype), props);
  }
  static check(v) {
    const fields = this.prototype._fields;
    if (fields === void 0 || fields === null) {
      return;
    }
    for (let i2 = 0; i2 < fields.length; ++i2) {
      const [key, propType] = fields[i2];
      const value = v[key];
      if (propType.check === void 0)
        throw Error("bug: CircuitValue without .check()");
      propType.check(value);
    }
  }
  static toConstant(t) {
    const xs = this.toFields(t);
    return this.fromFields(xs.map((x) => x.toConstant()));
  }
  static toJSON(v) {
    const res = {};
    if (this.prototype._fields !== void 0) {
      const fields = this.prototype._fields;
      fields.forEach(([key, propType]) => {
        res[key] = propType.toJSON(v[key]);
      });
    }
    return res;
  }
  static fromJSON(value) {
    let props = {};
    let fields = this.prototype._fields;
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
    }
    if (fields !== void 0) {
      for (let i2 = 0; i2 < fields.length; ++i2) {
        let [key, propType] = fields[i2];
        if (value[key] === void 0) {
          throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
        } else {
          props[key] = propType.fromJSON(value[key]);
        }
      }
    }
    return Object.assign(Object.create(this.prototype), props);
  }
  static empty() {
    const fields = this.prototype._fields ?? [];
    let props = {};
    fields.forEach(([key, propType]) => {
      props[key] = propType.empty();
    });
    return Object.assign(Object.create(this.prototype), props);
  }
};
function prop(target, key) {
  const fieldType = Reflect.getMetadata("design:type", target, key);
  if (!target.hasOwnProperty("_fields")) {
    target._fields = [];
  }
  if (fieldType === void 0) {
  } else if (fieldType.toFields && fieldType.fromFields) {
    target._fields.push([key, fieldType]);
  } else {
    console.log(`warning: property ${key} missing field element conversion methods`);
  }
}
function arrayProp(elementType, length) {
  return function(target, key) {
    if (!target.hasOwnProperty("_fields")) {
      target._fields = [];
    }
    target._fields.push([key, Provable.Array(elementType, length)]);
  };
}
function matrixProp(elementType, nRows, nColumns) {
  return function(target, key) {
    if (!target.hasOwnProperty("_fields")) {
      target._fields = [];
    }
    target._fields.push([
      key,
      Provable.Array(Provable.Array(elementType, nColumns), nRows)
    ]);
  };
}
function Struct(type) {
  class Struct_ {
    constructor(value) {
      Object.assign(this, value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @returns the size of this struct in field elements
     */
    static sizeInFields() {
      return this.type.sizeInFields();
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns the raw list of field elements that represent this struct inside the proof
     */
    static toFields(value) {
      return this.type.toFields(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns the raw non-field element data contained in the struct
     */
    static toAuxiliary(value) {
      return this.type.toAuxiliary(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns a representation of this struct as field elements, which can be hashed efficiently
     */
    static toInput(value) {
      return this.type.toInput(value);
    }
    /**
     * Convert this struct to a JSON object, consisting only of numbers, strings, booleans, arrays and plain objects.
     * @param value
     * @returns a JSON representation of this struct
     */
    static toJSON(value) {
      return this.type.toJSON(value);
    }
    /**
     * Convert from a JSON object to an instance of this struct.
     * @param json
     * @returns a JSON representation of this struct
     */
    static fromJSON(json) {
      let value = this.type.fromJSON(json);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
    /**
     * Create an instance of this struct filled with default values
     * @returns an empty instance of this struct
     */
    static empty() {
      let value = this.type.empty();
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * Method to make assertions which should be always made whenever a struct of this type is created in a proof.
     * @param value
     */
    static check(value) {
      return this.type.check(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * Recover a struct from its raw field elements and auxiliary data.
     * @param fields the raw fields elements
     * @param aux the raw non-field element data
     */
    static fromFields(fields, aux) {
      let value = this.type.fromFields(fields, aux);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
  }
  Struct_.type = provable(type);
  return Struct_;
}
var Unconstrained = class _Unconstrained {
  constructor(isSome, value) {
    this.option = { isSome, value };
  }
  /**
   * Read an unconstrained value.
   *
   * Note: Can only be called outside provable code.
   */
  get() {
    if (inCheckedComputation() && !Snarky.run.inProverBlock())
      throw Error(`You cannot use Unconstrained.get() in provable code.

The only place where you can read unconstrained values is in Provable.witness()
and Provable.asProver() blocks, which execute outside the proof.
`);
    assert2(this.option.isSome, "Empty `Unconstrained`");
    return this.option.value;
  }
  /**
   * Modify the unconstrained value.
   */
  set(value) {
    this.option = { isSome: true, value };
  }
  /**
   * Create an `Unconstrained` with the given `value`.
   */
  static from(value) {
    return new _Unconstrained(true, value);
  }
  /**
   * Create an `Unconstrained` from a witness computation.
   */
  static witness(compute) {
    return Provable.witness(_Unconstrained.provable, () => new _Unconstrained(true, compute()));
  }
};
Unconstrained.provable = {
  sizeInFields: () => 0,
  toFields: () => [],
  toAuxiliary: (t) => [t ?? new Unconstrained(false)],
  fromFields: (_, [t]) => t,
  check: () => {
  }
};
var primitives = /* @__PURE__ */ new Set([Field4, Bool4, Scalar3, Group3]);
function isPrimitive(obj) {
  for (let P of primitives) {
    if (obj instanceof P)
      return true;
  }
  return false;
}
function cloneCircuitValue(obj) {
  if (typeof obj !== "object" || obj === null)
    return obj;
  if (obj.constructor?.name.includes("GenericArgument") || obj.constructor?.name.includes("Callback")) {
    return obj;
  }
  if (obj.constructor?.name.includes("AccountUpdate")) {
    return obj.constructor.clone(obj);
  }
  if (Array.isArray(obj))
    return obj.map(cloneCircuitValue);
  if (obj instanceof Set)
    return new Set([...obj].map(cloneCircuitValue));
  if (obj instanceof Map)
    return new Map([...obj].map(([k, v]) => [k, cloneCircuitValue(v)]));
  if (ArrayBuffer.isView(obj))
    return new obj.constructor(obj);
  if (isPrimitive(obj)) {
    return obj;
  }
  if (obj instanceof Proof) {
    return obj;
  }
  let propertyDescriptors = {};
  for (let [key, value] of Object.entries(obj)) {
    propertyDescriptors[key] = {
      value: cloneCircuitValue(value),
      writable: true,
      enumerable: true,
      configurable: true
    };
  }
  return Object.create(Object.getPrototypeOf(obj), propertyDescriptors);
}
function circuitValueEquals(a2, b2) {
  if (typeof a2 !== "object" || a2 === null || typeof b2 !== "object" || b2 === null)
    return a2 === b2;
  if (Array.isArray(a2)) {
    return Array.isArray(b2) && a2.length === b2.length && a2.every((a_, i2) => circuitValueEquals(a_, b2[i2]));
  }
  if (a2 instanceof Set) {
    return b2 instanceof Set && a2.size === b2.size && [...a2].every((a_) => b2.has(a_));
  }
  if (a2 instanceof Map) {
    return b2 instanceof Map && a2.size === b2.size && [...a2].every(([k, v]) => circuitValueEquals(v, b2.get(k)));
  }
  if (ArrayBuffer.isView(a2) && !(a2 instanceof DataView)) {
    return ArrayBuffer.isView(b2) && !(b2 instanceof DataView) && circuitValueEquals([...a2], [...b2]);
  }
  if ("equals" in a2 && typeof a2.equals === "function") {
    let isEqual = a2.equals(b2).toBoolean();
    if (typeof isEqual === "boolean")
      return isEqual;
    if (isEqual instanceof Bool4)
      return isEqual.toBoolean();
  }
  if ("toFields" in a2 && typeof a2.toFields === "function" && "toFields" in b2 && typeof b2.toFields === "function") {
    let aFields = a2.toFields();
    let bFields = b2.toFields();
    return aFields.every((a3, i2) => a3.equals(bFields[i2]).toBoolean());
  }
  let aEntries = Object.entries(a2).filter(([, v]) => v !== void 0);
  let bEntries = Object.entries(b2).filter(([, v]) => v !== void 0);
  if (aEntries.length !== bEntries.length)
    return false;
  return aEntries.every(([key, value]) => key in b2 && circuitValueEquals(b2[key], value));
}
function toConstant2(type, value) {
  return type.fromFields(type.toFields(value).map((x) => x.toConstant()), type.toAuxiliary(value));
}

// dist/node/lib/gadgets/basic.js
function assertBoolean(x) {
  Snarky.field.assertBoolean(x.value);
}
function arrayGet(array, index) {
  let i2 = toVar(index);
  let a2 = existsOne(() => array[Number(i2.toBigInt())].toBigInt());
  let n = array.length;
  for (let j = 0; j < n; j++) {
    let zj = existsOne(() => {
      let zj2 = Fp.div(Fp.sub(a2.toBigInt(), array[j].toBigInt()), Fp.sub(i2.toBigInt(), Fp.fromNumber(j)));
      return zj2 ?? 0n;
    });
    if (array[j].isConstant()) {
      assertBilinear(zj, i2, [1n, -BigInt(j), 0n, array[j].toBigInt()], a2);
    } else {
      let aMinusAj = toVar(a2.sub(array[j]));
      assertBilinear(zj, i2, [1n, -BigInt(j), 0n, 0n], aMinusAj);
    }
  }
  return a2;
}
function assertOneOf(x, allowed) {
  let xv = toVar(x);
  let [c1, c2, ...c] = allowed;
  let n = c.length;
  if (n === 0) {
    assertBilinear(xv, xv, [1n, -(c1 + c2), 0n, c1 * c2]);
    return;
  }
  let z = bilinear(xv, xv, [1n, -(c1 + c2), 0n, c1 * c2]);
  for (let i2 = 0; i2 < n; i2++) {
    if (i2 < n - 1) {
      z = bilinear(z, xv, [1n, -c[i2], 0n, 0n]);
    } else {
      assertBilinear(z, xv, [1n, -c[i2], 0n, 0n]);
    }
  }
}
function bilinear(x, y, [a2, b2, c, d]) {
  let z = existsOne(() => {
    let x0 = x.toBigInt();
    let y0 = y.toBigInt();
    return a2 * x0 * y0 + b2 * x0 + c * y0 + d;
  });
  Gates.generic({ left: b2, right: c, out: -1n, mul: a2, const: d }, { left: x, right: y, out: z });
  return z;
}
function assertBilinear(x, y, [a2, b2, c, d], z) {
  Gates.generic({ left: b2, right: c, out: z === void 0 ? 0n : -1n, mul: a2, const: d }, { left: x, right: y, out: z === void 0 ? emptyCell() : z });
}
function emptyCell() {
  return existsOne(() => 0n);
}

// dist/node/lib/gadgets/foreign-field.js
var _Sum_instances;
var _Sum_result;
var _Sum_summands;
var _Sum_ops;
var _Sum_return;
var ForeignField = {
  add(x, y, f) {
    return sum([x, y], [1n], f);
  },
  sub(x, y, f) {
    return sum([x, y], [-1n], f);
  },
  negate(x, f) {
    return sum([Field32.from(0n), x], [-1n], f);
  },
  sum,
  Sum(x) {
    return new Sum(x);
  },
  mul: multiply,
  inv: inverse2,
  div: divide,
  assertMul,
  assertAlmostReduced,
  assertLessThan(x, f) {
    assert3(f > 0n, "assertLessThan: upper bound must be positive");
    if (Field32.isConstant(x)) {
      assert3(Field32.toBigint(x) < f, "assertLessThan: got x >= f");
      return;
    }
    ForeignField.negate(x, f - 1n);
  },
  equals
};
function sum(x, sign3, f) {
  assert3(x.length === sign3.length + 1, "inputs and operators match");
  if (x.every(Field32.isConstant)) {
    let xBig = x.map(Field32.toBigint);
    let sum2 = sign3.reduce((sum3, s, i2) => sum3 + s * xBig[i2 + 1], xBig[0]);
    return Field32.from(mod(sum2, f));
  }
  x = x.map(toVars);
  let result = x[0];
  for (let i2 = 0; i2 < sign3.length; i2++) {
    ({ result } = singleAdd(result, x[i2 + 1], sign3[i2], f));
  }
  Gates.zero(...result);
  multiRangeCheck(result);
  return result;
}
function singleAdd(x, y, sign3, f) {
  let f_ = split(f);
  let [r0, r1, r2, overflow, carry] = exists(5, () => {
    let x_ = toBigint3(x);
    let y_ = toBigint3(y);
    let r = combine(x_) + sign3 * combine(y_);
    let overflow2 = 0n;
    if (sign3 === 1n && r >= f)
      overflow2 = 1n;
    if (sign3 === -1n && r < 0n)
      overflow2 = -1n;
    if (f === 0n)
      overflow2 = 0n;
    let r01 = combine2(x_) + sign3 * combine2(y_) - overflow2 * combine2(f_);
    let carry2 = r01 >> l2;
    r01 &= l2Mask;
    let [r02, r12] = split2(r01);
    let r22 = x_[2] + sign3 * y_[2] - overflow2 * f_[2] + carry2;
    return [r02, r12, r22, overflow2, carry2];
  });
  foreignFieldAdd({ left: x, right: y, overflow, carry, modulus: f_, sign: sign3 });
  return { result: [r0, r1, r2], overflow };
}
function multiply(a2, b2, f) {
  assert3(f < 1n << 259n, "Foreign modulus fits in 259 bits");
  if (Field32.isConstant(a2) && Field32.isConstant(b2)) {
    let ab = Field32.toBigint(a2) * Field32.toBigint(b2);
    return Field32.from(mod(ab, f));
  }
  let { r01, r2, q: q3 } = multiplyNoRangeCheck(a2, b2, f);
  multiRangeCheck(q3);
  let r = compactMultiRangeCheck(r01, r2);
  return r;
}
function inverse2(x, f) {
  assert3(f < 1n << 259n, "Foreign modulus fits in 259 bits");
  if (Field32.isConstant(x)) {
    let xInv2 = inverse(Field32.toBigint(x), f);
    assert3(xInv2 !== void 0, "inverse exists");
    return Field32.from(xInv2);
  }
  let xInv = exists(3, () => {
    let xInv2 = inverse(Field32.toBigint(x), f);
    return xInv2 === void 0 ? [0n, 0n, 0n] : split(xInv2);
  });
  multiRangeCheck(xInv);
  let xInv2Bound = weakBound(xInv[2], f);
  let one = [Field3.from(1n), Field3.from(0n)];
  assertMulInternal(x, xInv, one, f);
  multiRangeCheck([xInv2Bound, Field3.from(0n), Field3.from(0n)]);
  return xInv;
}
function divide(x, y, f, { allowZeroOverZero = false } = {}) {
  assert3(f < 1n << 259n, "Foreign modulus fits in 259 bits");
  if (Field32.isConstant(x) && Field32.isConstant(y)) {
    let yInv = inverse(Field32.toBigint(y), f);
    assert3(yInv !== void 0, "inverse exists");
    return Field32.from(mod(Field32.toBigint(x) * yInv, f));
  }
  let z = exists(3, () => {
    let yInv = inverse(Field32.toBigint(y), f);
    if (yInv === void 0)
      return [0n, 0n, 0n];
    return split(mod(Field32.toBigint(x) * yInv, f));
  });
  multiRangeCheck(z);
  let z2Bound = weakBound(z[2], f);
  assertMulInternal(z, y, x, f);
  multiRangeCheck([z2Bound, Field3.from(0n), Field3.from(0n)]);
  if (!allowZeroOverZero) {
    ForeignField.equals(y, 0n, f).assertFalse();
  }
  return z;
}
function assertMulInternal(x, y, xy, f, message) {
  let { r01, r2, q: q3 } = multiplyNoRangeCheck(x, y, f);
  multiRangeCheck(q3);
  if (xy.length === 2) {
    let [xy01, xy2] = xy;
    r01.assertEquals(xy01, message);
    r2.assertEquals(xy2, message);
  } else {
    let xy01 = xy[0].add(xy[1].mul(1n << l));
    r01.assertEquals(xy01, message);
    r2.assertEquals(xy[2], message);
  }
}
function multiplyNoRangeCheck(a2, b2, f) {
  let f_ = (1n << l3) - f;
  let [f_0, f_1, f_2] = split(f_);
  let f2 = f >> l2;
  let f2Bound = (1n << l) - f2 - 1n;
  let witnesses = exists(21, () => {
    let [a0, a1, a22] = toBigint3(a2);
    let [b0, b1, b22] = toBigint3(b2);
    let ab = combine([a0, a1, a22]) * combine([b0, b1, b22]);
    let q4 = ab / f;
    let r = ab - q4 * f;
    let [q02, q12, q23] = split(q4);
    let [r0, r1, r22] = split(r);
    let r012 = combine2([r0, r1]);
    let p0 = a0 * b0 + q02 * f_0;
    let p1 = a0 * b1 + a1 * b0 + q02 * f_1 + q12 * f_0;
    let p22 = a0 * b22 + a1 * b1 + a22 * b0 + q02 * f_2 + q12 * f_1 + q23 * f_0;
    let [p102, p1102, p1112] = split(p1);
    let p11 = combine2([p1102, p1112]);
    let c02 = p0 + (p102 << l) - r012 >> l2;
    let c1 = p22 - r22 + p11 + c02 >> l;
    let c1_002 = bitSlice(c1, 0, 12);
    let c1_122 = bitSlice(c1, 12, 12);
    let c1_242 = bitSlice(c1, 24, 12);
    let c1_362 = bitSlice(c1, 36, 12);
    let c1_482 = bitSlice(c1, 48, 12);
    let c1_602 = bitSlice(c1, 60, 12);
    let c1_722 = bitSlice(c1, 72, 12);
    let c1_842 = bitSlice(c1, 84, 2);
    let c1_862 = bitSlice(c1, 86, 2);
    let c1_882 = bitSlice(c1, 88, 2);
    let c1_902 = bitSlice(c1, 90, 1);
    let q2Bound2 = q23 + f2Bound;
    return [
      r012,
      r22,
      q02,
      q12,
      q23,
      q2Bound2,
      p102,
      p1102,
      p1112,
      c02,
      c1_002,
      c1_122,
      c1_242,
      c1_362,
      c1_482,
      c1_602,
      c1_722,
      c1_842,
      c1_862,
      c1_882,
      c1_902
    ];
  });
  let [r01, r2, q0, q1, q22, q2Bound, p10, p110, p111, c0, c1_00, c1_12, c1_24, c1_36, c1_48, c1_60, c1_72, c1_84, c1_86, c1_88, c1_90] = witnesses;
  let q3 = [q0, q1, q22];
  Gates.foreignFieldMul({
    left: a2,
    right: b2,
    remainder: [r01, r2],
    quotient: q3,
    quotientHiBound: q2Bound,
    product1: [p10, p110, p111],
    carry0: c0,
    carry1p: [c1_00, c1_12, c1_24, c1_36, c1_48, c1_60, c1_72],
    carry1c: [c1_84, c1_86, c1_88, c1_90],
    foreignFieldModulus2: f2,
    negForeignFieldModulus: [f_0, f_1, f_2]
  });
  multiRangeCheck([p10, p110, q2Bound]);
  return { r01, r2, q: q3 };
}
function weakBound(x, f) {
  if ((f & l2Mask) === 0n) {
    return x.add(lMask + 1n - (f >> l2));
  }
  return x.add(lMask - (f >> l2));
}
function assertAlmostReduced(xs, f, skipMrc = false) {
  let bounds = [];
  for (let x of xs) {
    if (!skipMrc)
      multiRangeCheck(x);
    bounds.push(weakBound(x[2], f));
    if (TupleN.hasLength(3, bounds)) {
      multiRangeCheck(bounds);
      bounds = [];
    }
  }
  if (TupleN.hasLength(1, bounds)) {
    multiRangeCheck([...bounds, Field3.from(0n), Field3.from(0n)]);
  }
  if (TupleN.hasLength(2, bounds)) {
    multiRangeCheck([...bounds, Field3.from(0n)]);
  }
}
function equals(x, c, f) {
  assert3(c >= 0n && c < f, "equals: c must be in [0, f)");
  if (Field32.isConstant(x)) {
    return new Bool3(mod(Field32.toBigint(x), f) === c);
  }
  if (f >= 1n << l2) {
    let x01 = toVar(x[0].add(x[1].mul(1n << l)));
    let [c01, c2] = [c & l2Mask, c >> l2];
    let [cPlusF01, cPlusF2] = [c + f & l2Mask, c + f >> l2];
    let isC = x01.equals(c01).and(x[2].equals(c2));
    let isCPlusF = x01.equals(cPlusF01).and(x[2].equals(cPlusF2));
    return isC.or(isCPlusF);
  } else {
    ForeignField.assertLessThan(x, f);
    let x012 = toVar(x[0].add(x[1].mul(1n << l)).add(x[2].mul(1n << l2)));
    return x012.equals(c);
  }
}
var Field32 = {
  /**
   * Turn a bigint into a 3-tuple of Fields
   */
  from(x) {
    return Tuple.map(split(x), Field3.from);
  },
  /**
   * Turn a 3-tuple of Fields into a bigint
   */
  toBigint(x) {
    return combine(toBigint3(x));
  },
  /**
   * Turn several 3-tuples of Fields into bigints
   */
  toBigints(...xs) {
    return Tuple.map(xs, Field32.toBigint);
  },
  /**
   * Check whether a 3-tuple of Fields is constant
   */
  isConstant(x) {
    return x.every((x2) => x2.isConstant());
  },
  /**
   * Provable<T> interface for `Field3 = [Field, Field, Field]`.
   *
   * Note: Witnessing this creates a plain tuple of field elements without any implicit
   * range checks.
   */
  provable: provableTuple([Field3, Field3, Field3])
};
function toBigint3(x) {
  return Tuple.map(x, (x2) => x2.toBigInt());
}
function combine([x0, x1, x2]) {
  return x0 + (x1 << l) + (x2 << l2);
}
function split(x) {
  return [x & lMask, x >> l & lMask, x >> l2 & lMask];
}
function combine2([x0, x1]) {
  return x0 + (x1 << l);
}
function split2(x) {
  return [x & lMask, x >> l & lMask];
}
function assertMul(x, y, xy, f, message) {
  x = Sum.fromUnfinished(x);
  y = Sum.fromUnfinished(y);
  xy = Sum.fromUnfinished(xy);
  assert3(BigInt(Math.ceil(Math.sqrt(x.length * y.length))) * f < 1n << 258n, `Foreign modulus is too large for multiplication of sums of lengths ${x.length} and ${y.length}`);
  let y0 = y.finishForMulInput(f);
  let xy0 = xy.finish(f);
  let x0 = x.finishForMulInput(f, true);
  if (Field32.isConstant(x0) && Field32.isConstant(y0) && Field32.isConstant(xy0)) {
    let x_ = Field32.toBigint(x0);
    let y_ = Field32.toBigint(y0);
    let xy_ = Field32.toBigint(xy0);
    assert3(mod(x_ * y_, f) === xy_, message ?? "assertMul(): incorrect multiplication result");
    return;
  }
  assertMulInternal(x0, y0, xy0, f, message);
}
var Sum = class _Sum {
  constructor(x) {
    _Sum_instances.add(this);
    _Sum_result.set(this, void 0);
    _Sum_summands.set(this, void 0);
    _Sum_ops.set(this, []);
    (0, import_tslib2.__classPrivateFieldSet)(this, _Sum_summands, [x], "f");
  }
  get result() {
    assert3((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f") !== void 0, "sum not finished");
    return (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f");
  }
  get length() {
    return (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f").length;
  }
  add(y) {
    assert3((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_ops, "f").push(1n);
    (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f").push(y);
    return this;
  }
  sub(y) {
    assert3((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_ops, "f").push(-1n);
    (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f").push(y);
    return this;
  }
  isConstant() {
    return (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f").every(Field32.isConstant);
  }
  finish(f, isChained = false) {
    assert3((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    let signs = (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_ops, "f");
    let n = signs.length;
    if (n === 0)
      return (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f")[0]);
    if (this.isConstant()) {
      return (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, sum((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f"), signs, f));
    }
    let x = (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f").map(toVars);
    let result = x[0];
    for (let i2 = 0; i2 < n; i2++) {
      ({ result } = singleAdd(result, x[i2 + 1], signs[i2], f));
    }
    if (!isChained)
      Gates.zero(...result);
    (0, import_tslib2.__classPrivateFieldSet)(this, _Sum_result, result, "f");
    return result;
  }
  // TODO this is complex and should be removed once we fix the ffadd gate to constrain all limbs individually
  finishForMulInput(f, isChained = false) {
    assert3((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f") === void 0, "sum already finished");
    let signs = (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_ops, "f");
    let n = signs.length;
    if (n === 0)
      return (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f")[0]);
    if (this.isConstant()) {
      return (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_instances, "m", _Sum_return).call(this, sum((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f"), signs, f));
    }
    let xs = (0, import_tslib2.__classPrivateFieldGet)(this, _Sum_summands, "f").map(toVars);
    let f0 = f & lMask;
    let x0 = xs[0][0];
    let x0s = [];
    let overflows = [];
    let xRef = Unconstrained.witness(() => Field32.toBigint(xs[0]));
    for (let i2 = 0; i2 < n; i2++) {
      let [carry, overflow] = exists(2, () => {
        let x2 = xRef.get();
        let x02 = x2 & lMask;
        let xi = toBigint3(xs[i2 + 1]);
        let sign3 = signs[i2];
        x2 += sign3 * combine(xi);
        let overflow2 = 0n;
        if (sign3 === 1n && x2 >= f)
          overflow2 = 1n;
        if (sign3 === -1n && x2 < 0n)
          overflow2 = -1n;
        if (f === 0n)
          overflow2 = 0n;
        xRef.set(x2 - overflow2 * f);
        x02 = x02 + sign3 * xi[0] - overflow2 * f0;
        let carry2 = x02 >> l;
        return [carry2, overflow2];
      });
      overflows.push(overflow);
      assertOneOf(carry, [0n, 1n, -1n]);
      x0 = toVar(x0.add(xs[i2 + 1][0].mul(signs[i2])).sub(overflow.mul(f0)).sub(carry.mul(1n << l)));
      x0s.push(x0);
    }
    let x = xs[0];
    for (let i2 = 0; i2 < n; i2++) {
      let { result, overflow } = singleAdd(x, xs[i2 + 1], signs[i2], f);
      result[0].assertEquals(x0s[i2]);
      overflow.assertEquals(overflows[i2]);
      x = result;
    }
    if (!isChained)
      Gates.zero(...x);
    (0, import_tslib2.__classPrivateFieldSet)(this, _Sum_result, x, "f");
    return x;
  }
  rangeCheck() {
    assert3((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f") !== void 0, "sum not finished");
    if ((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_ops, "f").length > 0)
      multiRangeCheck((0, import_tslib2.__classPrivateFieldGet)(this, _Sum_result, "f"));
  }
  static fromUnfinished(x) {
    if (x instanceof _Sum) {
      assert3((0, import_tslib2.__classPrivateFieldGet)(x, _Sum_result, "f") === void 0, "sum already finished");
      return x;
    }
    return new _Sum(x);
  }
};
_Sum_result = /* @__PURE__ */ new WeakMap(), _Sum_summands = /* @__PURE__ */ new WeakMap(), _Sum_ops = /* @__PURE__ */ new WeakMap(), _Sum_instances = /* @__PURE__ */ new WeakSet(), _Sum_return = function _Sum_return2(x) {
  (0, import_tslib2.__classPrivateFieldSet)(this, _Sum_result, x, "f");
  return x;
};

// dist/node/lib/gadgets/arithmetic.js
function divMod32(n, quotientBits = 32) {
  if (n.isConstant()) {
    assert2(n.toBigInt() < 1n << 64n, `n needs to fit into 64 bit, but got ${n.toBigInt()}`);
    let nBigInt = n.toBigInt();
    let q3 = nBigInt >> 32n;
    let r = nBigInt - (q3 << 32n);
    return {
      remainder: new Field4(r),
      quotient: new Field4(q3)
    };
  }
  let [quotient, remainder] = Provable.witness(provableTuple([Field4, Field4]), () => {
    let nBigInt = n.toBigInt();
    let q3 = nBigInt >> 32n;
    let r = nBigInt - (q3 << 32n);
    return [new Field4(q3), new Field4(r)];
  });
  if (quotientBits === 1) {
    Bool3.check(Bool3.Unsafe.ofField(quotient));
  } else {
    rangeCheckN(quotientBits, quotient);
  }
  rangeCheck32(remainder);
  n.assertEquals(quotient.mul(1n << 32n).add(remainder));
  return {
    remainder,
    quotient
  };
}
function addMod32(x, y) {
  return divMod32(x.add(y), 1).remainder;
}

// dist/node/lib/gadgets/bitwise.js
function not(a2, length, checked = false) {
  assert3(length > 0, `Input length needs to be positive values.`);
  assert3(length < Field3.sizeInBits, `Length ${length} exceeds maximum of ${Field3.sizeInBits} bits.`);
  let padLength = Math.ceil(length / 16) * 16;
  if (a2.isConstant()) {
    let max2 = 1n << BigInt(padLength);
    assert3(a2.toBigInt() < max2, `${a2.toBigInt()} does not fit into ${padLength} bits`);
    return new Field3(Field.not(a2.toBigInt(), length));
  }
  let allOnes = new Field3(2n ** BigInt(length) - 1n);
  if (checked) {
    return xor2(a2, allOnes, length);
  } else {
    return allOnes.sub(a2).seal();
  }
}
function xor2(a2, b2, length) {
  assert3(length > 0, `Input lengths need to be positive values.`);
  assert3(length <= 254, `Length ${length} exceeds maximum of 254 bits.`);
  let padLength = Math.ceil(length / 16) * 16;
  if (a2.isConstant() && b2.isConstant()) {
    let max2 = 1n << BigInt(padLength);
    assert3(a2.toBigInt() < max2, `${a2} does not fit into ${padLength} bits`);
    assert3(b2.toBigInt() < max2, `${b2} does not fit into ${padLength} bits`);
    return new Field3(a2.toBigInt() ^ b2.toBigInt());
  }
  let outputXor = Provable.witness(Field3, () => new Field3(a2.toBigInt() ^ b2.toBigInt()));
  buildXor(a2, b2, outputXor, padLength);
  return outputXor;
}
function buildXor(a2, b2, out, padLength) {
  while (padLength !== 0) {
    let slices = exists(15, () => {
      let a0 = a2.toBigInt();
      let b0 = b2.toBigInt();
      let out02 = out.toBigInt();
      return [
        // slices of a
        bitSlice(a0, 0, 4),
        bitSlice(a0, 4, 4),
        bitSlice(a0, 8, 4),
        bitSlice(a0, 12, 4),
        // slices of b
        bitSlice(b0, 0, 4),
        bitSlice(b0, 4, 4),
        bitSlice(b0, 8, 4),
        bitSlice(b0, 12, 4),
        // slices of expected output
        bitSlice(out02, 0, 4),
        bitSlice(out02, 4, 4),
        bitSlice(out02, 8, 4),
        bitSlice(out02, 12, 4),
        // next values
        a0 >> 16n,
        b0 >> 16n,
        out02 >> 16n
      ];
    });
    let [in1_0, in1_1, in1_2, in1_3, in2_0, in2_1, in2_2, in2_3, out0, out1, out2, out3, aNext, bNext, outNext] = slices;
    Gates.xor(a2, b2, out, in1_0, in1_1, in1_2, in1_3, in2_0, in2_1, in2_2, in2_3, out0, out1, out2, out3);
    a2 = aNext;
    b2 = bNext;
    out = outNext;
    padLength = padLength - 16;
  }
  Gates.zero(a2, b2, out);
  let zero2 = new Field3(0);
  zero2.assertEquals(a2);
  zero2.assertEquals(b2);
  zero2.assertEquals(out);
}
function and(a2, b2, length) {
  assert3(length > 0, `Input lengths need to be positive values.`);
  assert3(length <= Field3.sizeInBits, `Length ${length} exceeds maximum of ${Field3.sizeInBits} bits.`);
  let padLength = Math.ceil(length / 16) * 16;
  if (a2.isConstant() && b2.isConstant()) {
    let max2 = 1n << BigInt(padLength);
    assert3(a2.toBigInt() < max2, `${a2} does not fit into ${padLength} bits`);
    assert3(b2.toBigInt() < max2, `${b2} does not fit into ${padLength} bits`);
    return new Field3(a2.toBigInt() & b2.toBigInt());
  }
  let outputAnd = Provable.witness(Field3, () => new Field3(a2.toBigInt() & b2.toBigInt()));
  let sum2 = a2.add(b2);
  let xorOutput = xor2(a2, b2, length);
  outputAnd.mul(2).add(xorOutput).assertEquals(sum2);
  return outputAnd;
}
function rotate64(field, bits2, direction = "left") {
  assert3(bits2 >= 0 && bits2 <= MAX_BITS, `rotation: expected bits to be between 0 and 64, got ${bits2}`);
  if (field.isConstant()) {
    assert3(field.toBigInt() < 1n << BigInt(MAX_BITS), `rotation: expected field to be at most 64 bits, got ${field.toBigInt()}`);
    return new Field3(Field.rot(field.toBigInt(), BigInt(bits2), direction));
  }
  const [rotated] = rot64(field, bits2, direction);
  return rotated;
}
function rotate32(field, bits2, direction = "left") {
  assert3(bits2 <= 32 && bits2 > 0, "bits must be between 0 and 32");
  if (field.isConstant()) {
    assert3(field.toBigInt() < 1n << 32n, `rotation: expected field to be at most 32 bits, got ${field.toBigInt()}`);
    return new Field3(Field.rot(field.toBigInt(), BigInt(bits2), direction, 32n));
  }
  let { quotient: excess, remainder: shifted } = divMod32(field.mul(1n << BigInt(direction === "left" ? bits2 : 32 - bits2)));
  let rotated = shifted.add(excess);
  rangeCheck32(rotated);
  return rotated;
}
function rot64(field, bits2, direction = "left") {
  const rotationBits = direction === "right" ? MAX_BITS - bits2 : bits2;
  const big2Power64 = 2n ** BigInt(MAX_BITS);
  const big2PowerRot = 2n ** BigInt(rotationBits);
  const [rotated, excess, shifted, bound] = Provable.witness(Provable.Array(Field3, 4), () => {
    const f = field.toBigInt();
    const { quotient: excess2, remainder: shifted2 } = divideWithRemainder(f * big2PowerRot, big2Power64);
    const rotated2 = shifted2 + excess2;
    const bound2 = excess2 + big2Power64 - big2PowerRot;
    return [rotated2, excess2, shifted2, bound2].map(Field3.from);
  });
  toVar(0n);
  let boundSlices = exists(12, () => {
    let bound0 = bound.toBigInt();
    return [
      bitSlice(bound0, 52, 12),
      bitSlice(bound0, 40, 12),
      bitSlice(bound0, 28, 12),
      bitSlice(bound0, 16, 12),
      bitSlice(bound0, 14, 2),
      bitSlice(bound0, 12, 2),
      bitSlice(bound0, 10, 2),
      bitSlice(bound0, 8, 2),
      bitSlice(bound0, 6, 2),
      bitSlice(bound0, 4, 2),
      bitSlice(bound0, 2, 2),
      bitSlice(bound0, 0, 2)
      // bits 0-2
    ];
  });
  let [b52, b40, b28, b16, b14, b12, b10, b8, b6, b4, b2, b0] = boundSlices;
  Gates.rotate(field, rotated, excess, [b52, b40, b28, b16], [b14, b12, b10, b8, b6, b4, b2, b0], big2PowerRot);
  rangeCheck64(shifted);
  return [rotated, excess, shifted];
}
function rightShift64(field, bits2) {
  assert3(bits2 >= 0 && bits2 <= MAX_BITS, `rightShift: expected bits to be between 0 and 64, got ${bits2}`);
  if (field.isConstant()) {
    assert3(field.toBigInt() < 2n ** BigInt(MAX_BITS), `rightShift: expected field to be at most 64 bits, got ${field.toBigInt()}`);
    return new Field3(Field.rightShift(field.toBigInt(), bits2));
  }
  const [, excess] = rot64(field, bits2, "right");
  return excess;
}
function leftShift64(field, bits2) {
  assert3(bits2 >= 0 && bits2 <= MAX_BITS, `rightShift: expected bits to be between 0 and 64, got ${bits2}`);
  if (field.isConstant()) {
    assert3(field.toBigInt() < 2n ** BigInt(MAX_BITS), `rightShift: expected field to be at most 64 bits, got ${field.toBigInt()}`);
    return new Field3(Field.leftShift(field.toBigInt(), bits2));
  }
  const [, , shifted] = rot64(field, bits2, "left");
  return shifted;
}
function leftShift32(field, bits2) {
  let { remainder: shifted } = divMod32(field.mul(1n << BigInt(bits2)));
  return shifted;
}

// dist/node/lib/int.js
var import_tslib3 = require("tslib");
var UInt642 = class _UInt64 extends CircuitValue {
  constructor(x) {
    if (x instanceof _UInt64 || x instanceof UInt322)
      x = x.value;
    else if (!(x instanceof Field4))
      x = Field4(x);
    super(x);
  }
  /**
   * Static method to create a {@link UInt64} with value `0`.
   */
  static get zero() {
    return new _UInt64(Field4(0));
  }
  /**
   * Static method to create a {@link UInt64} with value `1`.
   */
  static get one() {
    return new _UInt64(Field4(1));
  }
  /**
   * Turns the {@link UInt64} into a string.
   * @returns
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Turns the {@link UInt64} into a {@link BigInt}.
   * @returns
   */
  toBigInt() {
    return this.value.toBigInt();
  }
  /**
   * Turns the {@link UInt64} into a {@link UInt32}, asserting that it fits in 32 bits.
   */
  toUInt32() {
    let uint322 = new UInt322(this.value);
    UInt322.check(uint322);
    return uint322;
  }
  /**
   * Turns the {@link UInt64} into a {@link UInt32}, clamping to the 32 bits range if it's too large.
   * ```ts
   * UInt64.from(4294967296).toUInt32Clamped().toString(); // "4294967295"
   * ```
   */
  toUInt32Clamped() {
    let max2 = (1n << 32n) - 1n;
    return Provable.if(this.greaterThan(_UInt64.from(max2)), UInt322.from(max2), new UInt322(this.value));
  }
  static check(x) {
    rangeCheckN(_UInt64.NUM_BITS, x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 64]] };
  }
  /**
   * Encodes this structure into a JSON-like object.
   */
  static toJSON(x) {
    return x.value.toString();
  }
  /**
   * Decodes a JSON-like object into this structure.
   */
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt64: Expected number between 0 and 2^64 - 1, got ${xBig}`);
    }
    return x;
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link UInt64}.
   */
  static from(x) {
    if (x instanceof _UInt64 || x instanceof UInt322)
      x = x.value;
    return new this(this.checkConstant(Field4(x)));
  }
  /**
   * Creates a {@link UInt64} with a value of 18,446,744,073,709,551,615.
   */
  static MAXINT() {
    return new _UInt64(Field4((1n << 64n) - 1n));
  }
  /**
   * Integer division with remainder.
   *
   * `x.divMod(y)` returns the quotient and the remainder.
   */
  divMod(y) {
    let x = this.value;
    let y_ = _UInt64.from(y).value;
    if (this.value.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return {
        quotient: new _UInt64(Field4(q4)),
        rest: new _UInt64(Field4(r2))
      };
    }
    y_ = y_.seal();
    let q3 = Provable.witness(Field4, () => new Field4(x.toBigInt() / y_.toBigInt()));
    rangeCheckN(_UInt64.NUM_BITS, q3);
    let r = x.sub(q3.mul(y_)).seal();
    rangeCheckN(_UInt64.NUM_BITS, r);
    let r_ = new _UInt64(r);
    let q_ = new _UInt64(q3);
    r_.assertLessThan(new _UInt64(y_));
    return { quotient: q_, rest: r_ };
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `z * y <= x`.
   *
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisble by `y`.
   */
  mod(y) {
    return this.divMod(y).rest;
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let z = this.value.mul(_UInt64.from(y).value);
    rangeCheckN(_UInt64.NUM_BITS, z);
    return new _UInt64(z);
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let z = this.value.add(_UInt64.from(y).value);
    rangeCheckN(_UInt64.NUM_BITS, z);
    return new _UInt64(z);
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let z = this.value.sub(_UInt64.from(y).value);
    rangeCheckN(_UInt64.NUM_BITS, z);
    return new _UInt64(z);
  }
  /**
   * Bitwise XOR gadget on {@link Field} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).
   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.
   *
   * This gadget builds a chain of XOR gates recursively.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)
   *
   * @param x {@link UInt64} element to XOR.
   *
   * @example
   * ```ts
   * let a = UInt64.from(0b0101);
   * let b = UInt64.from(0b0011);
   *
   * let c = a.xor(b);
   * c.assertEquals(0b0110);
   * ```
   */
  xor(x) {
    return new _UInt64(xor2(this.value, x.value, _UInt64.NUM_BITS));
  }
  /**
   * Bitwise NOT gate on {@link Field} elements. Similar to the [bitwise
   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/
   * Web/JavaScript/Reference/Operators/Bitwise_NOT).
   *
   * **Note:** The NOT gate operates over 64 bit for UInt64 types.
   *
   * A NOT gate works by returning `1` in each bit position if the
   * corresponding bit of the operand is `0`, and returning `0` if the
   * corresponding bit of the operand is `1`.
   *
   * NOT is implemented as a subtraction of the input from the all one bitmask
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)
   *
   * @example
   * ```ts
   * // NOTing 4 bits with the unchecked version
   * let a = UInt64.from(0b0101);
   * let b = a.not(false);
   *
   * console.log(b.toBigInt().toString(2));
   * // 1111111111111111111111111111111111111111111111111111111111111010
   *
   * ```
   *
   * @param a - The value to apply NOT to.
   *
   */
  not() {
    return new _UInt64(not(this.value, _UInt64.NUM_BITS, false));
  }
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * To safely use `rotate()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)
   *
   * @param bits amount of bits to rotate this {@link UInt64} element with.
   * @param direction left or right rotation direction.
   *
   *
   * @example
   * ```ts
   * const x = UInt64.from(0b001100);
   * const y = x.rotate(2, 'left');
   * const z = x.rotate(2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   * ```
   */
  rotate(bits2, direction = "left") {
    return new _UInt64(rotate64(this.value, bits2, direction));
  }
  /**
   * Performs a left shift operation on the provided {@link UInt64} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * @param bits Amount of bits to shift the {@link UInt64} element to the left. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = UInt64.from(0b001100); // 12 in binary
   * const y = x.leftShift(2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   * ```
   */
  leftShift(bits2) {
    return new _UInt64(leftShift64(this.value, bits2));
  }
  /**
   * Performs a left right operation on the provided {@link UInt64} element.
   * This operation is similar to the `>>` shift operation in JavaScript,
   * where bits are shifted to the right, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * @param bits Amount of bits to shift the {@link UInt64} element to the right. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = UInt64.from(0b001100); // 12 in binary
   * const y = x.rightShift(2); // left shift by 2 bits
   * y.assertEquals(0b000011); // 48 in binary
   * ```
   */
  rightShift(bits2) {
    return new _UInt64(leftShift64(this.value, bits2));
  }
  /**
   * Bitwise AND gadget on {@link UInt64} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).
   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.
   *
   * It can be checked by a double generic gate that verifies the following relationship between the values below.
   *
   * The generic gate verifies:\
   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\
   * Where:\
   * `a + b = sum`\
   * `a ^ b = xor`\
   * `a & b = and`
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)
   *
   *
   * @example
   * ```typescript
   * let a = UInt64.from(3);    // ... 000011
   * let b = UInt64.from(5);    // ... 000101
   *
   * let c = a.and(b);    // ... 000001
   * c.assertEquals(1);
   * ```
   */
  and(x) {
    return new _UInt64(and(this.value, x.value, _UInt64.NUM_BITS));
  }
  /**
   * @deprecated Use {@link lessThanOrEqual} instead.
   *
   * Checks if a {@link UInt64} is less than or equal to another one.
   */
  lte(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = isInRangeN(_UInt64.NUM_BITS, xMinusY);
      let yMinusXFits = isInRangeN(_UInt64.NUM_BITS, yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * Checks if a {@link UInt64} is less than or equal to another one.
   */
  lessThanOrEqual(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = isInRangeN(_UInt64.NUM_BITS, xMinusY);
      let yMinusXFits = isInRangeN(_UInt64.NUM_BITS, yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * @deprecated Use {@link assertLessThanOrEqual} instead.
   *
   * Asserts that a {@link UInt64} is less than or equal to another one.
   */
  assertLte(y, message) {
    this.assertLessThanOrEqual(y, message);
  }
  /**
   * Asserts that a {@link UInt64} is less than or equal to another one.
   */
  assertLessThanOrEqual(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let x0 = this.value.toBigInt();
      let y0 = y.value.toBigInt();
      if (x0 > y0) {
        if (message !== void 0)
          throw Error(message);
        throw Error(`UInt64.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
      }
      return;
    }
    let yMinusX = y.value.sub(this.value).seal();
    rangeCheckN(_UInt64.NUM_BITS, yMinusX, message);
  }
  /**
   * @deprecated Use {@link lessThan} instead.
   *
   * Checks if a {@link UInt64} is less than another one.
   */
  lt(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   *
   * Checks if a {@link UInt64} is less than another one.
   */
  lessThan(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   *
   * @deprecated Use {@link assertLessThan} instead.
   *
   * Asserts that a {@link UInt64} is less than another one.
   */
  assertLt(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * Asserts that a {@link UInt64} is less than another one.
   */
  assertLessThan(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * @deprecated Use {@link greaterThan} instead.
   *
   * Checks if a {@link UInt64} is greater than another one.
   */
  gt(y) {
    return y.lessThan(this);
  }
  /**
   * Checks if a {@link UInt64} is greater than another one.
   */
  greaterThan(y) {
    return y.lessThan(this);
  }
  /**
   * @deprecated Use {@link assertGreaterThan} instead.
   *
   * Asserts that a {@link UInt64} is greater than another one.
   */
  assertGt(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * Asserts that a {@link UInt64} is greater than another one.
   */
  assertGreaterThan(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * @deprecated Use {@link greaterThanOrEqual} instead.
   *
   * Checks if a {@link UInt64} is greater than or equal to another one.
   */
  gte(y) {
    return this.lessThan(y).not();
  }
  /**
   * Checks if a {@link UInt64} is greater than or equal to another one.
   */
  greaterThanOrEqual(y) {
    return this.lessThan(y).not();
  }
  /**
   * @deprecated Use {@link assertGreaterThanOrEqual} instead.
   *
   * Asserts that a {@link UInt64} is greater than or equal to another one.
   */
  assertGte(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
  /**
   * Asserts that a {@link UInt64} is greater than or equal to another one.
   */
  assertGreaterThanOrEqual(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
};
UInt642.NUM_BITS = 64;
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Field4)
], UInt642.prototype, "value", void 0);
var UInt322 = class _UInt32 extends CircuitValue {
  constructor(x) {
    if (x instanceof _UInt32)
      x = x.value;
    else if (!(x instanceof Field4))
      x = Field4(x);
    super(x);
  }
  /**
   * Static method to create a {@link UInt32} with value `0`.
   */
  static get zero() {
    return new _UInt32(Field4(0));
  }
  /**
   * Static method to create a {@link UInt32} with value `0`.
   */
  static get one() {
    return new _UInt32(Field4(1));
  }
  /**
   * Turns the {@link UInt32} into a string.
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Turns the {@link UInt32} into a {@link BigInt}.
   */
  toBigint() {
    return this.value.toBigInt();
  }
  /**
   * Turns the {@link UInt32} into a {@link UInt64}.
   */
  toUInt64() {
    return new UInt642(this.value);
  }
  static check(x) {
    rangeCheck32(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 32]] };
  }
  /**
   * Encodes this structure into a JSON-like object.
   */
  static toJSON(x) {
    return x.value.toString();
  }
  /**
   * Decodes a JSON-like object into this structure.
   */
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt32: Expected number between 0 and 2^32 - 1, got ${xBig}`);
    }
    return x;
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link UInt32}.
   */
  static from(x) {
    if (x instanceof _UInt32)
      x = x.value;
    return new this(this.checkConstant(Field4(x)));
  }
  /**
   * Creates a {@link UInt32} with a value of 4,294,967,295.
   */
  static MAXINT() {
    return new _UInt32(Field4((1n << 32n) - 1n));
  }
  /**
   * Addition modulo 2^32. Check {@link Gadgets.addMod32} for a detailed description.
   */
  addMod32(y) {
    return new _UInt32(addMod32(this.value, y.value));
  }
  /**
   * Integer division with remainder.
   *
   * `x.divMod(y)` returns the quotient and the remainder.
   */
  divMod(y) {
    let x = this.value;
    let y_ = _UInt32.from(y).value;
    if (x.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return {
        quotient: new _UInt32(new Field4(q4.toString())),
        rest: new _UInt32(new Field4(r2.toString()))
      };
    }
    y_ = y_.seal();
    let q3 = Provable.witness(Field4, () => new Field4(x.toBigInt() / y_.toBigInt()));
    rangeCheck32(q3);
    let r = x.sub(q3.mul(y_)).seal();
    rangeCheck32(r);
    let r_ = new _UInt32(r);
    let q_ = new _UInt32(q3);
    r_.assertLessThan(new _UInt32(y_));
    return { quotient: q_, rest: r_ };
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `x * y <= x`.
   *
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisble by `y`.
   */
  mod(y) {
    return this.divMod(y).rest;
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let z = this.value.mul(_UInt32.from(y).value);
    rangeCheck32(z);
    return new _UInt32(z);
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let z = this.value.add(_UInt32.from(y).value);
    rangeCheck32(z);
    return new _UInt32(z);
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let z = this.value.sub(_UInt32.from(y).value);
    rangeCheck32(z);
    return new _UInt32(z);
  }
  /**
   * Bitwise XOR gadget on {@link UInt32} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).
   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.
   *
   * This gadget builds a chain of XOR gates recursively.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)
   *
   * @param x {@link UInt32} element to compare.
   *
   * @example
   * ```ts
   * let a = UInt32.from(0b0101);
   * let b = UInt32.from(0b0011);
   *
   * let c = a.xor(b);
   * c.assertEquals(0b0110);
   * ```
   */
  xor(x) {
    return new _UInt32(xor2(this.value, x.value, _UInt32.NUM_BITS));
  }
  /**
   * Bitwise NOT gate on {@link UInt32} elements. Similar to the [bitwise
   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/
   * Web/JavaScript/Reference/Operators/Bitwise_NOT).
   *
   * **Note:** The NOT gate operates over 32 bit for UInt32 types.
   *
   * A NOT gate works by returning `1` in each bit position if the
   * corresponding bit of the operand is `0`, and returning `0` if the
   * corresponding bit of the operand is `1`.
   *
   * NOT is implemented as a subtraction of the input from the all one bitmask.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)
   *
   * @example
   * ```ts
   * // NOTing 4 bits with the unchecked version
   * let a = UInt32.from(0b0101);
   * let b = a.not();
   *
   * console.log(b.toBigInt().toString(2));
   * // 11111111111111111111111111111010
   * ```
   *
   * @param a - The value to apply NOT to.
   */
  not() {
    return new _UInt32(not(this.value, _UInt32.NUM_BITS, false));
  }
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * To safely use `rotate()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)
   *
   * @param bits amount of bits to rotate this {@link UInt32} element with.
   * @param direction left or right rotation direction.
   *
   *
   * @example
   * ```ts
   * const x = UInt32.from(0b001100);
   * const y = x.rotate(2, 'left');
   * const z = x.rotate(2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   * ```
   */
  rotate(bits2, direction = "left") {
    return new _UInt32(rotate32(this.value, bits2, direction));
  }
  /**
   * Performs a left shift operation on the provided {@link UInt32} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   *
   * The operation expects the input to be range checked to 32 bit.
   *
   * @param bits Amount of bits to shift the {@link UInt32} element to the left. The amount should be between 0 and 32 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = UInt32.from(0b001100); // 12 in binary
   * const y = x.leftShift(2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   * ```
   */
  leftShift(bits2) {
    return new _UInt32(leftShift32(this.value, bits2));
  }
  /**
   * Performs a left right operation on the provided {@link UInt32} element.
   * This operation is similar to the `>>` shift operation in JavaScript,
   * where bits are shifted to the right, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   *
   * @param bits Amount of bits to shift the {@link UInt32} element to the right. The amount should be between 0 and 32 (or else the shift will fail).
   *
   * The operation expects the input to be range checked to 32 bit.
   *
   * @example
   * ```ts
   * const x = UInt32.from(0b001100); // 12 in binary
   * const y = x.rightShift(2); // left shift by 2 bits
   * y.assertEquals(0b000011); // 48 in binary
   * ```
   */
  rightShift(bits2) {
    return new _UInt32(rightShift64(this.value, bits2));
  }
  /**
   * Bitwise AND gadget on {@link UInt32} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).
   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.
   *
   * It can be checked by a double generic gate that verifies the following relationship between the values below.
   *
   * The generic gate verifies:\
   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\
   * Where:\
   * `a + b = sum`\
   * `a ^ b = xor`\
   * `a & b = and`
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)
   *
   *
   * @example
   * ```typescript
   * let a = UInt32.from(3);    // ... 000011
   * let b = UInt32.from(5);    // ... 000101
   *
   * let c = a.and(b, 2);    // ... 000001
   * c.assertEquals(1);
   * ```
   */
  and(x) {
    return new _UInt32(and(this.value, x.value, _UInt32.NUM_BITS));
  }
  /**
   * @deprecated Use {@link lessThanOrEqual} instead.
   *
   * Checks if a {@link UInt32} is less than or equal to another one.
   */
  lte(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = isInRangeN(_UInt32.NUM_BITS, xMinusY);
      let yMinusXFits = isInRangeN(_UInt32.NUM_BITS, yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * Checks if a {@link UInt32} is less than or equal to another one.
   */
  lessThanOrEqual(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool4(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = isInRangeN(_UInt32.NUM_BITS, xMinusY);
      let yMinusXFits = isInRangeN(_UInt32.NUM_BITS, yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * @deprecated Use {@link assertLessThanOrEqual} instead.
   *
   * Asserts that a {@link UInt32} is less than or equal to another one.
   */
  assertLte(y, message) {
    this.assertLessThanOrEqual(y, message);
  }
  /**
   * Asserts that a {@link UInt32} is less than or equal to another one.
   */
  assertLessThanOrEqual(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let x0 = this.value.toBigInt();
      let y0 = y.value.toBigInt();
      if (x0 > y0) {
        if (message !== void 0)
          throw Error(message);
        throw Error(`UInt32.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
      }
      return;
    }
    let yMinusX = y.value.sub(this.value).seal();
    rangeCheckN(_UInt32.NUM_BITS, yMinusX, message);
  }
  /**
   * @deprecated Use {@link lessThan} instead.
   *
   * Checks if a {@link UInt32} is less than another one.
   */
  lt(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   * Checks if a {@link UInt32} is less than another one.
   */
  lessThan(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   * @deprecated Use {@link assertLessThan} instead.
   *
   * Asserts that a {@link UInt32} is less than another one.
   */
  assertLt(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * Asserts that a {@link UInt32} is less than another one.
   */
  assertLessThan(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * @deprecated Use {@link greaterThan} instead.
   *
   * Checks if a {@link UInt32} is greater than another one.
   */
  gt(y) {
    return y.lessThan(this);
  }
  /**
   * Checks if a {@link UInt32} is greater than another one.
   */
  greaterThan(y) {
    return y.lessThan(this);
  }
  /**
   * @deprecated Use {@link assertGreaterThan} instead.
   *
   * Asserts that a {@link UInt32} is greater than another one.
   */
  assertGt(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * Asserts that a {@link UInt32} is greater than another one.
   */
  assertGreaterThan(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * @deprecated Use {@link greaterThanOrEqual} instead.
   *
   * Checks if a {@link UInt32} is greater than or equal to another one.
   */
  gte(y) {
    return this.lessThan(y).not();
  }
  /**
   * Checks if a {@link UInt32} is greater than or equal to another one.
   */
  greaterThanOrEqual(y) {
    return this.lessThan(y).not();
  }
  /**
     * @deprecated Use {@link assertGreaterThanOrEqual} instead.
  
     *
     * Asserts that a {@link UInt32} is greater than or equal to another one.
     */
  assertGte(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
  /**
   * Asserts that a {@link UInt32} is greater than or equal to another one.
   */
  assertGreaterThanOrEqual(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
};
UInt322.NUM_BITS = 32;
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Field4)
], UInt322.prototype, "value", void 0);
var Sign3 = class _Sign extends CircuitValue {
  static get one() {
    return new _Sign(Field4(1));
  }
  static get minusOne() {
    return new _Sign(Field4(-1));
  }
  static check(x) {
    x.value.square().assertEquals(Field4(1));
  }
  static empty() {
    return _Sign.one;
  }
  static toInput(x) {
    return { packed: [[x.isPositive().toField(), 1]] };
  }
  static toJSON(x) {
    if (x.toString() === "1")
      return "Positive";
    if (x.neg().toString() === "1")
      return "Negative";
    throw Error(`Invalid Sign: ${x}`);
  }
  static fromJSON(x) {
    return x === "Positive" ? new _Sign(Field4(1)) : new _Sign(Field4(-1));
  }
  neg() {
    return new _Sign(this.value.neg());
  }
  mul(y) {
    return new _Sign(this.value.mul(y.value));
  }
  isPositive() {
    return this.value.equals(Field4(1));
  }
  toString() {
    return this.value.toString();
  }
};
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Field4)
], Sign3.prototype, "value", void 0);
var Int64 = class _Int64 extends CircuitValue {
  // Some thoughts regarding the representation as field elements:
  // toFields returns the in-circuit representation, so the main objective is to minimize the number of constraints
  // that result from this representation. Therefore, I think the only candidate for an efficient 1-field representation
  // is the one where the Int64 is the field: toFields = Int64 => [Int64.magnitude.mul(Int64.sign)]. Anything else involving
  // bit packing would just lead to very inefficient circuit operations.
  //
  // So, is magnitude * sign ("1-field") a more efficient representation than (magnitude, sign) ("2-field")?
  // Several common operations like add, mul, etc, operate on 1-field so in 2-field they result in one additional multiplication
  // constraint per operand. However, the check operation (constraining to 64 bits + a sign) which is called at the introduction
  // of every witness, and also at the end of add, mul, etc, operates on 2-field. So here, the 1-field representation needs
  // to add an additional magnitude * sign = Int64 multiplication constraint, which will typically cancel out most of the gains
  // achieved by 1-field elsewhere.
  // There are some notable operations for which 2-field is definitely better:
  //
  // * div and mod (which do integer division with rounding on the magnitude)
  // * converting the Int64 to a Currency.Amount.Signed (for the zkapp balance), which has the exact same (magnitude, sign) representation we use here.
  //
  // The second point is one of the main things an Int64 is used for, and was the original motivation to use 2 fields.
  // Overall, I think the existing implementation is the optimal one.
  constructor(magnitude, sgn = Sign3.one) {
    super(magnitude, sgn);
  }
  /**
   * Creates a new {@link Int64} from a {@link Field}.
   *
   * Does check if the {@link Field} is within range.
   */
  static fromFieldUnchecked(x) {
    let TWO64 = 1n << 64n;
    let xBigInt = x.toBigInt();
    let isValidPositive = xBigInt < TWO64;
    let isValidNegative = Field4.ORDER - xBigInt < TWO64;
    if (!isValidPositive && !isValidNegative)
      throw Error(`Int64: Expected a value between (-2^64, 2^64), got ${x}`);
    let magnitude = Field4(isValidPositive ? x.toString() : x.neg().toString());
    let sign3 = isValidPositive ? Sign3.one : Sign3.minusOne;
    return new _Int64(new UInt642(magnitude), sign3);
  }
  // this doesn't check ranges because we assume they're already checked on UInts
  /**
   * Creates a new {@link Int64} from a {@link Field}.
   *
   * **Does not** check if the {@link Field} is within range.
   */
  static fromUnsigned(x) {
    return new _Int64(x instanceof UInt322 ? x.toUInt64() : x);
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link Int64}.
   *
   * Check the range if the argument is a constant.
   */
  static from(x) {
    if (x instanceof _Int64)
      return x;
    if (x instanceof UInt642 || x instanceof UInt322) {
      return _Int64.fromUnsigned(x);
    }
    return _Int64.fromFieldUnchecked(Field4(x));
  }
  /**
   * Turns the {@link Int64} into a string.
   */
  toString() {
    let abs2 = this.magnitude.toString();
    let sgn = this.isPositive().toBoolean() || abs2 === "0" ? "" : "-";
    return sgn + abs2;
  }
  isConstant() {
    return this.magnitude.value.isConstant() && this.sgn.isConstant();
  }
  // --- circuit-compatible operations below ---
  // the assumption here is that all Int64 values that appear in a circuit are already checked as valid
  // this is because Provable.witness calls .check, which calls .check on each prop, i.e. UInt64 and Sign
  // so we only have to do additional checks if an operation on valid inputs can have an invalid outcome (example: overflow)
  /**
   * Static method to create a {@link Int64} with value `0`.
   */
  static get zero() {
    return new _Int64(UInt642.zero);
  }
  /**
   * Static method to create a {@link Int64} with value `1`.
   */
  static get one() {
    return new _Int64(UInt642.one);
  }
  /**
   * Static method to create a {@link Int64} with value `-1`.
   */
  static get minusOne() {
    return new _Int64(UInt642.one).neg();
  }
  /**
   * Returns the {@link Field} value.
   */
  toField() {
    return this.magnitude.value.mul(this.sgn.value);
  }
  /**
   * Static method to create a {@link Int64} from a {@link Field}.
   */
  static fromField(x) {
    if (x.isConstant())
      return _Int64.fromFieldUnchecked(x);
    let xInt = Provable.witness(_Int64, () => _Int64.fromFieldUnchecked(x));
    xInt.toField().assertEquals(x);
    return xInt;
  }
  /**
   * Negates the value.
   *
   * `Int64.from(5).neg()` will turn into `Int64.from(-5)`
   */
  neg() {
    return new _Int64(this.magnitude, this.sgn.neg());
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let y_ = _Int64.from(y);
    return _Int64.fromField(this.toField().add(y_.toField()));
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let y_ = _Int64.from(y);
    return _Int64.fromField(this.toField().sub(y_.toField()));
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let y_ = _Int64.from(y);
    return _Int64.fromField(this.toField().mul(y_.toField()));
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `z * y <= x`.
   *
   */
  div(y) {
    let y_ = _Int64.from(y);
    let { quotient } = this.magnitude.divMod(y_.magnitude);
    let sign3 = this.sgn.mul(y_.sgn);
    return new _Int64(quotient, sign3);
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisble by `y`.
   */
  mod(y) {
    let y_ = UInt642.from(y);
    let rest = this.magnitude.divMod(y_).rest.value;
    rest = Provable.if(this.isPositive(), rest, y_.value.sub(rest));
    return new _Int64(new UInt642(rest));
  }
  /**
   * Checks if two values are equal.
   */
  equals(y) {
    let y_ = _Int64.from(y);
    return this.toField().equals(y_.toField());
  }
  /**
   * Asserts that two values are equal.
   */
  assertEquals(y, message) {
    let y_ = _Int64.from(y);
    this.toField().assertEquals(y_.toField(), message);
  }
  /**
   * Checks if the value is positive.
   */
  isPositive() {
    return this.sgn.isPositive();
  }
};
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", UInt642)
], Int64.prototype, "magnitude", void 0);
(0, import_tslib3.__decorate)([
  prop,
  (0, import_tslib3.__metadata)("design:type", Sign3)
], Int64.prototype, "sgn", void 0);
var UInt8 = class _UInt8 extends Struct({
  value: Field4
}) {
  /**
   * Create a {@link UInt8} from a bigint or number.
   * The max value of a {@link UInt8} is `2^8 - 1 = 255`.
   *
   * **Warning**: Cannot overflow past 255, an error is thrown if the result is greater than 255.
   */
  constructor(x) {
    if (x instanceof _UInt8)
      x = x.value.value;
    super({ value: Field4(x) });
    _UInt8.checkConstant(this.value);
  }
  /**
   * Add a {@link UInt8} to another {@link UInt8} without allowing overflow.
   *
   * @example
   * ```ts
   * const x = UInt8.from(3);
   * const sum = x.add(5);
   * sum.assertEquals(8);
   * ```
   *
   * @throws if the result is greater than 255.
   */
  add(y) {
    let z = this.value.add(_UInt8.from(y).value);
    rangeCheck8(z);
    return _UInt8.Unsafe.fromField(z);
  }
  /**
   * Subtract a {@link UInt8} from another {@link UInt8} without allowing underflow.
   *
   * @example
   * ```ts
   * const x = UInt8.from(8);
   * const difference = x.sub(5);
   * difference.assertEquals(3);
   * ```
   *
   * @throws if the result is less than 0.
   */
  sub(y) {
    let z = this.value.sub(_UInt8.from(y).value);
    rangeCheck8(z);
    return _UInt8.Unsafe.fromField(z);
  }
  /**
   * Multiply a {@link UInt8} by another {@link UInt8} without allowing overflow.
   *
   * @example
   * ```ts
   * const x = UInt8.from(3);
   * const product = x.mul(5);
   * product.assertEquals(15);
   * ```
   *
   * @throws if the result is greater than 255.
   */
  mul(y) {
    let z = this.value.mul(_UInt8.from(y).value);
    rangeCheck8(z);
    return _UInt8.Unsafe.fromField(z);
  }
  /**
   * Divide a {@link UInt8} by another {@link UInt8}.
   * This is integer division that rounds down.
   *
   * @example
   * ```ts
   * const x = UInt8.from(7);
   * const quotient = x.div(2);
   * quotient.assertEquals(3);
   * ```
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Get the remainder a {@link UInt8} of division of another {@link UInt8}.
   *
   * @example
   * ```ts
   * const x = UInt8.from(50);
   * const mod = x.mod(30);
   * mod.assertEquals(20);
   * ```
   */
  mod(y) {
    return this.divMod(y).remainder;
  }
  /**
   * Get the quotient and remainder of a {@link UInt8} divided by another {@link UInt8}:
   *
   * `x == y * q + r`, where `0 <= r < y`.
   *
   * @param y - a {@link UInt8} to get the quotient and remainder of another {@link UInt8}.
   *
   * @return The quotient `q` and remainder `r`.
   */
  divMod(y) {
    let x = this.value;
    let y_ = _UInt8.from(y).value.seal();
    if (this.value.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return { quotient: _UInt8.from(q4), remainder: _UInt8.from(r2) };
    }
    let q3 = Provable.witness(Field4, () => Field4(x.toBigInt() / y_.toBigInt()));
    let r = x.sub(q3.mul(y_)).seal();
    rangeCheck16(q3);
    rangeCheck16(r);
    let remainder = _UInt8.Unsafe.fromField(r);
    let quotient = _UInt8.Unsafe.fromField(q3);
    remainder.assertLessThan(y);
    return { quotient, remainder };
  }
  /**
   * Check if this {@link UInt8} is less than or equal to another {@link UInt8} value.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * UInt8.from(3).lessThanOrEqual(UInt8.from(5));
   * ```
   */
  lessThanOrEqual(y) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      return Bool4(this.toBigInt() <= y_.toBigInt());
    }
    throw Error("Not implemented");
  }
  /**
   * Check if this {@link UInt8} is less than another {@link UInt8} value.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * UInt8.from(2).lessThan(UInt8.from(3));
   * ```
   */
  lessThan(y) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      return Bool4(this.toBigInt() < y_.toBigInt());
    }
    throw Error("Not implemented");
  }
  /**
   * Assert that this {@link UInt8} is less than another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThan(y, message) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      let x0 = this.toBigInt();
      let y0 = y_.toBigInt();
      if (x0 >= y0) {
        if (message !== void 0)
          throw Error(message);
        throw Error(`UInt8.assertLessThan: expected ${x0} < ${y0}`);
      }
      return;
    }
    let xPlus1 = new _UInt8(this.value.add(1).value);
    xPlus1.assertLessThanOrEqual(y, message);
  }
  /**
   * Assert that this {@link UInt8} is less than or equal to another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertLessThanOrEqual(y, message) {
    let y_ = _UInt8.from(y);
    if (this.value.isConstant() && y_.value.isConstant()) {
      let x0 = this.toBigInt();
      let y0 = y_.toBigInt();
      if (x0 > y0) {
        if (message !== void 0)
          throw Error(message);
        throw Error(`UInt8.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
      }
      return;
    }
    try {
      let yMinusX = y_.value.sub(this.value).seal();
      rangeCheck16(yMinusX);
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  /**
   * Check if this {@link UInt8} is greater than another {@link UInt8}.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * // 5 > 3
   * UInt8.from(5).greaterThan(3);
   * ```
   */
  greaterThan(y) {
    return _UInt8.from(y).lessThan(this);
  }
  /**
   * Check if this {@link UInt8} is greater than or equal another {@link UInt8} value.
   * Returns a {@link Bool}.
   *
   * @example
   * ```ts
   * // 3 >= 3
   * UInt8.from(3).greaterThanOrEqual(3);
   * ```
   */
  greaterThanOrEqual(y) {
    return _UInt8.from(y).lessThanOrEqual(this);
  }
  /**
   * Assert that this {@link UInt8} is greater than another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThan(y, message) {
    _UInt8.from(y).assertLessThan(this, message);
  }
  /**
   * Assert that this {@link UInt8} is greater than or equal to another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertGreaterThanOrEqual(y, message) {
    _UInt8.from(y).assertLessThanOrEqual(this, message);
  }
  /**
   * Assert that this {@link UInt8} is equal another {@link UInt8} value.
   *
   * **Important**: If an assertion fails, the code throws an error.
   *
   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.
   * @param message? - a string error message to print if the assertion fails, optional.
   */
  assertEquals(y, message) {
    let y_ = _UInt8.from(y);
    this.value.assertEquals(y_.value, message);
  }
  /**
   * Serialize the {@link UInt8} to a string, e.g. for printing.
   *
   * **Warning**: This operation is not provable.
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Serialize the {@link UInt8} to a number.
   *
   * **Warning**: This operation is not provable.
   */
  toNumber() {
    return Number(this.value.toBigInt());
  }
  /**
   * Serialize the {@link UInt8} to a bigint.
   *
   * **Warning**: This operation is not provable.
   */
  toBigInt() {
    return this.value.toBigInt();
  }
  /**
   * {@link Provable.check} for {@link UInt8}.
   * Proves that the input is in the [0, 255] range.
   */
  static check(x) {
    if (x instanceof Field4)
      x = { value: x };
    rangeCheck8(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 8]] };
  }
  /**
   * Turns a {@link UInt8} into a {@link UInt32}.
   */
  toUInt32() {
    return new UInt322(this.value);
  }
  /**
   * Turns a {@link UInt8} into a {@link UInt64}.
   */
  toUInt64() {
    return new UInt642(this.value);
  }
  /**
   * Creates a {@link UInt8} with a value of 255.
   */
  static MAXINT() {
    return new _UInt8((1n << BigInt(_UInt8.NUM_BITS)) - 1n);
  }
  /**
   * Creates a new {@link UInt8}.
   */
  static from(x) {
    if (x instanceof _UInt8)
      return x;
    if (x instanceof UInt642 || x instanceof UInt322 || x instanceof Field4) {
      let xx = x instanceof Field4 ? { value: x } : x;
      _UInt8.check(xx);
      return new _UInt8(xx.value.value);
    }
    return new _UInt8(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return;
    rangeCheck8(x);
  }
};
UInt8.NUM_BITS = 8;
UInt8.Unsafe = {
  /**
   * Create a {@link UInt8} from a {@link Field} without constraining its range.
   *
   * **Warning**: This is unsafe, because it does not prove that the input {@link Field} actually fits in 8 bits.\
   * Only use this if you know what you are doing, otherwise use the safe {@link UInt8.from}.
   */
  fromField(x) {
    return new UInt8(x.value);
  }
};

// dist/node/lib/util/arrays.js
function chunk(array, size) {
  assert3(array.length % size === 0, "invalid input length");
  return Array.from({ length: array.length / size }, (_, i2) => array.slice(size * i2, size * (i2 + 1)));
}
function chunkString(str, size) {
  return chunk([...str], size).map((c) => c.join(""));
}

// dist/node/lib/provable-types/bytes.js
var Bytes = class _Bytes {
  constructor(bytes) {
    let size = this.constructor.size;
    assert3(bytes.length <= size, `Expected at most ${size} bytes, got ${bytes.length}`);
    let padding2 = Array.from({ length: size - bytes.length }, () => new UInt8(0));
    this.bytes = bytes.concat(padding2);
  }
  /**
   * Coerce the input to {@link Bytes}.
   *
   * Inputs smaller than `this.size` are padded with zero bytes.
   */
  static from(data) {
    if (data instanceof _Bytes)
      return data;
    if (this._size === void 0) {
      let Bytes_ = createBytes(data.length);
      return Bytes_.from(data);
    }
    return new this([...data].map(UInt8.from));
  }
  toBytes() {
    return Uint8Array.from(this.bytes.map((x) => x.toNumber()));
  }
  toFields() {
    return this.bytes.map((x) => x.value);
  }
  /**
   * Create {@link Bytes} from a string.
   *
   * Inputs smaller than `this.size` are padded with zero bytes.
   */
  static fromString(s) {
    let bytes = new TextEncoder().encode(s);
    return this.from(bytes);
  }
  /**
   * Create random {@link Bytes} using secure builtin randomness.
   */
  static random() {
    let bytes = randomBytes(this.size);
    return this.from(bytes);
  }
  /**
   * Create {@link Bytes} from a hex string.
   *
   * Inputs smaller than `this.size` are padded with zero bytes.
   */
  static fromHex(xs) {
    let bytes = chunkString(xs, 2).map((s) => parseInt(s, 16));
    return this.from(bytes);
  }
  /**
   * Convert {@link Bytes} to a hex string.
   */
  toHex() {
    return this.bytes.map((x) => x.toBigInt().toString(16).padStart(2, "0")).join("");
  }
  /**
   * The size of the {@link Bytes}.
   */
  static get size() {
    assert3(this._size !== void 0, "Bytes not initialized");
    return this._size;
  }
  get length() {
    return this.bytes.length;
  }
  /**
   * `Provable<Bytes>`
   */
  static get provable() {
    assert3(this._provable !== void 0, "Bytes not initialized");
    return this._provable;
  }
};
function createBytes(size) {
  var _a;
  return _a = class Bytes_ extends Bytes {
  }, _a._size = size, _a._provable = provableFromClass(_a, {
    bytes: Provable.Array(UInt8, size)
  }), _a;
}

// dist/node/lib/provable-types/provable-types.js
function Bytes2(size) {
  return createBytes(size);
}
Bytes2.from = Bytes.from;
Bytes2.fromHex = Bytes.fromHex;
Bytes2.fromString = Bytes.fromString;

// dist/node/lib/gadgets/bit-slices.js
function bytesToWord(wordBytes) {
  return wordBytes.reduce((acc, byte, idx) => {
    const shift3 = 1n << BigInt(8 * idx);
    return acc.add(byte.value.mul(shift3));
  }, Field3.from(0));
}
function wordToBytes(word, bytesPerWord = 8) {
  let bytes = Provable.witness(Provable.Array(UInt8, bytesPerWord), () => {
    let w = word.toBigInt();
    return Array.from({ length: bytesPerWord }, (_, k) => UInt8.from(w >> BigInt(8 * k) & 0xffn));
  });
  bytesToWord(bytes).assertEquals(word);
  return bytes;
}
function wordsToBytes(words, bytesPerWord = 8) {
  return words.flatMap((w) => wordToBytes(w, bytesPerWord));
}
function bytesToWords(bytes, bytesPerWord = 8) {
  return chunk(bytes, bytesPerWord).map(bytesToWord);
}
function sliceField3([x0, x1, x2], { maxBits, chunkSize }) {
  let l_ = Number(l);
  assert3(maxBits <= 3 * l_, `expected max bits <= 3*${l_}, got ${maxBits}`);
  let result0 = sliceField(x0, Math.min(l_, maxBits), chunkSize);
  if (maxBits <= l_)
    return result0.chunks;
  maxBits -= l_;
  let result1 = sliceField(x1, Math.min(l_, maxBits), chunkSize, result0);
  if (maxBits <= l_)
    return result0.chunks.concat(result1.chunks);
  maxBits -= l_;
  let result2 = sliceField(x2, maxBits, chunkSize, result1);
  return result0.chunks.concat(result1.chunks, result2.chunks);
}
function sliceField(x, maxBits, chunkSize, leftover) {
  let bits2 = exists(maxBits, () => {
    let bits3 = bigIntToBits(x.toBigInt());
    if (bits3.length > maxBits)
      bits3 = bits3.slice(0, maxBits);
    if (bits3.length < maxBits)
      bits3 = bits3.concat(Array(maxBits - bits3.length).fill(false));
    return bits3.map(BigInt);
  });
  let chunks = [];
  let sum2 = Field3.from(0n);
  if (leftover !== void 0) {
    let { chunks: previous, leftoverSize: size } = leftover;
    let remainingChunk = Field3.from(0n);
    for (let i3 = 0; i3 < size; i3++) {
      let bit = bits2[i3];
      Bool3.check(Bool3.Unsafe.ofField(bit));
      remainingChunk = remainingChunk.add(bit.mul(1n << BigInt(i3)));
    }
    sum2 = remainingChunk = remainingChunk.seal();
    let chunk2 = previous[previous.length - 1];
    previous[previous.length - 1] = chunk2.add(remainingChunk.mul(1n << BigInt(chunkSize - size)));
  }
  let i2 = leftover?.leftoverSize ?? 0;
  for (; i2 < maxBits; i2 += chunkSize) {
    let chunk2 = Field3.from(0n);
    let size = Math.min(maxBits - i2, chunkSize);
    for (let j = 0; j < size; j++) {
      let bit = bits2[i2 + j];
      Bool3.check(Bool3.Unsafe.ofField(bit));
      chunk2 = chunk2.add(bit.mul(1n << BigInt(j)));
    }
    chunk2 = chunk2.seal();
    sum2 = sum2.add(chunk2.mul(1n << BigInt(i2)));
    chunks.push(chunk2);
  }
  sum2.assertEquals(x);
  let leftoverSize = i2 - maxBits;
  return { chunks, leftoverSize };
}

// dist/node/lib/gadgets/sha256.js
var SHA256Constants = {
  // constants §4.2.2
  K: [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ],
  // initial hash values §5.3.3
  H: [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]
};
function padding(data) {
  let message = Bytes2.from(data);
  let l4 = message.length * 8;
  let k = Number(mod(448n - (BigInt(l4) + 1n), 512n));
  let lBinary = l4.toString(2);
  let paddingBits = ("1" + // append 1 bit
  "0".repeat(k) + // append k zero bits
  "0".repeat(64 - lBinary.length) + // append 64bit containing the length of the original message
  lBinary).match(/.{1,8}/g);
  let padding2 = paddingBits.map((x) => UInt8.from(BigInt("0b" + x)));
  let paddedMessage = message.bytes.concat(padding2);
  let chunks = [];
  for (let i2 = 0; i2 < paddedMessage.length; i2 += 4) {
    chunks.push(UInt322.from(bytesToWord(paddedMessage.slice(i2, i2 + 4).reverse())));
  }
  return chunk(chunks, 16);
}
var SHA256 = {
  hash(data) {
    let messageBlocks = padding(data);
    const H = SHA256Constants.H.map((x) => UInt322.from(x));
    const K = SHA256Constants.K.map((x) => UInt322.from(x));
    const N = messageBlocks.length;
    for (let i2 = 0; i2 < N; i2++) {
      const M = messageBlocks[i2];
      const W = [];
      for (let t = 0; t <= 15; t++)
        W[t] = M[t];
      for (let t = 16; t <= 63; t++) {
        let unreduced = DeltaOne(W[t - 2]).value.add(W[t - 7].value).add(DeltaZero(W[t - 15]).value.add(W[t - 16].value));
        W[t] = UInt322.from(divMod32(unreduced, 16).remainder);
      }
      let a2 = H[0];
      let b2 = H[1];
      let c = H[2];
      let d = H[3];
      let e = H[4];
      let f = H[5];
      let g = H[6];
      let h = H[7];
      for (let t = 0; t <= 63; t++) {
        const unreducedT1 = h.value.add(SigmaOne(e).value).add(Ch(e, f, g).value).add(K[t].value).add(W[t].value).seal();
        const unreducedT2 = SigmaZero(a2).value.add(Maj(a2, b2, c).value);
        h = g;
        g = f;
        f = e;
        e = UInt322.from(divMod32(d.value.add(unreducedT1), 16).remainder);
        d = c;
        c = b2;
        b2 = a2;
        a2 = UInt322.from(divMod32(unreducedT2.add(unreducedT1), 16).remainder);
      }
      H[0] = H[0].addMod32(a2);
      H[1] = H[1].addMod32(b2);
      H[2] = H[2].addMod32(c);
      H[3] = H[3].addMod32(d);
      H[4] = H[4].addMod32(e);
      H[5] = H[5].addMod32(f);
      H[6] = H[6].addMod32(g);
      H[7] = H[7].addMod32(h);
    }
    return Bytes2.from(H.map((x) => wordToBytes(x.value, 4).reverse()).flat());
  }
};
function Ch(x, y, z) {
  let xAndY = x.and(y).value;
  let xNotAndZ = x.not().and(z).value;
  let ch = xAndY.add(xNotAndZ).seal();
  return UInt322.from(ch);
}
function Maj(x, y, z) {
  let sum2 = x.value.add(y.value).add(z.value).seal();
  let xor4 = x.xor(y).xor(z).value;
  let maj = sum2.sub(xor4).div(2).seal();
  return UInt322.from(maj);
}
function SigmaZero(x) {
  return sigma(x, [2, 13, 22]);
}
function SigmaOne(x) {
  return sigma(x, [6, 11, 25]);
}
function DeltaZero(x) {
  return sigma(x, [3, 7, 18], true);
}
function DeltaOne(x) {
  return sigma(x, [10, 17, 19], true);
}
function ROTR(n, x) {
  return x.rotate(n, "right");
}
function SHR(n, x) {
  let val = x.rightShift(n);
  return val;
}
function sigmaSimple(u, bits2, firstShifted = false) {
  let [r0, r1, r2] = bits2;
  let rot0 = firstShifted ? SHR(r0, u) : ROTR(r0, u);
  let rot1 = ROTR(r1, u);
  let rot2 = ROTR(r2, u);
  return rot0.xor(rot1).xor(rot2);
}
function sigma(u, bits2, firstShifted = false) {
  if (u.isConstant())
    return sigmaSimple(u, bits2, firstShifted);
  let [r0, r1, r2] = bits2;
  let x = u.value;
  let d0 = r0;
  let d1 = r1 - r0;
  let d2 = r2 - r1;
  let d3 = 32 - r2;
  let [x0, x1, x2, x3] = exists(4, () => {
    let xx = x.toBigInt();
    return [
      bitSlice(xx, 0, d0),
      bitSlice(xx, r0, d1),
      bitSlice(xx, r1, d2),
      bitSlice(xx, r2, d3)
    ];
  });
  rangeCheck16(x0);
  rangeCheck16(x1);
  rangeCheck16(x2);
  rangeCheck16(x3);
  let x23 = x2.add(x3.mul(1 << d2)).seal();
  let x123 = x1.add(x23.mul(1 << d1)).seal();
  x0.add(x123.mul(1 << d0)).assertEquals(x);
  let xRotR0;
  if (!firstShifted) {
    xRotR0 = x123.add(x0.mul(1 << d1 + d2 + d3)).seal();
  } else {
    xRotR0 = x123;
    rangeCheck16(x0.mul(1 << 16 - d0).seal());
  }
  let x01 = x0.add(x1.mul(1 << d0)).seal();
  let xRotR1 = x23.add(x01.mul(1 << d2 + d3)).seal();
  let x012 = x01.add(x2.mul(1 << d0 + d1)).seal();
  let xRotR2 = x3.add(x012.mul(1 << d3)).seal();
  return UInt322.from(xRotR0).xor(new UInt322(xRotR1)).xor(new UInt322(xRotR2));
}

// dist/node/lib/gadgets/gadgets.js
var Gadgets = {
  /**
   * Asserts that the input value is in the range [0, 2^64).
   *
   * This function proves that the provided field element can be represented with 64 bits.
   * If the field element exceeds 64 bits, an error is thrown.
   *
   * @param x - The value to be range-checked.
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * Gadgets.rangeCheck64(x); // successfully proves 64-bit range
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rangeCheck64(xLarge); // throws an error since input exceeds 64 bits
   * ```
   *
   * **Note**: Small "negative" field element inputs are interpreted as large integers close to the field size,
   * and don't pass the 64-bit check. If you want to prove that a value lies in the int64 range [-2^63, 2^63),
   * you could use `rangeCheck64(x.add(1n << 63n))`.
   */
  rangeCheck64(x) {
    return rangeCheck64(x);
  },
  /**
   * Asserts that the input value is in the range [0, 2^32).
   *
   * This function proves that the provided field element can be represented with 32 bits.
   * If the field element exceeds 32 bits, an error is thrown.
   *
   * @param x - The value to be range-checked.
   *
   * @throws Throws an error if the input value exceeds 32 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * Gadgets.rangeCheck32(x); // successfully proves 32-bit range
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rangeCheck32(xLarge); // throws an error since input exceeds 32 bits
   * ```
   *
   * **Note**: Small "negative" field element inputs are interpreted as large integers close to the field size,
   * and don't pass the 32-bit check. If you want to prove that a value lies in the int32 range [-2^31, 2^31),
   * you could use `rangeCheck32(x.add(1n << 31n))`.
   */
  rangeCheck32(x) {
    return rangeCheck32(x);
  },
  /**
   * Asserts that the input value is in the range [0, 2^n). `n` must be a multiple of 16.
   *
   * This function proves that the provided field element can be represented with `n` bits.
   * If the field element exceeds `n` bits, an error is thrown.
   *
   * @param x - The value to be range-checked.
   * @param n - The number of bits to be considered for the range check.
   * @param message - Optional message to be displayed when the range check fails.
   *
   * @throws Throws an error if the input value exceeds `n` bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * Gadgets.rangeCheckN(32, x); // successfully proves 32-bit range
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rangeCheckN(32, xLarge); // throws an error since input exceeds 32 bits
   * ```
   */
  rangeCheckN(n, x, message) {
    return rangeCheckN(n, x, message);
  },
  /**
   * Checks whether the input value is in the range [0, 2^n). `n` must be a multiple of 16.
   *
   * This function proves that the provided field element can be represented with `n` bits.
   * If the field element exceeds `n` bits, `Bool(false)` is returned and `Bool(true)` otherwise.
   *
   * @param x - The value to be range-checked.
   * @param n - The number of bits to be considered for the range check.
   *
   * @returns a Bool indicating whether the input value is in the range [0, 2^n).
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(12345678n));
   * let inRange = Gadgets.isInRangeN(32, x); // return Bool(true)
   * ```
   */
  isInRangeN(n, x) {
    return isInRangeN(n, x);
  },
  /*
   * Asserts that the input value is in the range [0, 2^16).
   *
   * See {@link Gadgets.rangeCheck64} for analogous details and usage examples.
   */
  rangeCheck16(x) {
    return rangeCheck16(x);
  },
  /**
   * Asserts that the input value is in the range [0, 2^8).
   *
   * See {@link Gadgets.rangeCheck64} for analogous details and usage examples.
   */
  rangeCheck8(x) {
    return rangeCheck8(x);
  },
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * **Important:** The gadget assumes that its input is at most 64 bits in size.
   *
   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the rotation.
   * To safely use `rotate64()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)
   *
   * @param field {@link Field} element to rotate.
   * @param bits amount of bits to rotate this {@link Field} element with.
   * @param direction left or right rotation direction.
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100));
   * const y = Gadgets.rotate64(x, 2, 'left'); // left rotation by 2 bits
   * const z = Gadgets.rotate64(x, 2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rotate64(xLarge, 32, "left"); // throws an error since input exceeds 64 bits
   * ```
   */
  rotate64(field, bits2, direction = "left") {
    return rotate64(field, bits2, direction);
  },
  /**
   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,
   * with the distinction that the bits are circulated to the opposite end of a 32-bit representation rather than being discarded.
   * For a left rotation, this means that bits shifted off the left end reappear at the right end.
   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.
   *
   * **Important:** The gadget assumes that its input is at most 32 bits in size.
   *
   * If the input exceeds 32 bits, the gadget is invalid and fails to prove correct execution of the rotation.
   * To safely use `rotate32()`, you need to make sure that the value passed in is range-checked to 32 bits;
   * for example, using {@link Gadgets.rangeCheck32}.
   *
   *
   * @param field {@link Field} element to rotate.
   * @param bits amount of bits to rotate this {@link Field} element with.
   * @param direction left or right rotation direction.
   *
   * @throws Throws an error if the input value exceeds 32 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100));
   * const y = Gadgets.rotate32(x, 2, 'left'); // left rotation by 2 bits
   * const z = Gadgets.rotate32(x, 2, 'right'); // right rotation by 2 bits
   * y.assertEquals(0b110000);
   * z.assertEquals(0b000011);
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * Gadgets.rotate32(xLarge, 32, "left"); // throws an error since input exceeds 32 bits
   * ```
   */
  rotate32(field, bits2, direction = "left") {
    return rotate32(field, bits2, direction);
  },
  /**
   * Bitwise XOR gadget on {@link Field} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).
   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.
   *
   * This gadget builds a chain of XOR gates recursively. Each XOR gate can verify 16 bit at most. If your input elements exceed 16 bit, another XOR gate will be added to the chain.
   *
   * The `length` parameter lets you define how many bits should be compared. `length` is rounded to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`, and both input values are constrained to fit into `paddedLength` bits. The output is guaranteed to have at most `paddedLength` bits as well.
   *
   * **Note:** Specifying a larger `length` parameter adds additional constraints.
   *
   * It is also important to mention that specifying a smaller `length` allows the verifier to infer the length of the original input data (e.g. smaller than 16 bit if only one XOR gate has been used).
   * A zkApp developer should consider these implications when choosing the `length` parameter and carefully weigh the trade-off between increased amount of constraints and security.
   *
   * **Important:** Both {@link Field} elements need to fit into `2^paddedLength - 1`. Otherwise, an error is thrown and no proof can be generated.
   *
   * For example, with `length = 2` (`paddedLength = 16`), `xor()` will fail for any input that is larger than `2**16`.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)
   *
   * @param a {@link Field} element to compare.
   * @param b {@link Field} element to compare.
   * @param length amount of bits to compare.
   *
   * @throws Throws an error if the input values exceed `2^paddedLength - 1`.
   *
   * @example
   * ```ts
   * let a = Field(0b0101);
   * let b = Field(0b0011);
   *
   * let c = Gadgets.xor(a, b, 4); // xor-ing 4 bits
   * c.assertEquals(0b0110);
   * ```
   */
  xor(a2, b2, length) {
    return xor2(a2, b2, length);
  },
  /**
   * Bitwise NOT gate on {@link Field} elements. Similar to the [bitwise
   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/
   * Web/JavaScript/Reference/Operators/Bitwise_NOT).
   *
   * **Note:** The NOT gate only operates over the amount
   * of bits specified by the `length` parameter.
   *
   * A NOT gate works by returning `1` in each bit position if the
   * corresponding bit of the operand is `0`, and returning `0` if the
   * corresponding bit of the operand is `1`.
   *
   * The `length` parameter lets you define how many bits to NOT.
   *
   * **Note:** Specifying a larger `length` parameter adds additional constraints. The operation will fail if the length or the input value is larger than 254.
   *
   * NOT is implemented in two different ways. If the `checked` parameter is set to `true`
   * the {@link Gadgets.xor} gadget is reused with a second argument to be an
   * all one bitmask the same length. This approach needs as many rows as an XOR would need
   * for a single negation. If the `checked` parameter is set to `false`, NOT is
   * implemented as a subtraction of the input from the all one bitmask. This
   * implementation is returned by default if no `checked` parameter is provided.
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)
   *
   * @example
   * ```ts
   * // not-ing 4 bits with the unchecked version
   * let a = Field(0b0101);
   * let b = Gadgets.not(a,4,false);
   *
   * b.assertEquals(0b1010);
   *
   * // not-ing 4 bits with the checked version utilizing the xor gadget
   * let a = Field(0b0101);
   * let b = Gadgets.not(a,4,true);
   *
   * b.assertEquals(0b1010);
   * ```
   *
   * @param a - The value to apply NOT to. The operation will fail if the value is larger than 254.
   * @param length - The number of bits to be considered for the NOT operation.
   * @param checked - Optional boolean to determine if the checked or unchecked not implementation is used. If it
   * is set to `true` the {@link Gadgets.xor} gadget is reused. If it is set to `false`, NOT is implemented
   *  as a subtraction of the input from the all one bitmask. It is set to `false` by default if no parameter is provided.
   *
   * @throws Throws an error if the input value exceeds 254 bits.
   */
  not(a2, length, checked = false) {
    return not(a2, length, checked);
  },
  /**
   * Performs a left shift operation on the provided {@link Field} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * **Important:** The gadgets assumes that its input is at most 64 bits in size.
   *
   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the shift.
   * Therefore, to safely use `leftShift()`, you need to make sure that the values passed in are range checked to 64 bits.
   * For example, this can be done with {@link Gadgets.rangeCheck64}.
   *
   * @param field {@link Field} element to shift.
   * @param bits Amount of bits to shift the {@link Field} element to the left. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
   * const y = Gadgets.leftShift64(x, 2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * leftShift64(xLarge, 32); // throws an error since input exceeds 64 bits
   * ```
   */
  leftShift64(field, bits2) {
    return leftShift64(field, bits2);
  },
  /**
   * Performs a left shift operation on the provided {@link Field} element.
   * This operation is similar to the `<<` shift operation in JavaScript,
   * where bits are shifted to the left, and the overflowing bits are discarded.
   *
   * It’s important to note that these operations are performed considering the big-endian 32-bit representation of the number,
   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.
   *
   * **Important:** The gadgets assumes that its input is at most 32 bits in size.
   *
   * The output is range checked to 32 bits.
   *
   * @param field {@link Field} element to shift.
   * @param bits Amount of bits to shift the {@link Field} element to the left. The amount should be between 0 and 32 (or else the shift will fail).
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
   * const y = Gadgets.leftShift32(x, 2); // left shift by 2 bits
   * y.assertEquals(0b110000); // 48 in binary
   * ```
   */
  leftShift32(field, bits2) {
    return leftShift32(field, bits2);
  },
  /**
   * Performs a right shift operation on the provided {@link Field} element.
   * This is similar to the `>>` shift operation in JavaScript, where bits are moved to the right.
   * The `rightShift64` function utilizes the rotation method internally to implement this operation.
   *
   * * It’s important to note that these operations are performed considering the big-endian 64-bit representation of the number,
   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
   *
   * **Important:** The gadgets assumes that its input is at most 64 bits in size.
   *
   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the shift.
   * To safely use `rightShift64()`, you need to make sure that the value passed in is range-checked to 64 bits;
   * for example, using {@link Gadgets.rangeCheck64}.
   *
   * @param field {@link Field} element to shift.
   * @param bits Amount of bits to shift the {@link Field} element to the right. The amount should be between 0 and 64 (or else the shift will fail).
   *
   * @throws Throws an error if the input value exceeds 64 bits.
   *
   * @example
   * ```ts
   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
   * const y = Gadgets.rightShift64(x, 2); // right shift by 2 bits
   * y.assertEquals(0b000011); // 3 in binary
   *
   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
   * rightShift64(xLarge, 32); // throws an error since input exceeds 64 bits
   * ```
   */
  rightShift64(field, bits2) {
    return rightShift64(field, bits2);
  },
  /**
   * Bitwise AND gadget on {@link Field} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).
   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.
   *
   * It can be checked by a double generic gate that verifies the following relationship between the values below (in the process it also invokes the {@link Gadgets.xor} gadget which will create additional constraints depending on `length`).
   *
   * The generic gate verifies:\
   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\
   * Where:\
   * `a + b = sum`\
   * `a ^ b = xor`\
   * `a & b = and`
   *
   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)
   *
   * The `length` parameter lets you define how many bits should be compared. `length` is rounded to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`, and both input values are constrained to fit into `paddedLength` bits. The output is guaranteed to have at most `paddedLength` bits as well.
   *
   * **Note:** Specifying a larger `length` parameter adds additional constraints.
   *
   * **Note:** Both {@link Field} elements need to fit into `2^paddedLength - 1`. Otherwise, an error is thrown and no proof can be generated.
   * For example, with `length = 2` (`paddedLength = 16`), `and()` will fail for any input that is larger than `2**16`.
   *
   * @example
   * ```typescript
   * let a = Field(3);    // ... 000011
   * let b = Field(5);    // ... 000101
   *
   * let c = Gadgets.and(a, b, 2);    // ... 000001
   * c.assertEquals(1);
   * ```
   */
  and(a2, b2, length) {
    return and(a2, b2, length);
  },
  /**
   * Multi-range check.
   *
   * Proves that x, y, z are all in the range [0, 2^88).
   *
   * This takes 4 rows, so it checks 88*3/4 = 66 bits per row. This is slightly more efficient
   * than 64-bit range checks, which can do 64 bits in 1 row.
   *
   * In particular, the 3x88-bit range check supports bigints up to 264 bits, which in turn is enough
   * to support foreign field multiplication with moduli up to 2^259.
   *
   * @example
   * ```ts
   * Gadgets.multiRangeCheck([x, y, z]);
   * ```
   *
   * @throws Throws an error if one of the input values exceeds 88 bits.
   */
  multiRangeCheck(limbs) {
    multiRangeCheck(limbs);
  },
  /**
   * Compact multi-range check
   *
   * This is a variant of {@link multiRangeCheck} where the first two variables are passed in
   * combined form xy = x + 2^88*y.
   *
   * The gadget
   * - splits up xy into x and y
   * - proves that xy = x + 2^88*y
   * - proves that x, y, z are all in the range [0, 2^88).
   *
   * The split form [x, y, z] is returned.
   *
   * @example
   * ```ts
   * let [x, y] = Gadgets.compactMultiRangeCheck([xy, z]);
   * ```
   *
   * @throws Throws an error if `xy` exceeds 2*88 = 176 bits, or if z exceeds 88 bits.
   */
  compactMultiRangeCheck(xy, z) {
    return compactMultiRangeCheck(xy, z);
  },
  /**
   * Gadgets for foreign field operations.
   *
   * A _foreign field_ is a finite field different from the native field of the proof system.
   *
   * The `ForeignField` namespace exposes operations like modular addition and multiplication,
   * which work for any finite field of size less than 2^259.
   *
   * Foreign field elements are represented as 3 limbs of native field elements.
   * Each limb holds 88 bits of the total, in little-endian order.
   *
   * All `ForeignField` gadgets expect that their input limbs are constrained to the range [0, 2^88).
   * Range checks on outputs are added by the gadget itself.
   */
  ForeignField: {
    /**
     * Foreign field addition: `x + y mod f`
     *
     * The modulus `f` does not need to be prime.
     *
     * Inputs and outputs are 3-tuples of native Fields.
     * Each input limb is assumed to be in the range [0, 2^88), and the gadget is invalid if this is not the case.
     * The result limbs are guaranteed to be in the same range.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3.provable, () => Field3.from(9n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(10n));
     *
     * // range check x and y
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     *
     * // compute x + y mod 17
     * let z = ForeignField.add(x, y, 17n);
     *
     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = 9 + 10 mod 17
     * ```
     *
     * **Warning**: The gadget does not assume that inputs are reduced modulo f,
     * and does not prove that the result is reduced modulo f.
     * It only guarantees that the result is in the correct residue class.
     *
     * @param x left summand
     * @param y right summand
     * @param f modulus
     * @returns x + y mod f
     */
    add(x, y, f) {
      return ForeignField.add(x, y, f);
    },
    /**
     * Foreign field subtraction: `x - y mod f`
     *
     * See {@link Gadgets.ForeignField.add} for assumptions and usage examples.
     *
     * @throws fails if `x - y < -f`, where the result cannot be brought back to a positive number by adding `f` once.
     */
    sub(x, y, f) {
      return ForeignField.sub(x, y, f);
    },
    /**
     * Foreign field negation: `-x mod f = f - x`
     *
     * See {@link ForeignField.add} for assumptions and usage examples.
     *
     * @throws fails if `x > f`, where `f - x < 0`.
     */
    neg(x, f) {
      return ForeignField.negate(x, f);
    },
    /**
     * Foreign field sum: `xs[0] + signs[0] * xs[1] + ... + signs[n-1] * xs[n] mod f`
     *
     * This gadget takes a list of inputs and a list of signs (of size one less than the inputs),
     * and computes a chain of additions or subtractions, depending on the sign.
     * A sign is of type `1n | -1n`, where `1n` represents addition and `-1n` represents subtraction.
     *
     * **Note**: For 3 or more inputs, `sum()` uses fewer constraints than a sequence of `add()` and `sub()` calls,
     * because we can avoid range checks on intermediate results.
     *
     * See {@link Gadgets.ForeignField.add} for assumptions on inputs.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3.provable, () => Field3.from(4n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(5n));
     * let z = Provable.witness(Field3.provable, () => Field3.from(10n));
     *
     * // range check x, y, z
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     * Gadgets.multiRangeCheck(z);
     *
     * // compute x + y - z mod 17
     * let sum = ForeignField.sum([x, y, z], [1n, -1n], 17n);
     *
     * Provable.log(sum); // ['16', '0', '0'] = limb representation of 16 = 4 + 5 - 10 mod 17
     * ```
     */
    sum(xs, signs, f) {
      return ForeignField.sum(xs, signs, f);
    },
    /**
     * Foreign field multiplication: `x * y mod f`
     *
     * The modulus `f` does not need to be prime, but has to be smaller than 2^259.
     *
     * **Assumptions**: In addition to the assumption that input limbs are in the range [0, 2^88), as in all foreign field gadgets,
     * this assumes an additional bound on the inputs: `x * y < 2^264 * p`, where p is the native modulus.
     * We usually assert this bound by proving that `x[2] < f[2] + 1`, where `x[2]` is the most significant limb of x.
     * To do this, we use an 88-bit range check on `2^88 - x[2] - (f[2] + 1)`, and same for y.
     * The implication is that x and y are _almost_ reduced modulo f.
     *
     * All of the above assumptions are checked by {@link Gadgets.ForeignField.assertAlmostReduced}.
     *
     * **Warning**: This gadget does not add the extra bound check on the result.
     * So, to use the result in another foreign field multiplication, you have to add the bound check on it yourself, again.
     *
     * @example
     * ```ts
     * // example modulus: secp256k1 prime
     * let f = (1n << 256n) - (1n << 32n) - 0b1111010001n;
     *
     * let x = Provable.witness(Field3.provable, () => Field3.from(f - 1n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(f - 2n));
     *
     * // range check x, y and prove additional bounds x[2] <= f[2]
     * ForeignField.assertAlmostReduced([x, y], f);
     *
     * // compute x * y mod f
     * let z = ForeignField.mul(x, y, f);
     *
     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = (-1)*(-2) mod f
     * ```
     */
    mul(x, y, f) {
      return ForeignField.mul(x, y, f);
    },
    /**
     * Foreign field inverse: `x^(-1) mod f`
     *
     * See {@link Gadgets.ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     */
    inv(x, f) {
      return ForeignField.inv(x, f);
    },
    /**
     * Foreign field division: `x * y^(-1) mod f`
     *
     * See {@link Gadgets.ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     *
     * @throws Different than {@link Gadgets.ForeignField.mul}, this fails on unreduced input `x`, because it checks that `x === (x/y)*y` and the right side will be reduced.
     */
    div(x, y, f) {
      return ForeignField.div(x, y, f);
    },
    /**
     * Optimized multiplication of sums in a foreign field, for example: `(x - y)*z = a + b + c mod f`
     *
     * Note: This is much more efficient than using {@link Gadgets.ForeignField.add} and {@link Gadgets.ForeignField.sub} separately to
     * compute the multiplication inputs and outputs, and then using {@link Gadgets.ForeignField.mul} to constrain the result.
     *
     * The sums passed into this method are "lazy sums" created with {@link Gadgets.ForeignField.Sum}.
     * You can also pass in plain {@link Field3} elements.
     *
     * **Assumptions**: The assumptions on the _summands_ are analogous to the assumptions described in {@link Gadgets.ForeignField.mul}:
     * - each summand's limbs are in the range [0, 2^88)
     * - summands that are part of a multiplication input satisfy `x[2] <= f[2]`
     *
     * @throws if the modulus is so large that the second assumption no longer suffices for validity of the multiplication.
     * For small sums and moduli < 2^256, this will not fail.
     *
     * @throws if the provided multiplication result is not correct modulo f.
     *
     * @example
     * ```ts
     * // range-check x, y, z, a, b, c
     * ForeignField.assertAlmostReduced([x, y, z], f);
     * Gadgets.multiRangeCheck(a);
     * Gadgets.multiRangeCheck(b);
     * Gadgets.multiRangeCheck(c);
     *
     * // create lazy input sums
     * let xMinusY = ForeignField.Sum(x).sub(y);
     * let aPlusBPlusC = ForeignField.Sum(a).add(b).add(c);
     *
     * // assert that (x - y)*z = a + b + c mod f
     * ForeignField.assertMul(xMinusY, z, aPlusBPlusC, f);
     * ```
     */
    assertMul(x, y, z, f) {
      return ForeignField.assertMul(x, y, z, f);
    },
    /**
     * Lazy sum of {@link Field3} elements, which can be used as input to {@link Gadgets.ForeignField.assertMul}.
     */
    Sum(x) {
      return ForeignField.Sum(x);
    },
    /**
     * Prove that each of the given {@link Field3} elements is "almost" reduced modulo f,
     * i.e., satisfies the assumptions required by {@link Gadgets.ForeignField.mul} and other gadgets:
     * - each limb is in the range [0, 2^88)
     * - the most significant limb is less or equal than the modulus, x[2] <= f[2]
     *
     * **Note**: This method is most efficient when the number of input elements is a multiple of 3.
     *
     * @throws if any of the assumptions is violated.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3.provable, () => Field3.from(4n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(5n));
     * let z = Provable.witness(Field3.provable, () => Field3.from(10n));
     *
     * ForeignField.assertAlmostReduced([x, y, z], f);
     *
     * // now we can use x, y, z as inputs to foreign field multiplication
     * let xy = ForeignField.mul(x, y, f);
     * let xyz = ForeignField.mul(xy, z, f);
     *
     * // since xy is an input to another multiplication, we need to prove that it is almost reduced again!
     * ForeignField.assertAlmostReduced([xy], f); // TODO: would be more efficient to batch this with 2 other elements
     * ```
     */
    assertAlmostReduced(xs, f, { skipMrc = false } = {}) {
      ForeignField.assertAlmostReduced(xs, f, skipMrc);
    },
    /**
     * Prove that x < f for any constant f < 2^264.
     *
     * If f is a finite field modulus, this means that the given field element is fully reduced modulo f.
     * This is a stronger statement than {@link ForeignField.assertAlmostReduced}
     * and also uses more constraints; it should not be needed in most use cases.
     *
     * **Note**: This assumes that the limbs of x are in the range [0, 2^88), in contrast to
     * {@link ForeignField.assertAlmostReduced} which adds that check itself.
     *
     * @throws if x is greater or equal to f.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3.provable, () => Field3.from(0x1235n));
     *
     *  // range check limbs of x
     * Gadgets.multiRangeCheck(x);
     *
     * // prove that x is fully reduced mod f
     * Gadgets.ForeignField.assertLessThan(x, f);
     * ```
     */
    assertLessThan(x, f) {
      ForeignField.assertLessThan(x, f);
    }
  },
  /**
   * Helper methods to interact with 3-limb vectors of Fields.
   *
   * **Note:** This interface does not contain any provable methods.
   */
  Field3: Field32,
  /**
   * Division modulo 2^32. The operation decomposes a {@link Field} element in the range [0, 2^64) into two 32-bit limbs, `remainder` and `quotient`, using the following equation: `n = quotient * 2^32 + remainder`.
   *
   * **Note:** The gadget acts as a proof that the input is in the range [0, 2^64). If the input exceeds 64 bits, the gadget fails.
   *
   * Asserts that both `remainder` and `quotient` are in the range [0, 2^32) using {@link Gadgets.rangeCheck32}.
   *
   * @example
   * ```ts
   * let n = Field((1n << 32n) + 8n)
   * let { remainder, quotient } = Gadgets.divMod32(n);
   * // remainder = 8, quotient = 1
   *
   * n.assertEquals(quotient.mul(1n << 32n).add(remainder));
   * ```
   */
  divMod32,
  /**
   * Addition modulo 2^32. The operation adds two {@link Field} elements in the range [0, 2^64] and returns the result modulo 2^32.
   *
   * Asserts that the result is in the range [0, 2^32) using {@link Gadgets.rangeCheck32}.
   *
   * It uses {@link Gadgets.divMod32} internally by adding the two {@link Field} elements and then decomposing the result into `remainder` and `quotient` and returning the `remainder`.
   *
   * **Note:** The gadget assumes both inputs to be in the range [0, 2^64). When called with non-range-checked inputs, be aware that the sum `a + b` can overflow the native field and the gadget can succeed but return an invalid result.
   *
   * @example
   * ```ts
   * let a = Field(8n);
   * let b = Field(1n << 32n);
   *
   * Gadgets.addMod32(a, b).assertEquals(Field(8n));
   * ```
   *    */
  addMod32,
  /**
   * Implementation of the [SHA256 hash function.](https://en.wikipedia.org/wiki/SHA-2) Hash function with 256bit output.
   *
   * Applies the SHA2-256 hash function to a list of byte-sized elements.
   *
   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]`, `bigint[]` or `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} that conforms to the chosen bit length.
   *
   * @param data - {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest = Gadgets.SHA256.hash(preimage);
   * ```
   *
   */
  SHA256
};

// dist/node/lib/foreign-field.js
var ForeignField2 = class _ForeignField {
  // static parameters
  static get Bigint() {
    assert3(this._Bigint !== void 0, "ForeignField class not initialized.");
    return this._Bigint;
  }
  static get modulus() {
    assert3(this._modulus !== void 0, "ForeignField class not initialized.");
    return this._modulus;
  }
  get modulus() {
    return this.constructor.modulus;
  }
  static get sizeInBits() {
    return this.modulus.toString(2).length;
  }
  get Constructor() {
    return this.constructor;
  }
  /**
   * Constructor for unreduced field elements.
   */
  static get Unreduced() {
    assert3(this._variants !== void 0, "ForeignField class not initialized.");
    return this._variants.unreduced;
  }
  /**
   * Constructor for field elements that are "almost reduced", i.e. lie in the range [0, 2^ceil(log2(p))).
   */
  static get AlmostReduced() {
    assert3(this._variants !== void 0, "ForeignField class not initialized.");
    return this._variants.almostReduced;
  }
  /**
   * Constructor for field elements that are fully reduced, i.e. lie in the range [0, p).
   */
  static get Canonical() {
    assert3(this._variants !== void 0, "ForeignField class not initialized.");
    return this._variants.canonical;
  }
  /**
   * Create a new {@link ForeignField} from a bigint, number, string or another ForeignField.
   * @example
   * ```ts
   * let x = new ForeignField(5);
   * ```
   */
  constructor(x) {
    const p3 = this.modulus;
    if (x instanceof _ForeignField) {
      this.value = x.value;
      return;
    }
    if (Array.isArray(x)) {
      this.value = x;
      return;
    }
    this.value = Field32.from(mod(BigInt(x), p3));
  }
  static from(x) {
    if (x instanceof this)
      return x;
    return new this.Canonical(x);
  }
  /**
   * Checks whether this field element is a constant.
   *
   * See {@link FieldVar} to understand constants vs variables.
   */
  isConstant() {
    return Field32.isConstant(this.value);
  }
  /**
   * Convert this field element to a constant.
   *
   * See {@link FieldVar} to understand constants vs variables.
   *
   * **Warning**: This function is only useful in {@link Provable.witness} or {@link Provable.asProver} blocks,
   * that is, in situations where the prover computes a value outside provable code.
   */
  toConstant() {
    let constantLimbs = Tuple.map(this.value, (l4) => l4.toConstant());
    return new this.Constructor(constantLimbs);
  }
  /**
   * Convert this field element to a bigint.
   */
  toBigInt() {
    return Field32.toBigint(this.value);
  }
  /**
   * Assert that this field element lies in the range [0, 2^k),
   * where k = ceil(log2(p)) and p is the foreign field modulus.
   *
   * Returns the field element as a {@link AlmostForeignField}.
   *
   * For a more efficient version of this for multiple field elements, see {@link assertAlmostReduced}.
   *
   * Note: this does not ensure that the field elements is in the canonical range [0, p).
   * To assert that stronger property, there is {@link assertCanonical}.
   * You should typically use {@link assertAlmostReduced} though, because it is cheaper to prove and sufficient for
   * ensuring validity of all our non-native field arithmetic methods.
   */
  assertAlmostReduced() {
    let [x] = this.Constructor.assertAlmostReduced(this);
    return x;
  }
  /**
   * Assert that one or more field elements lie in the range [0, 2^k),
   * where k = ceil(log2(p)) and p is the foreign field modulus.
   *
   * This is most efficient than when checking a multiple of 3 field elements at once.
   */
  static assertAlmostReduced(...xs) {
    Gadgets.ForeignField.assertAlmostReduced(xs.map((x) => x.value), this.modulus, { skipMrc: true });
    return Tuple.map(xs, this.AlmostReduced.unsafeFrom);
  }
  /**
   * Assert that this field element is fully reduced,
   * i.e. lies in the range [0, p), where p is the foreign field modulus.
   *
   * Returns the field element as a {@link CanonicalForeignField}.
   */
  assertCanonical() {
    this.assertLessThan(this.modulus);
    return this.Constructor.Canonical.unsafeFrom(this);
  }
  // arithmetic with full constraints, for safe use
  /**
   * Finite field addition
   * @example
   * ```ts
   * x.add(2); // x + 2 mod p
   * ```
   */
  add(y) {
    return this.Constructor.sum([this, y], [1]);
  }
  /**
   * Finite field negation
   * @example
   * ```ts
   * x.neg(); // -x mod p = p - x
   * ```
   */
  neg() {
    let xNeg = Gadgets.ForeignField.neg(this.value, this.modulus);
    return new this.Constructor.AlmostReduced(xNeg);
  }
  /**
   * Finite field subtraction
   * @example
   * ```ts
   * x.sub(1); // x - 1 mod p
   * ```
   */
  sub(y) {
    return this.Constructor.sum([this, y], [-1]);
  }
  /**
   * Sum (or difference) of multiple finite field elements.
   *
   * @example
   * ```ts
   * let z = ForeignField.sum([3, 2, 1], [-1, 1]); // 3 - 2 + 1
   * z.assertEquals(2);
   * ```
   *
   * This method expects a list of ForeignField-like values, `x0,...,xn`,
   * and a list of "operations" `op1,...,opn` where every op is 1 or -1 (plus or minus),
   * and returns
   *
   * `x0 + op1*x1 + ... + opn*xn`
   *
   * where the sum is computed in finite field arithmetic.
   *
   * **Important:** For more than two summands, this is significantly more efficient
   * than chaining calls to {@link ForeignField.add} and {@link ForeignField.sub}.
   *
   */
  static sum(xs, operations) {
    const p3 = this.modulus;
    let fields = xs.map((x) => toLimbs(x, p3));
    let ops = operations.map((op) => op === 1 ? 1n : -1n);
    let z = Gadgets.ForeignField.sum(fields, ops, p3);
    return new this.Unreduced(z);
  }
  assertEquals(y, message) {
    const p3 = this.modulus;
    try {
      if (this.isConstant() && isConstant6(y)) {
        let x = this.toBigInt();
        let y0 = mod(toBigInt(y), p3);
        if (x !== y0) {
          throw Error(`ForeignField.assertEquals(): ${x} != ${y0}`);
        }
        return new this.Constructor.Canonical(this.value);
      }
      Provable.assertEqual(this.Constructor.provable, this, new this.Constructor(y));
      if (isConstant6(y) || y instanceof this.Constructor.Canonical) {
        return new this.Constructor.Canonical(this.value);
      } else if (y instanceof this.Constructor.AlmostReduced) {
        return new this.Constructor.AlmostReduced(this.value);
      } else {
        return this;
      }
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  /**
   * Assert that this field element is less than a constant c: `x < c`.
   *
   * The constant must satisfy `0 <= c < 2^264`, otherwise an error is thrown.
   *
   * @example
   * ```ts
   * x.assertLessThan(10);
   * ```
   */
  assertLessThan(c, message) {
    assert3(c >= 0 && c < 1n << l3, `ForeignField.assertLessThan(): expected c <= c < 2^264, got ${c}`);
    try {
      Gadgets.ForeignField.assertLessThan(this.value, toBigInt(c));
    } catch (err) {
      throw withMessage2(err, message);
    }
  }
  // bit packing
  /**
   * Unpack a field element to its bits, as a {@link Bool}[] array.
   *
   * This method is provable!
   */
  toBits(length) {
    const sizeInBits2 = this.Constructor.sizeInBits;
    if (length === void 0)
      length = sizeInBits2;
    checkBitLength("ForeignField.toBits()", length, sizeInBits2);
    let [l0, l1, l22] = this.value;
    let limbSize = Number(l);
    let xBits = l0.toBits(Math.min(length, limbSize));
    length -= limbSize;
    if (length <= 0)
      return xBits;
    let yBits = l1.toBits(Math.min(length, limbSize));
    length -= limbSize;
    if (length <= 0)
      return [...xBits, ...yBits];
    let zBits = l22.toBits(Math.min(length, limbSize));
    return [...xBits, ...yBits, ...zBits];
  }
  /**
   * Create a field element from its bits, as a `Bool[]` array.
   *
   * This method is provable!
   */
  static fromBits(bits2) {
    let length = bits2.length;
    checkBitLength("ForeignField.fromBits()", length, this.sizeInBits);
    let limbSize = Number(l);
    let l0 = Field3.fromBits(bits2.slice(0 * limbSize, 1 * limbSize));
    let l1 = Field3.fromBits(bits2.slice(1 * limbSize, 2 * limbSize));
    let l22 = Field3.fromBits(bits2.slice(2 * limbSize, 3 * limbSize));
    return new this.AlmostReduced([l0, l1, l22]);
  }
  static random() {
    return new this.Canonical(this.Bigint.random());
  }
  /**
   * Instance version of `Provable<ForeignField>.toFields`, see {@link Provable.toFields}
   */
  toFields() {
    return this.value;
  }
  static check(_) {
    throw Error("ForeignField.check() not implemented: must use a subclass");
  }
  /**
   * `Provable<ForeignField>`, see {@link Provable}
   */
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
};
ForeignField2._Bigint = void 0;
ForeignField2._modulus = void 0;
ForeignField2._variants = void 0;
ForeignField2._provable = void 0;
var ForeignFieldWithMul = class extends ForeignField2 {
  /**
   * Finite field multiplication
   * @example
   * ```ts
   * x.mul(y); // x*y mod p
   * ```
   */
  mul(y) {
    const p3 = this.modulus;
    let z = Gadgets.ForeignField.mul(this.value, toLimbs(y, p3), p3);
    return new this.Constructor.Unreduced(z);
  }
  /**
   * Multiplicative inverse in the finite field
   * @example
   * ```ts
   * let z = x.inv(); // 1/x mod p
   * z.mul(x).assertEquals(1);
   * ```
   */
  inv() {
    const p3 = this.modulus;
    let z = Gadgets.ForeignField.inv(this.value, p3);
    return new this.Constructor.AlmostReduced(z);
  }
  /**
   * Division in the finite field, i.e. `x*y^(-1) mod p` where `y^(-1)` is the finite field inverse.
   * @example
   * ```ts
   * let z = x.div(y); // x/y mod p
   * z.mul(y).assertEquals(x);
   * ```
   */
  div(y) {
    const p3 = this.modulus;
    let z = Gadgets.ForeignField.div(this.value, toLimbs(y, p3), p3);
    return new this.Constructor.AlmostReduced(z);
  }
};
var UnreducedForeignField = class extends ForeignField2 {
  constructor() {
    super(...arguments);
    this.type = "Unreduced";
  }
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
  static check(x) {
    Gadgets.multiRangeCheck(x.value);
  }
};
UnreducedForeignField._provable = void 0;
var AlmostForeignField = class extends ForeignFieldWithMul {
  constructor(x) {
    super(x);
    this.type = "AlmostReduced";
  }
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
  static check(x) {
    Gadgets.multiRangeCheck(x.value);
    x.assertAlmostReduced();
  }
  /**
   * Coerce the input to an {@link AlmostForeignField} without additional assertions.
   *
   * **Warning:** Only use if you know what you're doing.
   */
  static unsafeFrom(x) {
    return new this(x.value);
  }
  /**
   * Check equality with a constant value.
   *
   * @example
   * ```ts
   * let isXZero = x.equals(0);
   * ```
   */
  equals(y) {
    return ForeignField.equals(this.value, BigInt(y), this.modulus);
  }
};
AlmostForeignField._provable = void 0;
var CanonicalForeignField = class extends ForeignFieldWithMul {
  constructor(x) {
    super(x);
    this.type = "FullyReduced";
  }
  static get provable() {
    assert3(this._provable !== void 0, "ForeignField class not initialized.");
    return this._provable;
  }
  static check(x) {
    Gadgets.multiRangeCheck(x.value);
    x.assertCanonical();
  }
  /**
   * Coerce the input to a {@link CanonicalForeignField} without additional assertions.
   *
   * **Warning:** Only use if you know what you're doing.
   */
  static unsafeFrom(x) {
    return new this(x.value);
  }
  /**
   * Check equality with a ForeignField-like value.
   *
   * @example
   * ```ts
   * let isEqual = x.equals(y);
   * ```
   *
   * Note: This method only exists on canonical fields; on unreduced fields, it would be easy to
   * misuse, because not being exactly equal does not imply being unequal modulo p.
   */
  equals(y) {
    let [x0, x1, x2] = this.value;
    let [y0, y1, y2] = toLimbs(y, this.modulus);
    let x01 = x0.add(x1.mul(1n << l)).seal();
    let y01 = y0.add(y1.mul(1n << l)).seal();
    return x01.equals(y01).and(x2.equals(y2));
  }
};
CanonicalForeignField._provable = void 0;
function toLimbs(x, p3) {
  if (x instanceof ForeignField2)
    return x.value;
  return Field32.from(mod(BigInt(x), p3));
}
function toBigInt(x) {
  if (x instanceof ForeignField2)
    return x.toBigInt();
  return BigInt(x);
}
function isConstant6(x) {
  if (x instanceof ForeignField2)
    return x.isConstant();
  return true;
}
function createForeignField(modulus) {
  assert3(modulus > 0n, `ForeignField: modulus must be positive, got ${modulus}`);
  assert3(modulus < foreignFieldMax, `ForeignField: modulus exceeds the max supported size of 2^${foreignFieldMaxBits}`);
  let Bigint = createField(modulus);
  class UnreducedField extends UnreducedForeignField {
  }
  UnreducedField._Bigint = Bigint;
  UnreducedField._modulus = modulus;
  UnreducedField._provable = provable2(UnreducedField);
  UnreducedField.from = ForeignField2.from.bind(UnreducedField);
  UnreducedField.sum = ForeignField2.sum.bind(UnreducedField);
  UnreducedField.fromBits = ForeignField2.fromBits.bind(UnreducedField);
  class AlmostField extends AlmostForeignField {
  }
  AlmostField._Bigint = Bigint;
  AlmostField._modulus = modulus;
  AlmostField._provable = provable2(AlmostField);
  AlmostField.from = ForeignField2.from.bind(AlmostField);
  AlmostField.sum = ForeignField2.sum.bind(AlmostField);
  AlmostField.fromBits = ForeignField2.fromBits.bind(AlmostField);
  AlmostField.unsafeFrom = AlmostForeignField.unsafeFrom.bind(AlmostField);
  class CanonicalField extends CanonicalForeignField {
  }
  CanonicalField._Bigint = Bigint;
  CanonicalField._modulus = modulus;
  CanonicalField._provable = provable2(CanonicalField);
  CanonicalField.from = ForeignField2.from.bind(CanonicalField);
  CanonicalField.sum = ForeignField2.sum.bind(CanonicalField);
  CanonicalField.fromBits = ForeignField2.fromBits.bind(CanonicalField);
  CanonicalField.unsafeFrom = CanonicalForeignField.unsafeFrom.bind(CanonicalField);
  let variants = {
    unreduced: UnreducedField,
    almostReduced: AlmostField,
    canonical: CanonicalField
  };
  UnreducedField._variants = variants;
  AlmostField._variants = variants;
  CanonicalField._variants = variants;
  return UnreducedField;
}
var foreignFieldMaxBits = (BigInt(Fp.sizeInBits - 1) + 3n * l) / 2n;
var foreignFieldMax = 1n << foreignFieldMaxBits;
function provable2(Class) {
  return {
    toFields(x) {
      return x.value;
    },
    toAuxiliary() {
      return [];
    },
    sizeInFields() {
      return 3;
    },
    fromFields(fields) {
      let limbs = TupleN.fromArray(3, fields);
      return new Class(limbs);
    },
    check(x) {
      Class.check(x);
    },
    // ugh
    toJSON(x) {
      return x.toBigInt().toString();
    },
    fromJSON(x) {
      return new Class(x);
    },
    empty() {
      return new Class(0n);
    },
    toInput(x) {
      let l_ = Number(l);
      return {
        packed: [
          [x.value[0], l_],
          [x.value[1], l_],
          [x.value[2], l_]
        ]
      };
    }
  };
}

// dist/node/lib/gadgets/elliptic-curve.js
var import_js_sha2562 = require("js-sha256");
var EllipticCurve = {
  add,
  double,
  negate,
  assertOnCurve,
  scale,
  assertInSubgroup,
  multiScalarMul
};
function add(p1, p22, Curve) {
  let { x: x1, y: y1 } = p1;
  let { x: x2, y: y2 } = p22;
  let f = Curve.modulus;
  if (Point.isConstant(p1) && Point.isConstant(p22)) {
    let p3 = affineAdd(Point.toBigint(p1), Point.toBigint(p22), f);
    return Point.from(p3);
  }
  let witnesses = exists(9, () => {
    let [x1_, x2_, y1_, y2_] = Field32.toBigints(x1, x2, y1, y2);
    let denom = inverse(mod(x1_ - x2_, f), f);
    let m3 = denom !== void 0 ? mod((y1_ - y2_) * denom, f) : 0n;
    let m22 = mod(m3 * m3, f);
    let x33 = mod(m22 - x1_ - x2_, f);
    let y33 = mod(m3 * (x1_ - x33) - y1_, f);
    return [...split(m3), ...split(x33), ...split(y33)];
  });
  let [m0, m1, m2, x30, x31, x32, y30, y31, y32] = witnesses;
  let m = [m0, m1, m2];
  let x3 = [x30, x31, x32];
  let y3 = [y30, y31, y32];
  ForeignField.assertAlmostReduced([m, x3, y3], f);
  let deltaX = ForeignField.Sum(x1).sub(x2);
  let deltaY = ForeignField.Sum(y1).sub(y2);
  ForeignField.assertMul(deltaX, m, deltaY, f);
  let xSum = ForeignField.Sum(x1).add(x2).add(x3);
  ForeignField.assertMul(m, m, xSum, f);
  let deltaX1X3 = ForeignField.Sum(x1).sub(x3);
  let ySum = ForeignField.Sum(y1).add(y3);
  ForeignField.assertMul(deltaX1X3, m, ySum, f);
  return { x: x3, y: y3 };
}
function double(p1, Curve) {
  let { x: x1, y: y1 } = p1;
  let f = Curve.modulus;
  if (Point.isConstant(p1)) {
    let p3 = affineDouble(Point.toBigint(p1), f);
    return Point.from(p3);
  }
  let witnesses = exists(9, () => {
    let [x1_, y1_] = Field32.toBigints(x1, y1);
    let denom = inverse(mod(2n * y1_, f), f);
    let m3 = denom !== void 0 ? mod(3n * mod(x1_ ** 2n, f) * denom, f) : 0n;
    let m22 = mod(m3 * m3, f);
    let x33 = mod(m22 - 2n * x1_, f);
    let y33 = mod(m3 * (x1_ - x33) - y1_, f);
    return [...split(m3), ...split(x33), ...split(y33)];
  });
  let [m0, m1, m2, x30, x31, x32, y30, y31, y32] = witnesses;
  let m = [m0, m1, m2];
  let x3 = [x30, x31, x32];
  let y3 = [y30, y31, y32];
  ForeignField.assertAlmostReduced([m, x3, y3], f);
  let x1x1 = ForeignField.mul(x1, x1, f);
  let y1Times2 = ForeignField.Sum(y1).add(y1);
  let x1x1Times3PlusA = ForeignField.Sum(x1x1).add(x1x1).add(x1x1);
  if (Curve.a !== 0n)
    x1x1Times3PlusA = x1x1Times3PlusA.add(Field32.from(Curve.a));
  ForeignField.assertMul(y1Times2, m, x1x1Times3PlusA, f);
  let xSum = ForeignField.Sum(x1).add(x1).add(x3);
  ForeignField.assertMul(m, m, xSum, f);
  let deltaX1X3 = ForeignField.Sum(x1).sub(x3);
  let ySum = ForeignField.Sum(y1).add(y3);
  ForeignField.assertMul(deltaX1X3, m, ySum, f);
  return { x: x3, y: y3 };
}
function negate({ x, y }, Curve) {
  return { x, y: ForeignField.negate(y, Curve.modulus) };
}
function assertOnCurve(p3, { modulus: f, a: a2, b: b2 }) {
  let { x, y } = p3;
  let x2 = ForeignField.mul(x, x, f);
  let y2 = ForeignField.mul(y, y, f);
  let y2MinusB = ForeignField.Sum(y2).sub(Field32.from(b2));
  let x2PlusA = ForeignField.Sum(x2);
  if (a2 !== 0n)
    x2PlusA = x2PlusA.add(Field32.from(a2));
  let message;
  if (Point.isConstant(p3)) {
    message = `assertOnCurve(): (${x}, ${y}) is not on the curve.`;
  }
  ForeignField.assertMul(x2PlusA, x, y2MinusB, f, message);
}
function scale(scalar, point, Curve, config = { mode: "assert-nonzero" }) {
  config.windowSize ??= Point.isConstant(point) ? 4 : 3;
  return multiScalarMul([scalar], [point], Curve, [config], config.mode);
}
function assertInSubgroup(p3, Curve) {
  if (!Curve.hasCofactor)
    return;
  scale(Field32.from(Curve.order), p3, Curve, { mode: "assert-zero" });
}
function equals2(p1, p22, Curve) {
  let xEquals = ForeignField.equals(p1.x, p22.x, Curve.modulus);
  let yEquals = ForeignField.equals(p1.y, p22.y, Curve.modulus);
  return xEquals.and(yEquals);
}
function verifyEcdsa(Curve, signature, msgHash, publicKey, config = { G: { windowSize: 4 }, P: { windowSize: 3 } }) {
  if (EcdsaSignature.isConstant(signature) && Field32.isConstant(msgHash) && Point.isConstant(publicKey)) {
    let isValid = verifyEcdsaConstant(Curve, EcdsaSignature.toBigint(signature), Field32.toBigint(msgHash), Point.toBigint(publicKey));
    return new Bool3(isValid);
  }
  let { r, s } = signature;
  ForeignField.inv(r, Curve.order);
  let sInv = ForeignField.inv(s, Curve.order);
  let u1 = ForeignField.mul(msgHash, sInv, Curve.order);
  let u2 = ForeignField.mul(r, sInv, Curve.order);
  let G = Point.from(Curve.one);
  let R = multiScalarMul([u1, u2], [G, publicKey], Curve, config && [config.G, config.P], "assert-nonzero", config?.ia);
  let Rx = ForeignField.mul(R.x, Field32.from(1n), Curve.order);
  ForeignField.assertLessThan(Rx, Curve.order);
  return Provable.equal(Field32.provable, Rx, r);
}
function verifyEcdsaConstant(Curve, { r, s }, msgHash, publicKey) {
  let pk = Curve.from(publicKey);
  if (Curve.equal(pk, Curve.zero))
    return false;
  if (Curve.hasCofactor && !Curve.isInSubgroup(pk))
    return false;
  if (r < 1n || r >= Curve.order)
    return false;
  if (s < 1n || s >= Curve.order)
    return false;
  let sInv = Curve.Scalar.inverse(s);
  assert3(sInv !== void 0);
  let u1 = Curve.Scalar.mul(msgHash, sInv);
  let u2 = Curve.Scalar.mul(r, sInv);
  let R = Curve.add(Curve.scale(Curve.one, u1), Curve.scale(pk, u2));
  if (Curve.equal(R, Curve.zero))
    return false;
  return Curve.Scalar.equal(R.x, r);
}
function multiScalarMul(scalars, points, Curve, tableConfigs = [], mode = "assert-nonzero", ia) {
  let n = points.length;
  assert3(scalars.length === n, "Points and scalars lengths must match");
  assertPositiveInteger(n, "Expected at least 1 point and scalar");
  let useGlv = Curve.hasEndomorphism;
  if (scalars.every(Field32.isConstant) && points.every(Point.isConstant)) {
    let s = scalars.map(Field32.toBigint);
    let P = points.map(Point.toBigint);
    let sum3 = Curve.zero;
    for (let i2 = 0; i2 < n; i2++) {
      if (useGlv) {
        sum3 = Curve.add(sum3, Curve.Endo.scale(P[i2], s[i2]));
      } else {
        sum3 = Curve.add(sum3, Curve.scale(P[i2], s[i2]));
      }
    }
    if (mode === "assert-zero") {
      assert3(sum3.infinity, "scalar multiplication: expected zero result");
      return Point.from(Curve.zero);
    }
    assert3(!sum3.infinity, "scalar multiplication: expected non-zero result");
    return Point.from(sum3);
  }
  let windowSizes = points.map((_, i2) => tableConfigs[i2]?.windowSize ?? 1);
  let tables = points.map((P, i2) => getPointTable(Curve, P, windowSizes[i2], tableConfigs[i2]?.multiples));
  let maxBits = Curve.Scalar.sizeInBits;
  if (useGlv) {
    maxBits = Curve.Endo.decomposeMaxBits;
    let n2 = 2 * n;
    let scalars2 = Array(n2);
    let points2 = Array(n2);
    let windowSizes2 = Array(n2);
    let tables2 = Array(n2);
    let mrcStack = [];
    for (let i2 = 0; i2 < n; i2++) {
      let [s0, s1] = decomposeNoRangeCheck(Curve, scalars[i2]);
      scalars2[2 * i2] = s0.abs;
      scalars2[2 * i2 + 1] = s1.abs;
      let table = tables[i2];
      let endoTable = table.map((P, i3) => {
        if (i3 === 0)
          return P;
        let [phiP, betaXBound] = endomorphism2(Curve, P);
        mrcStack.push(betaXBound);
        return phiP;
      });
      tables2[2 * i2] = table.map((P) => negateIf(s0.isNegative, P, Curve.modulus));
      tables2[2 * i2 + 1] = endoTable.map((P) => negateIf(s1.isNegative, P, Curve.modulus));
      points2[2 * i2] = tables2[2 * i2][1];
      points2[2 * i2 + 1] = tables2[2 * i2 + 1][1];
      windowSizes2[2 * i2] = windowSizes2[2 * i2 + 1] = windowSizes[i2];
    }
    reduceMrcStack(mrcStack);
    points = points2;
    tables = tables2;
    scalars = scalars2;
    windowSizes = windowSizes2;
    n = n2;
  }
  let scalarChunks = scalars.map((s, i2) => sliceField3(s, { maxBits, chunkSize: windowSizes[i2] }));
  ia ??= initialAggregator(Curve);
  let sum2 = Point.from(ia);
  for (let i2 = maxBits - 1; i2 >= 0; i2--) {
    for (let j = 0; j < n; j++) {
      let windowSize = windowSizes[j];
      if (i2 % windowSize === 0) {
        let sj = scalarChunks[j][i2 / windowSize];
        let sjP = windowSize === 1 ? points[j] : arrayGetGeneric(Point.provable, tables[j], sj);
        let added = add(sum2, sjP, Curve);
        sum2 = Provable.if(sj.equals(0), Point.provable, sum2, added);
      }
    }
    if (i2 === 0)
      break;
    sum2 = double(sum2, Curve);
  }
  let iaFinal = Curve.scale(Curve.fromNonzero(ia), 1n << BigInt(maxBits - 1));
  let isZero = equals2(sum2, iaFinal, Curve);
  if (mode === "assert-nonzero") {
    isZero.assertFalse();
    sum2 = add(sum2, Point.from(Curve.negate(iaFinal)), Curve);
  } else {
    isZero.assertTrue();
    sum2 = Point.from(Curve.zero);
  }
  return sum2;
}
function negateIf(condition, P, f) {
  let y = Provable.if(Bool3.Unsafe.ofField(condition), Field32.provable, ForeignField.negate(P.y, f), P.y);
  return { x: P.x, y };
}
function endomorphism2(Curve, P) {
  let beta = Field32.from(Curve.Endo.base);
  let betaX = ForeignField.mul(beta, P.x, Curve.modulus);
  return [{ x: betaX, y: P.y }, weakBound(betaX[2], Curve.modulus)];
}
function decomposeNoRangeCheck(Curve, s) {
  assert3(Curve.Endo.decomposeMaxBits < l2, "decomposed scalars assumed to be < 2*88 bits");
  let witnesses = exists(6, () => {
    let [s02, s12] = Curve.Endo.decompose(Field32.toBigint(s));
    let [s002, s012] = split(s02.abs);
    let [s102, s112] = split(s12.abs);
    return [
      s02.isNegative ? 1n : 0n,
      s002,
      s012,
      s12.isNegative ? 1n : 0n,
      s102,
      s112
    ];
  });
  let [s0Negative, s00, s01, s1Negative, s10, s11] = witnesses;
  let s0 = [s00, s01, Field3.from(0n)];
  let s1 = [s10, s11, Field3.from(0n)];
  assertBoolean(s0Negative);
  assertBoolean(s1Negative);
  let lambda = Provable.if(Bool3.Unsafe.ofField(s1Negative), Field32.provable, Field32.from(Curve.Scalar.negate(Curve.Endo.scalar)), Field32.from(Curve.Endo.scalar));
  let rhs = Provable.if(Bool3.Unsafe.ofField(s0Negative), Field32.provable, ForeignField.Sum(s).add(s0).finish(Curve.order), ForeignField.Sum(s).sub(s0).finish(Curve.order));
  ForeignField.assertMul(s1, lambda, rhs, Curve.order);
  return [
    { isNegative: s0Negative, abs: s0 },
    { isNegative: s1Negative, abs: s1 }
  ];
}
function signEcdsa(Curve, msgHash, privateKey) {
  let { Scalar: Scalar4 } = Curve;
  let k = Scalar4.random();
  let R = Curve.scale(Curve.one, k);
  let r = Scalar4.mod(R.x);
  let kInv = Scalar4.inverse(k);
  assert3(kInv !== void 0);
  let s = Scalar4.mul(kInv, Scalar4.add(msgHash, Scalar4.mul(r, privateKey)));
  return { r, s };
}
function getPointTable(Curve, P, windowSize, table) {
  assertPositiveInteger(windowSize, "invalid window size");
  let n = 1 << windowSize;
  assert3(table === void 0 || table.length === n, "invalid table");
  if (table !== void 0)
    return table;
  table = [Point.from(Curve.zero), P];
  if (n === 2)
    return table;
  let Pi = double(P, Curve);
  table.push(Pi);
  for (let i2 = 3; i2 < n; i2++) {
    Pi = add(Pi, P, Curve);
    table.push(Pi);
  }
  return table;
}
function initialAggregator(Curve) {
  let h = import_js_sha2562.sha256.create();
  h.update("initial-aggregator");
  h.update(bigIntToBytes(Curve.modulus));
  h.update(bigIntToBytes(Curve.order));
  h.update(bigIntToBytes(Curve.a));
  h.update(bigIntToBytes(Curve.b));
  let bytes = h.array();
  const F = Curve.Field;
  let x = F.mod(bytesToBigInt(bytes));
  return simpleMapToCurve(x, Curve);
}
function random(Curve) {
  let x = Curve.Field.random();
  return simpleMapToCurve(x, Curve);
}
function simpleMapToCurve(x, Curve) {
  const F = Curve.Field;
  let y = void 0;
  while (y === void 0) {
    x = F.add(x, 1n);
    let x3 = F.mul(F.square(x), x);
    let y2 = F.add(x3, F.mul(Curve.a, x) + Curve.b);
    y = F.sqrt(y2);
  }
  let p3 = { x, y, infinity: false };
  if (Curve.hasCofactor) {
    p3 = Curve.scale(p3, Curve.cofactor);
  }
  return p3;
}
function arrayGetGeneric(type, array, index) {
  let a2 = Provable.witness(type, () => array[Number(index)]);
  let aFields = type.toFields(a2);
  let size = type.sizeInFields();
  let arrays = array.map(type.toFields);
  for (let j = 0; j < size; j++) {
    let arrayFieldsJ = arrays.map((x) => x[j]);
    arrayGet(arrayFieldsJ, index).assertEquals(aFields[j]);
  }
  return a2;
}
var Point = {
  from({ x, y }) {
    return { x: Field32.from(x), y: Field32.from(y) };
  },
  toBigint({ x, y }) {
    return { x: Field32.toBigint(x), y: Field32.toBigint(y), infinity: false };
  },
  isConstant: (P) => Provable.isConstant(Point.provable, P),
  /**
   * Random point on the curve.
   */
  random(Curve) {
    return Point.from(random(Curve));
  },
  provable: provable({ x: Field32.provable, y: Field32.provable })
};
var EcdsaSignature = {
  from({ r, s }) {
    return { r: Field32.from(r), s: Field32.from(s) };
  },
  toBigint({ r, s }) {
    return { r: Field32.toBigint(r), s: Field32.toBigint(s) };
  },
  isConstant: (S) => Provable.isConstant(EcdsaSignature.provable, S),
  /**
   * Create an {@link EcdsaSignature} from a raw 130-char hex string as used in
   * [Ethereum transactions](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).
   */
  fromHex(rawSignature) {
    let prefix = rawSignature.slice(0, 2);
    let signature = rawSignature.slice(2, 130);
    if (prefix !== "0x" || signature.length < 128) {
      throw Error(`Signature.fromHex(): Invalid signature, expected hex string 0x... of length at least 130.`);
    }
    let r = BigInt(`0x${signature.slice(0, 64)}`);
    let s = BigInt(`0x${signature.slice(64)}`);
    return EcdsaSignature.from({ r, s });
  },
  provable: provable({ r: Field32.provable, s: Field32.provable })
};
var Ecdsa = {
  sign: signEcdsa,
  verify: verifyEcdsa,
  Signature: EcdsaSignature
};
function reduceMrcStack(xs) {
  let n = xs.length;
  let nRemaining = n % 3;
  let nFull = (n - nRemaining) / 3;
  for (let i2 = 0; i2 < nFull; i2++) {
    multiRangeCheck([xs[3 * i2], xs[3 * i2 + 1], xs[3 * i2 + 2]]);
  }
  let remaining = [Field3.from(0n), Field3.from(0n), Field3.from(0n)];
  for (let i2 = 0; i2 < nRemaining; i2++) {
    remaining[i2] = xs[3 * nFull + i2];
  }
  multiRangeCheck(remaining);
}

// dist/node/lib/foreign-curve.js
function toPoint({ x, y }) {
  return { x: x.value, y: y.value };
}
var ForeignCurve = class {
  /**
   * Create a new {@link ForeignCurve} from an object representing the (affine) x and y coordinates.
   *
   * @example
   * ```ts
   * let x = new ForeignCurve({ x: 1n, y: 1n });
   * ```
   *
   * **Important**: By design, there is no way for a `ForeignCurve` to represent the zero point.
   *
   * **Warning**: This fails for a constant input which does not represent an actual point on the curve.
   */
  constructor(g) {
    this.x = new this.Constructor.Field(g.x);
    this.y = new this.Constructor.Field(g.y);
    if (this.isConstant()) {
      this.assertOnCurve();
      this.assertInSubgroup();
    }
  }
  /**
   * Coerce the input to a {@link ForeignCurve}.
   */
  static from(g) {
    if (g instanceof this)
      return g;
    return new this(g);
  }
  /**
   * The constant generator point.
   */
  static get generator() {
    return new this(this.Bigint.one);
  }
  /**
   * The size of the curve's base field.
   */
  static get modulus() {
    return this.Bigint.modulus;
  }
  /**
   * The size of the curve's base field.
   */
  get modulus() {
    return this.Constructor.Bigint.modulus;
  }
  /**
   * Checks whether this curve point is constant.
   *
   * See {@link FieldVar} to understand constants vs variables.
   */
  isConstant() {
    return Provable.isConstant(this.Constructor.provable, this);
  }
  /**
   * Convert this curve point to a point with bigint coordinates.
   */
  toBigint() {
    return this.Constructor.Bigint.fromNonzero({
      x: this.x.toBigInt(),
      y: this.y.toBigInt()
    });
  }
  /**
   * Elliptic curve addition.
   *
   * ```ts
   * let r = p.add(q); // r = p + q
   * ```
   *
   * **Important**: this is _incomplete addition_ and does not handle the degenerate cases:
   * - Inputs are equal, `g = h` (where you would use {@link double}).
   *   In this case, the result of this method is garbage and can be manipulated arbitrarily by a malicious prover.
   * - Inputs are inverses of each other, `g = -h`, so that the result would be the zero point.
   *   In this case, the proof fails.
   *
   * If you want guaranteed soundness regardless of the input, use {@link addSafe} instead.
   *
   * @throws if the inputs are inverses of each other.
   */
  add(h) {
    let Curve = this.Constructor.Bigint;
    let h_ = this.Constructor.from(h);
    let p3 = EllipticCurve.add(toPoint(this), toPoint(h_), Curve);
    return new this.Constructor(p3);
  }
  /**
   * Safe elliptic curve addition.
   *
   * This is the same as {@link add}, but additionally proves that the inputs are not equal.
   * Therefore, the method is guaranteed to either fail or return a valid addition result.
   *
   * **Beware**: this is more expensive than {@link add}, and is still incomplete in that
   * it does not succeed on equal or inverse inputs.
   *
   * @throws if the inputs are equal or inverses of each other.
   */
  addSafe(h) {
    let h_ = this.Constructor.from(h);
    let x1 = this.x.assertCanonical();
    let x2 = h_.x.assertCanonical();
    x1.equals(x2).assertFalse();
    return this.add(h_);
  }
  /**
   * Elliptic curve doubling.
   *
   * @example
   * ```ts
   * let r = p.double(); // r = 2 * p
   * ```
   */
  double() {
    let Curve = this.Constructor.Bigint;
    let p3 = EllipticCurve.double(toPoint(this), Curve);
    return new this.Constructor(p3);
  }
  /**
   * Elliptic curve negation.
   *
   * @example
   * ```ts
   * let r = p.negate(); // r = -p
   * ```
   */
  negate() {
    return new this.Constructor({ x: this.x, y: this.y.neg() });
  }
  /**
   * Elliptic curve scalar multiplication, where the scalar is represented as a {@link ForeignField} element.
   *
   * **Important**: this proves that the result of the scalar multiplication is not the zero point.
   *
   * @throws if the scalar multiplication results in the zero point; for example, if the scalar is zero.
   *
   * @example
   * ```ts
   * let r = p.scale(s); // r = s * p
   * ```
   */
  scale(scalar) {
    let Curve = this.Constructor.Bigint;
    let scalar_ = this.Constructor.Scalar.from(scalar);
    let p3 = EllipticCurve.scale(scalar_.value, toPoint(this), Curve);
    return new this.Constructor(p3);
  }
  static assertOnCurve(g) {
    EllipticCurve.assertOnCurve(toPoint(g), this.Bigint);
  }
  /**
   * Assert that this point lies on the elliptic curve, which means it satisfies the equation
   * `y^2 = x^3 + ax + b`
   */
  assertOnCurve() {
    this.Constructor.assertOnCurve(this);
  }
  static assertInSubgroup(g) {
    if (this.Bigint.hasCofactor) {
      EllipticCurve.assertInSubgroup(toPoint(g), this.Bigint);
    }
  }
  /**
   * Assert that this point lies in the subgroup defined by `order*P = 0`.
   *
   * Note: this is a no-op if the curve has cofactor equal to 1. Otherwise
   * it performs the full scalar multiplication `order*P` and is expensive.
   */
  assertInSubgroup() {
    this.Constructor.assertInSubgroup(this);
  }
  /**
   * Check that this is a valid element of the target subgroup of the curve:
   * - Check that the coordinates are valid field elements
   * - Use {@link assertOnCurve()} to check that the point lies on the curve
   * - If the curve has cofactor unequal to 1, use {@link assertInSubgroup()}.
   */
  static check(g) {
    this.Field.assertAlmostReduced(g.x, g.y);
    this.assertOnCurve(g);
    this.assertInSubgroup(g);
  }
  // dynamic subclassing infra
  get Constructor() {
    return this.constructor;
  }
  /**
   * Curve arithmetic on JS bigints.
   */
  static get Bigint() {
    assert3(this._Bigint !== void 0, "ForeignCurve not initialized");
    return this._Bigint;
  }
  /**
   * The base field of this curve as a {@link ForeignField}.
   */
  static get Field() {
    assert3(this._Field !== void 0, "ForeignCurve not initialized");
    return this._Field;
  }
  /**
   * The scalar field of this curve as a {@link ForeignField}.
   */
  static get Scalar() {
    assert3(this._Scalar !== void 0, "ForeignCurve not initialized");
    return this._Scalar;
  }
  /**
   * `Provable<ForeignCurve>`
   */
  static get provable() {
    assert3(this._provable !== void 0, "ForeignCurve not initialized");
    return this._provable;
  }
};
function createForeignCurve(params) {
  const FieldUnreduced = createForeignField(params.modulus);
  const ScalarUnreduced = createForeignField(params.order);
  class Field5 extends FieldUnreduced.AlmostReduced {
  }
  class Scalar4 extends ScalarUnreduced.AlmostReduced {
  }
  const BigintCurve = createCurveAffine(params);
  class Curve extends ForeignCurve {
  }
  Curve._Bigint = BigintCurve;
  Curve._Field = Field5;
  Curve._Scalar = Scalar4;
  Curve._provable = provableFromClass(Curve, {
    x: Field5.provable,
    y: Field5.provable
  });
  return Curve;
}

// dist/node/lib/keccak.js
var Keccak = {
  /**
   * Implementation of [NIST SHA-3](https://csrc.nist.gov/pubs/fips/202/final) Hash Function.
   * Supports output lengths of 256, 384, or 512 bits.
   *
   * Applies the SHA-3 hash function to a list of big-endian byte-sized {@link Field} elements, flexible to handle varying output lengths (256, 384, 512 bits) as specified.
   *
   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} that conforms to the chosen bit length.
   * Both input and output bytes are big-endian.
   *
   * @param len - Desired output length in bits. Valid options: 256, 384, 512.
   * @param message - Big-endian {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest256 = Keccak.nistSha3(256, preimage);
   * let digest384 = Keccak.nistSha3(384, preimage);
   * let digest512 = Keccak.nistSha3(512, preimage);
   * ```
   *
   */
  nistSha3(len, message) {
    return nistSha3(len, Bytes2.from(message));
  },
  /**
   * Ethereum-Compatible Keccak-256 Hash Function.
   * This is a specialized variant of {@link Keccak.preNist} configured for a 256-bit output length.
   *
   * Primarily used in Ethereum for hashing transactions, messages, and other types of payloads.
   *
   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} of length 32. Both input and output bytes are big-endian.
   *
   * @param message - Big-endian {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest = Keccak.ethereum(preimage);
   * ```
   */
  ethereum(message) {
    return ethereum(Bytes2.from(message));
  },
  /**
   * Implementation of [pre-NIST Keccak](https://keccak.team/keccak.html) hash function.
   * Supports output lengths of 256, 384, or 512 bits.
   *
   * Keccak won the SHA-3 competition and was slightly altered before being standardized as SHA-3 by NIST in 2015.
   * This variant was used in Ethereum before the NIST standardization, by specifying `len` as 256 bits you can obtain the same hash function as used by Ethereum {@link Keccak.ethereum}.
   *
   * The function applies the pre-NIST Keccak hash function to a list of byte-sized {@link Field} elements and is flexible to handle varying output lengths (256, 384, 512 bits) as specified.
   *
   * {@link Keccak.preNist} accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).
   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.
   *
   * Produces an output of {@link Bytes} that conforms to the chosen bit length.
   * Both input and output bytes are big-endian.
   *
   * @param len - Desired output length in bits. Valid options: 256, 384, 512.
   * @param message - Big-endian {@link Bytes} representing the message to hash.
   *
   * ```ts
   * let preimage = Bytes.fromString("hello world");
   * let digest256 = Keccak.preNist(256, preimage);
   * let digest384 = Keccak.preNist(384, preimage);
   * let digest512= Keccak.preNist(512, preimage);
   * ```
   *
   */
  preNist(len, message) {
    return preNist(len, Bytes2.from(message));
  }
};
var KECCAK_DIM = 5;
var KECCAK_ELL = 6;
var KECCAK_WORD = 2 ** KECCAK_ELL;
var BYTES_PER_WORD = KECCAK_WORD / 8;
var KECCAK_STATE_LENGTH_WORDS = KECCAK_DIM ** 2;
var KECCAK_STATE_LENGTH = KECCAK_STATE_LENGTH_WORDS * KECCAK_WORD;
var KECCAK_STATE_LENGTH_BYTES = KECCAK_STATE_LENGTH / 8;
var ROT_TABLE = [
  [0, 36, 3, 41, 18],
  [1, 44, 10, 45, 2],
  [62, 6, 43, 15, 61],
  [28, 55, 25, 21, 56],
  [27, 20, 39, 8, 14]
];
var ROUND_CONSTANTS = [
  0x0000000000000001n,
  0x0000000000008082n,
  0x800000000000808an,
  0x8000000080008000n,
  0x000000000000808bn,
  0x0000000080000001n,
  0x8000000080008081n,
  0x8000000000008009n,
  0x000000000000008an,
  0x0000000000000088n,
  0x0000000080008009n,
  0x000000008000000an,
  0x000000008000808bn,
  0x800000000000008bn,
  0x8000000000008089n,
  0x8000000000008003n,
  0x8000000000008002n,
  0x8000000000000080n,
  0x000000000000800an,
  0x800000008000000an,
  0x8000000080008081n,
  0x8000000000008080n,
  0x0000000080000001n,
  0x8000000080008008n
];
function bytesToPad(rate, length) {
  return rate - length % rate;
}
function pad(message, rate, nist) {
  const extraBytes = bytesToPad(rate, message.length);
  const first = nist ? 0x06n : 0x01n;
  const last = 0x80n;
  const pad2 = Array(extraBytes).fill(UInt8.from(0));
  pad2[0] = UInt8.from(first);
  pad2[extraBytes - 1] = pad2[extraBytes - 1].add(last);
  return [...message, ...pad2];
}
var theta = (state3) => {
  const stateA = state3;
  const stateC = stateA.map((row) => row.reduce(xor3));
  const stateD = Array.from({ length: KECCAK_DIM }, (_, i2) => xor3(stateC[(i2 + KECCAK_DIM - 1) % KECCAK_DIM], Gadgets.rotate64(stateC[(i2 + 1) % KECCAK_DIM], 1, "left")));
  const stateE = stateA.map((row, index) => row.map((elem) => xor3(elem, stateD[index])));
  return stateE;
};
function piRho(state3) {
  const stateE = state3;
  const stateB = State.zeros();
  for (let i2 = 0; i2 < KECCAK_DIM; i2++) {
    for (let j = 0; j < KECCAK_DIM; j++) {
      stateB[j][(2 * i2 + 3 * j) % KECCAK_DIM] = Gadgets.rotate64(stateE[i2][j], ROT_TABLE[i2][j], "left");
    }
  }
  return stateB;
}
function chi(state3) {
  const stateB = state3;
  const stateF = State.zeros();
  for (let i2 = 0; i2 < KECCAK_DIM; i2++) {
    for (let j = 0; j < KECCAK_DIM; j++) {
      stateF[i2][j] = xor3(stateB[i2][j], Gadgets.and(
        // We can use unchecked NOT because the length of the input is constrained to be 64 bits thanks to the fact that it is the output of a previous Xor64
        Gadgets.not(stateB[(i2 + 1) % KECCAK_DIM][j], KECCAK_WORD, false),
        stateB[(i2 + 2) % KECCAK_DIM][j],
        KECCAK_WORD
      ));
    }
  }
  return stateF;
}
function iota(state3, rc) {
  const stateG = state3;
  stateG[0][0] = xor3(stateG[0][0], Field3.from(rc));
  return stateG;
}
function round(state3, rc) {
  const stateA = state3;
  const stateE = theta(stateA);
  const stateB = piRho(stateE);
  const stateF = chi(stateB);
  const stateD = iota(stateF, rc);
  return stateD;
}
function permutation(state3, rcs) {
  return rcs.reduce((state4, rc) => round(state4, rc), state3);
}
function absorb(paddedMessage, capacity, rate, rc) {
  assert2(rate + capacity === KECCAK_STATE_LENGTH_WORDS, `invalid rate or capacity (rate + capacity should be ${KECCAK_STATE_LENGTH_WORDS})`);
  assert2(paddedMessage.length % rate === 0, "invalid padded message length (should be multiple of rate)");
  let state3 = State.zeros();
  const zeros = Array(capacity).fill(Field3.from(0));
  for (let idx = 0; idx < paddedMessage.length; idx += rate) {
    const block = paddedMessage.slice(idx, idx + rate);
    const paddedBlock = block.concat(zeros);
    const blockState = State.fromWords(paddedBlock);
    const stateXor = State.xor(state3, blockState);
    state3 = permutation(stateXor, rc);
  }
  return state3;
}
function squeeze(state3, length, rate) {
  const squeezes = Math.floor(length / rate) + 1;
  assert2(squeezes === 1, "squeezes should be 1");
  const words = State.toWords(state3);
  const hashed = words.slice(0, length);
  return hashed;
}
function sponge(paddedMessage, length, capacity, rate) {
  assert2(paddedMessage.length % rate === 0, "Invalid padded message length");
  const state3 = absorb(paddedMessage, capacity, rate, ROUND_CONSTANTS);
  const hashed = squeeze(state3, length, rate);
  return hashed;
}
function hash(message, length, capacity, nistVersion) {
  assert2(capacity > 0, "capacity must be positive");
  assert2(capacity < KECCAK_STATE_LENGTH_BYTES, `capacity must be less than ${KECCAK_STATE_LENGTH_BYTES}`);
  assert2(length > 0, "length must be positive");
  assert2(capacity % BYTES_PER_WORD === 0, "length must be a multiple of 8");
  capacity /= BYTES_PER_WORD;
  assert2(length % BYTES_PER_WORD === 0, "length must be a multiple of 8");
  length /= BYTES_PER_WORD;
  const rate = KECCAK_STATE_LENGTH_WORDS - capacity;
  const paddedBytes = pad(message.bytes, rate * BYTES_PER_WORD, nistVersion);
  const padded = bytesToWords(paddedBytes);
  const hash3 = sponge(padded, length, capacity, rate);
  const hashBytes = wordsToBytes(hash3);
  return hashBytes;
}
function nistSha3(len, message) {
  let bytes = hash(message, len / 8, len / 4, true);
  return BytesOfBitlength[len].from(bytes);
}
function preNist(len, message) {
  let bytes = hash(message, len / 8, len / 4, false);
  return BytesOfBitlength[len].from(bytes);
}
function ethereum(message) {
  return preNist(256, message);
}
var State = {
  /**
   * Create a state of all zeros
   */
  zeros() {
    return Array.from(Array(KECCAK_DIM), (_) => Array(KECCAK_DIM).fill(Field3.from(0)));
  },
  /**
   * Flatten state to words
   */
  toWords(state3) {
    const words = Array(KECCAK_STATE_LENGTH_WORDS);
    for (let j = 0; j < KECCAK_DIM; j++) {
      for (let i2 = 0; i2 < KECCAK_DIM; i2++) {
        words[KECCAK_DIM * j + i2] = state3[i2][j];
      }
    }
    return words;
  },
  /**
   * Compose words to state
   */
  fromWords(words) {
    const state3 = State.zeros();
    for (let j = 0; j < KECCAK_DIM; j++) {
      for (let i2 = 0; i2 < KECCAK_DIM; i2++) {
        state3[i2][j] = words[KECCAK_DIM * j + i2];
      }
    }
    return state3;
  },
  /**
   * XOR two states together and return the result
   */
  xor(a2, b2) {
    assert2(a2.length === KECCAK_DIM && a2[0].length === KECCAK_DIM, `invalid \`a\` dimensions (should be ${KECCAK_DIM})`);
    assert2(b2.length === KECCAK_DIM && b2[0].length === KECCAK_DIM, `invalid \`b\` dimensions (should be ${KECCAK_DIM})`);
    return a2.map((row, i2) => row.map((x, j) => xor3(x, b2[i2][j])));
  }
};
var Bytes32 = class extends Bytes2(32) {
};
var Bytes48 = class extends Bytes2(48) {
};
var Bytes64 = class extends Bytes2(64) {
};
var BytesOfBitlength = {
  256: Bytes32,
  384: Bytes48,
  512: Bytes64
};
function xor3(x, y) {
  if (x.isConstant() && x.toBigInt() === 0n)
    return y;
  if (y.isConstant() && y.toBigInt() === 0n)
    return x;
  return Gadgets.xor(x, y, 64);
}

// dist/node/lib/foreign-ecdsa.js
var EcdsaSignature2 = class {
  /**
   * Create a new {@link EcdsaSignature} from an object containing the scalars r and s.
   * @param signature
   */
  constructor(signature) {
    this.r = new this.Constructor.Curve.Scalar(signature.r);
    this.s = new this.Constructor.Curve.Scalar(signature.s);
  }
  /**
   * Coerce the input to a {@link EcdsaSignature}.
   */
  static from(signature) {
    if (signature instanceof this)
      return signature;
    return new this(signature);
  }
  /**
   * Create an {@link EcdsaSignature} from a raw 130-char hex string as used in
   * [Ethereum transactions](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).
   */
  static fromHex(rawSignature) {
    let s = Ecdsa.Signature.fromHex(rawSignature);
    return new this(s);
  }
  /**
   * Convert this signature to an object with bigint fields.
   */
  toBigInt() {
    return { r: this.r.toBigInt(), s: this.s.toBigInt() };
  }
  /**
   * Verify the ECDSA signature given the message (an array of bytes) and public key (a {@link Curve} point).
   *
   * **Important:** This method returns a {@link Bool} which indicates whether the signature is valid.
   * So, to actually prove validity of a signature, you need to assert that the result is true.
   *
   * @throws if one of the signature scalars is zero or if the public key is not on the curve.
   *
   * @example
   * ```ts
   * // create classes for your curve
   * class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}
   * class Scalar extends Secp256k1.Scalar {}
   * class Ecdsa extends createEcdsa(Secp256k1) {}
   *
   * let message = 'my message';
   * let messageBytes = new TextEncoder().encode(message);
   *
   * // outside provable code: create inputs
   * let privateKey = Scalar.random();
   * let publicKey = Secp256k1.generator.scale(privateKey);
   * let signature = Ecdsa.sign(messageBytes, privateKey.toBigInt());
   *
   * // ...
   * // in provable code: create input witnesses (or use method inputs, or constants)
   * let pk = Provable.witness(Secp256k1.provable, () => publicKey);
   * let msg = Provable.witness(Provable.Array(Field, 9), () => messageBytes.map(Field));
   * let sig = Provable.witness(Ecdsa.provable, () => signature);
   *
   * // verify signature
   * let isValid = sig.verify(msg, pk);
   * isValid.assertTrue('signature verifies');
   * ```
   */
  verify(message, publicKey) {
    let msgHashBytes = Keccak.ethereum(message);
    let msgHash = keccakOutputToScalar(msgHashBytes, this.Constructor.Curve);
    return this.verifySignedHash(msgHash, publicKey);
  }
  /**
   * Verify the ECDSA signature given the message hash (a {@link Scalar}) and public key (a {@link Curve} point).
   *
   * This is a building block of {@link EcdsaSignature.verify}, where the input message is also hashed.
   * In contrast, this method just takes the message hash (a curve scalar) as input, giving you flexibility in
   * choosing the hashing algorithm.
   */
  verifySignedHash(msgHash, publicKey) {
    let msgHash_ = this.Constructor.Curve.Scalar.from(msgHash);
    let publicKey_ = this.Constructor.Curve.from(publicKey);
    return Ecdsa.verify(this.Constructor.Curve.Bigint, toObject(this), msgHash_.value, toPoint(publicKey_));
  }
  /**
   * Create an {@link EcdsaSignature} by signing a message with a private key.
   *
   * Note: This method is not provable, and only takes JS bigints as input.
   */
  static sign(message, privateKey) {
    let msgHashBytes = Keccak.ethereum(message);
    let msgHash = keccakOutputToScalar(msgHashBytes, this.Curve);
    return this.signHash(msgHash.toBigInt(), privateKey);
  }
  /**
   * Create an {@link EcdsaSignature} by signing a message hash with a private key.
   *
   * This is a building block of {@link EcdsaSignature.sign}, where the input message is also hashed.
   * In contrast, this method just takes the message hash (a curve scalar) as input, giving you flexibility in
   * choosing the hashing algorithm.
   *
   * Note: This method is not provable, and only takes JS bigints as input.
   */
  static signHash(msgHash, privateKey) {
    let { r, s } = Ecdsa.sign(this.Curve.Bigint, msgHash, privateKey);
    return new this({ r, s });
  }
  static check(signature) {
    this.Curve.Scalar.assertAlmostReduced(signature.r, signature.s);
  }
  // dynamic subclassing infra
  get Constructor() {
    return this.constructor;
  }
  /**
   * The {@link ForeignCurve} on which the ECDSA signature is defined.
   */
  static get Curve() {
    assert3(this._Curve !== void 0, "EcdsaSignature not initialized");
    return this._Curve;
  }
  /**
   * `Provable<EcdsaSignature>`
   */
  static get provable() {
    assert3(this._provable !== void 0, "EcdsaSignature not initialized");
    return this._provable;
  }
};
function createEcdsa(curve) {
  let Curve0 = "b" in curve ? createForeignCurve(curve) : curve;
  class Curve extends Curve0 {
  }
  class Signature3 extends EcdsaSignature2 {
  }
  Signature3._Curve = Curve;
  Signature3._provable = provableFromClass(Signature3, {
    r: Curve.Scalar.provable,
    s: Curve.Scalar.provable
  });
  return Signature3;
}
function toObject(signature) {
  return { r: signature.r.value, s: signature.s.value };
}
function keccakOutputToScalar(hash3, Curve) {
  const L_n = Curve.Scalar.sizeInBits;
  assert3(L_n === 256, `Scalar sizes ${L_n} !== 256 not supported`);
  assert3(hash3.length === 32, `hash length ${hash3.length} !== 32 not supported`);
  assert3(l === 88n);
  let x2 = bytesToLimbBE(hash3.bytes.slice(0, 10));
  let x1 = bytesToLimbBE(hash3.bytes.slice(10, 21));
  let x0 = bytesToLimbBE(hash3.bytes.slice(21, 32));
  return new Curve.Scalar.AlmostReduced([x0, x1, x2]);
}
function bytesToLimbBE(bytes_) {
  let bytes = bytes_.map((x) => x.value);
  let n = bytes.length;
  let limb = bytes[0];
  for (let i2 = 1; i2 < n; i2++) {
    limb = limb.mul(1n << 8n).add(bytes[i2]);
  }
  return limb.seal();
}

// dist/node/lib/hashes-combined.js
var Hash = {
  /**
   * Hashes the given field elements using [Poseidon](https://eprint.iacr.org/2019/458.pdf). Alias for `Poseidon.hash()`.
   *
   * ```ts
   * let hash = Hash.hash([a, b, c]);
   * ```
   *
   * **Important:** This is by far the most efficient hash function o1js has available in provable code.
   * Use it by default, if no compatibility concerns require you to use a different hash function.
   *
   * The Poseidon implementation operates over the native [Pallas base field](https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/)
   * and uses parameters generated specifically for the [Mina](https://minaprotocol.com) blockchain.
   *
   * We use a `rate` of 2, which means that 2 field elements are hashed per permutation.
   * A permutation causes 11 rows in the constraint system.
   *
   * You can find the full set of Poseidon parameters [here](https://github.com/o1-labs/o1js-bindings/blob/main/crypto/constants.ts).
   */
  hash: Poseidon2.hash,
  /**
   * The [Poseidon](https://eprint.iacr.org/2019/458.pdf) hash function.
   *
   * See {@link Hash.hash} for details and usage examples.
   */
  Poseidon: Poseidon2,
  /**
   * The SHA2 hash function with an output length of 256 bits.
   */
  SHA2_256: {
    /**
     * Hashes the given bytes using SHA2-256.
     *
     * This is an alias for `Gadgets.SHA256.hash(bytes)`.\
     * See {@link Gadgets.SHA256.hash} for details and usage examples.
     */
    hash: Gadgets.SHA256.hash
  },
  /**
   * The SHA3 hash function with an output length of 256 bits.
   */
  SHA3_256: {
    /**
     * Hashes the given bytes using SHA3-256.
     *
     * This is an alias for `Keccak.nistSha3(256, bytes)`.\
     * See {@link Keccak.nistSha3} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.nistSha3(256, bytes);
    }
  },
  /**
   * The SHA3 hash function with an output length of 384 bits.
   */
  SHA3_384: {
    /**
     * Hashes the given bytes using SHA3-384.
     *
     * This is an alias for `Keccak.nistSha3(384, bytes)`.\
     * See {@link Keccak.nistSha3} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.nistSha3(384, bytes);
    }
  },
  /**
   * The SHA3 hash function with an output length of 512 bits.
   */
  SHA3_512: {
    /**
     * Hashes the given bytes using SHA3-512.
     *
     * This is an alias for `Keccak.nistSha3(512, bytes)`.\
     * See {@link Keccak.nistSha3} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.nistSha3(512, bytes);
    }
  },
  /**
   * The pre-NIST Keccak hash function with an output length of 256 bits.
   */
  Keccak256: {
    /**
     * Hashes the given bytes using Keccak-256.
     *
     * This is an alias for `Keccak.preNist(256, bytes)`.\
     * See {@link Keccak.preNist} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.preNist(256, bytes);
    }
  },
  /**
   * The pre-NIST Keccak hash function with an output length of 384 bits.
   */
  Keccak384: {
    /**
     * Hashes the given bytes using Keccak-384.
     *
     * This is an alias for `Keccak.preNist(384, bytes)`.\
     * See {@link Keccak.preNist} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.preNist(384, bytes);
    }
  },
  /**
   * The pre-NIST Keccak hash function with an output length of 512 bits.
   */
  Keccak512: {
    /**
     * Hashes the given bytes using Keccak-512.
     *
     * This is an alias for `Keccak.preNist(512, bytes)`.\
     * See {@link Keccak.preNist} for details and usage examples.
     */
    hash(bytes) {
      return Keccak.preNist(512, bytes);
    }
  }
};

// dist/node/lib/signature.js
var import_tslib4 = require("tslib");

// dist/node/mina-signer/src/signature.js
var import_blakejs = require("blakejs");

// dist/node/provable/poseidon-bigint.js
var HashInput2 = createHashInput();
var HashHelpers2 = createHashHelpers(Field, Poseidon);
var { hashWithPrefix: hashWithPrefix2 } = HashHelpers2;
var HashLegacy = createHashHelpers(Field, PoseidonLegacy);
function packToFields2({ fields = [], packed = [] }) {
  if (packed.length === 0)
    return fields;
  let packedBits = [];
  let currentPackedField = 0n;
  let currentSize = 0;
  for (let [field, size] of packed) {
    currentSize += size;
    if (currentSize < 255) {
      currentPackedField = currentPackedField * (1n << BigInt(size)) + field;
    } else {
      packedBits.push(currentPackedField);
      currentSize = size;
      currentPackedField = field;
    }
  }
  packedBits.push(currentPackedField);
  return fields.concat(packedBits);
}
function packToFieldsLegacy({ fields, bits: bits2 }) {
  let packedFields = [];
  while (bits2.length > 0) {
    let fieldBits = bits2.splice(0, sizeInBits - 1);
    let field = Field.fromBits(fieldBits);
    packedFields.push(field);
  }
  return fields.concat(packedFields);
}
var HashInputLegacy = {
  empty() {
    return { fields: [], bits: [] };
  },
  bits(bits2) {
    return { fields: [], bits: bits2 };
  },
  append(input1, input2) {
    return {
      fields: (input1.fields ?? []).concat(input2.fields ?? []),
      bits: (input1.bits ?? []).concat(input2.bits ?? [])
    };
  }
};

// dist/node/mina-signer/src/signature.js
var networkIdMainnet = 0x01n;
var networkIdTestnet = 0x00n;
var BinableSignature = withVersionNumber(record({ r: Field, s: Scalar }, ["r", "s"]), versionNumbers.signature);
var Signature = {
  ...BinableSignature,
  ...base58(BinableSignature, versionBytes.signature),
  toJSON({ r, s }) {
    return {
      field: Field.toJSON(r),
      scalar: Scalar.toJSON(s)
    };
  },
  fromJSON({ field, scalar }) {
    let r = Field.fromJSON(field);
    let s = Scalar.fromJSON(scalar);
    return { r, s };
  },
  dummy() {
    return { r: Field(1), s: Scalar(1) };
  }
};
function signFieldElement(message, privateKey, networkId) {
  return sign2({ fields: [message] }, privateKey, networkId);
}
function verifyFieldElement(signature, message, publicKey, networkId) {
  return verify2(signature, { fields: [message] }, publicKey, networkId);
}
function sign2(message, privateKey, networkId) {
  let publicKey = Group.scale(Group.generatorMina, privateKey);
  let kPrime = deriveNonce(message, publicKey, privateKey, networkId);
  if (Scalar.equal(kPrime, 0n))
    throw Error("sign: derived nonce is 0");
  let { x: rx, y: ry } = Group.scale(Group.generatorMina, kPrime);
  let k = Field.isEven(ry) ? kPrime : Scalar.negate(kPrime);
  let e = hashMessage(message, publicKey, rx, networkId);
  let s = Scalar.add(k, Scalar.mul(e, privateKey));
  return { r: rx, s };
}
function deriveNonce(message, publicKey, privateKey, networkId) {
  let { x, y } = publicKey;
  let d = Field(privateKey);
  let id = networkId === "mainnet" ? networkIdMainnet : networkIdTestnet;
  let input = HashInput2.append(message, {
    fields: [x, y, d],
    packed: [[id, 8]]
  });
  let packedInput = packToFields2(input);
  let inputBits = packedInput.map(Field.toBits).flat();
  let inputBytes = bitsToBytes(inputBits);
  let bytes = (0, import_blakejs.blake2b)(Uint8Array.from(inputBytes), void 0, 32);
  bytes[bytes.length - 1] &= 63;
  return Scalar.fromBytes([...bytes]);
}
function hashMessage(message, publicKey, r, networkId) {
  let { x, y } = publicKey;
  let input = HashInput2.append(message, { fields: [x, y, r] });
  let prefix = networkId === "mainnet" ? prefixes.signatureMainnet : prefixes.signatureTestnet;
  return hashWithPrefix2(prefix, packToFields2(input));
}
function verify2(signature, message, publicKey, networkId) {
  let { r, s } = signature;
  let pk = PublicKey.toGroup(publicKey);
  let e = hashMessage(message, pk, r, networkId);
  let { scale: scale2, one, sub } = Pallas;
  let R = sub(scale2(one, s), scale2(Group.toProjective(pk), e));
  try {
    let { x: rx, y: ry } = Group.fromProjective(R);
    return Field.isEven(ry) && Field.equal(rx, r);
  } catch {
    return false;
  }
}

// dist/node/lib/signature.js
var PrivateKey2 = class _PrivateKey extends CircuitValue {
  constructor(s) {
    super(s);
  }
  /**
   * You can use this method to generate a private key. You can then obtain
   * the associated public key via {@link toPublicKey}. And generate signatures
   * via {@link Signature.create}.
   *
   * @returns a new {@link PrivateKey}.
   */
  static random() {
    return new _PrivateKey(Scalar3.random());
  }
  /**
   * Deserializes a list of bits into a {@link PrivateKey}.
   *
   * @param bs a list of {@link Bool}.
   * @returns a {@link PrivateKey}.
   */
  static fromBits(bs) {
    return new _PrivateKey(Scalar3.fromBits(bs));
  }
  /**
   * Convert this {@link PrivateKey} to a bigint
   */
  toBigInt() {
    return constantScalarToBigint(this.s, "PrivateKey.toBigInt");
  }
  /**
   * Create a {@link PrivateKey} from a bigint
   *
   * **Warning**: Private keys should be sampled from secure randomness with sufficient entropy.
   * Be careful that you don't use this method to create private keys that were sampled insecurely.
   */
  static fromBigInt(sk) {
    return new _PrivateKey(Scalar3.from(sk));
  }
  /**
   * Derives the associated public key.
   *
   * @returns a {@link PublicKey}.
   */
  toPublicKey() {
    return PublicKey2.fromPrivateKey(this);
  }
  /**
   * Decodes a base58 string into a {@link PrivateKey}.
   *
   * @returns a {@link PrivateKey}.
   */
  static fromBase58(privateKeyBase58) {
    let scalar = PrivateKey.fromBase58(privateKeyBase58);
    return new _PrivateKey(Scalar3.from(scalar));
  }
  /**
   * Encodes a {@link PrivateKey} into a base58 string.
   * @returns a base58 encoded string
   */
  toBase58() {
    return _PrivateKey.toBase58(this);
  }
  // static version, to operate on non-class versions of this type
  /**
   * Static method to encode a {@link PrivateKey} into a base58 string.
   * @returns a base58 encoded string
   */
  static toBase58(privateKey) {
    return PrivateKey.toBase58(constantScalarToBigint(privateKey.s, "PrivateKey.toBase58"));
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Scalar3)
], PrivateKey2.prototype, "s", void 0);
var PublicKey2 = class _PublicKey extends CircuitValue {
  /**
   * Returns the {@link Group} representation of this {@link PublicKey}.
   * @returns A {@link Group}
   */
  toGroup() {
    let { x, isOdd } = this;
    let ySquared = x.mul(x).mul(x).add(5);
    let someY = ySquared.sqrt();
    let isTheRightY = isOdd.equals(someY.toBits()[0]);
    let y = isTheRightY.toField().mul(someY).add(isTheRightY.not().toField().mul(someY.neg()));
    return new Group3({ x, y });
  }
  /**
   * Creates a {@link PublicKey} from a {@link Group} element.
   * @returns a {@link PublicKey}.
   */
  static fromGroup({ x, y }) {
    let isOdd = y.toBits()[0];
    return _PublicKey.fromObject({ x, isOdd });
  }
  /**
   * Derives a {@link PublicKey} from a {@link PrivateKey}.
   * @returns a {@link PublicKey}.
   */
  static fromPrivateKey({ s }) {
    return _PublicKey.fromGroup(Group3.generator.scale(s));
  }
  /**
   * Creates a {@link PublicKey} from a JSON structure element.
   * @returns a {@link PublicKey}.
   */
  static from(g) {
    return _PublicKey.fromObject(g);
  }
  /**
   * Creates an empty {@link PublicKey}.
   * @returns an empty {@link PublicKey}
   */
  static empty() {
    return _PublicKey.from({ x: Field4(0), isOdd: Bool4(false) });
  }
  /**
   * Checks if a {@link PublicKey} is empty.
   * @returns a {@link Bool}
   */
  isEmpty() {
    return this.x.isZero();
  }
  /**
   * Decodes a base58 encoded {@link PublicKey} into a {@link PublicKey}.
   * @returns a {@link PublicKey}
   */
  static fromBase58(publicKeyBase58) {
    let { x, isOdd } = PublicKey.fromBase58(publicKeyBase58);
    return _PublicKey.from({ x: Field4(x), isOdd: Bool4(!!isOdd) });
  }
  /**
   * Encodes a {@link PublicKey} in base58 format.
   * @returns a base58 encoded {@link PublicKey}
   */
  toBase58() {
    return _PublicKey.toBase58(this);
  }
  /**
   * Static method to encode a {@link PublicKey} into base58 format.
   * @returns a base58 encoded {@link PublicKey}
   */
  static toBase58({ x, isOdd }) {
    x = toConstantField(x, "toBase58", "pk", "public key");
    return PublicKey.toBase58({
      x: x.toBigInt(),
      isOdd: Bool(isOdd.toBoolean())
    });
  }
  /**
   * Serializes a {@link PublicKey} into its JSON representation.
   * @returns a JSON string
   */
  static toJSON(publicKey) {
    return publicKey.toBase58();
  }
  /**
   * Deserializes a JSON string into a {@link PublicKey}.
   * @returns a JSON string
   */
  static fromJSON(publicKey) {
    return _PublicKey.fromBase58(publicKey);
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Field4)
], PublicKey2.prototype, "x", void 0);
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Bool4)
], PublicKey2.prototype, "isOdd", void 0);
var Signature2 = class _Signature extends CircuitValue {
  /**
   * Signs a message using a {@link PrivateKey}.
   * @returns a {@link Signature}
   */
  static create(privKey, msg) {
    const publicKey = PublicKey2.fromPrivateKey(privKey).toGroup();
    const d = privKey.s;
    const kPrime = Scalar3.fromBigInt(deriveNonce({ fields: msg.map((f) => f.toBigInt()) }, { x: publicKey.x.toBigInt(), y: publicKey.y.toBigInt() }, BigInt(d.toJSON()), "testnet"));
    let { x: r, y: ry } = Group3.generator.scale(kPrime);
    const k = ry.toBits()[0].toBoolean() ? kPrime.neg() : kPrime;
    let h = hashWithPrefix(prefixes.signatureTestnet, msg.concat([publicKey.x, publicKey.y, r]));
    let e = unshift2(Scalar3.fromBits(h.toBits()));
    const s = e.mul(d).add(k);
    return new _Signature(r, s);
  }
  /**
   * Verifies the {@link Signature} using a message and the corresponding {@link PublicKey}.
   * @returns a {@link Bool}
   */
  verify(publicKey, msg) {
    const point = publicKey.toGroup();
    let h = hashWithPrefix(prefixes.signatureTestnet, msg.concat([point.x, point.y, this.r]));
    let e = Scalar3.fromBits(h.toBits());
    let r = scaleShifted(point, e).neg().add(Group3.generator.scale(this.s));
    return Bool4.and(r.x.equals(this.r), r.y.toBits()[0].equals(false));
  }
  /**
   * Decodes a base58 encoded signature into a {@link Signature}.
   */
  static fromBase58(signatureBase58) {
    let { r, s } = Signature.fromBase58(signatureBase58);
    return _Signature.fromObject({
      r: Field4(r),
      s: Scalar3.fromJSON(s.toString())
    });
  }
  /**
   * Encodes a {@link Signature} in base58 format.
   */
  toBase58() {
    let r = this.r.toBigInt();
    let s = BigInt(this.s.toJSON());
    return Signature.toBase58({ r, s });
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Field4)
], Signature2.prototype, "r", void 0);
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Scalar3)
], Signature2.prototype, "s", void 0);
function scaleShifted(point, shiftedScalar) {
  let oneHalfGroup = point.scale(Scalar3.fromBigInt(oneHalf2));
  let shiftGroup = oneHalfGroup.scale(Scalar3.fromBigInt(shift2));
  return oneHalfGroup.scale(shiftedScalar).sub(shiftGroup);
}
function unshift2(shiftedScalar) {
  return shiftedScalar.sub(Scalar3.fromBigInt(shift2)).mul(Scalar3.fromBigInt(oneHalf2));
}
var shift2 = Scalar(1n + 2n ** 255n);
var oneHalf2 = Scalar.inverse(2n);

// dist/node/lib/circuit.js
var import_reflect_metadata2 = require("reflect-metadata");
var Circuit = class {
  /**
   * Generates a proving key and a verification key for this circuit.
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * ```
   */
  static generateKeypair() {
    let main = mainFromCircuitData(this._main);
    let publicInputSize = this._main.publicInputType.sizeInFields();
    return prettifyStacktracePromise(withThreadPool(async () => {
      let keypair = Snarky.circuit.compile(main, publicInputSize);
      return new Keypair(keypair);
    }));
  }
  /**
   * Proves a statement using the private input, public input, and the {@link Keypair} of the circuit.
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * const proof = await MyCircuit.prove(privateInput, publicInput, keypair);
   * ```
   */
  static prove(privateInput, publicInput, keypair) {
    let main = mainFromCircuitData(this._main, privateInput);
    let publicInputSize = this._main.publicInputType.sizeInFields();
    let publicInputFields = this._main.publicInputType.toFields(publicInput);
    return prettifyStacktracePromise(withThreadPool(async () => {
      let proof = Snarky.circuit.prove(main, publicInputSize, MlFieldConstArray.to(publicInputFields), keypair.value);
      return new Proof2(proof);
    }));
  }
  /**
   * Verifies a proof using the public input, the proof, and the initial {@link Keypair} of the circuit.
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * const proof = await MyCircuit.prove(privateInput, publicInput, keypair);
   * const isValid = await MyCircuit.verify(publicInput, keypair.vk, proof);
   * ```
   */
  static verify(publicInput, verificationKey, proof) {
    let publicInputFields = this._main.publicInputType.toFields(publicInput);
    return prettifyStacktracePromise(withThreadPool(async () => Snarky.circuit.verify(MlFieldConstArray.to(publicInputFields), proof.value, verificationKey.value)));
  }
};
Circuit.witness = Provable.witness;
Circuit.asProver = Provable.asProver;
Circuit.runAndCheck = Provable.runAndCheck;
Circuit.runUnchecked = Provable.runUnchecked;
Circuit.constraintSystem = Provable.constraintSystem;
Circuit.array = Provable.Array;
Circuit.assertEqual = Provable.assertEqual;
Circuit.equal = Provable.equal;
Circuit.if = Provable.if;
Circuit.switch = Provable.switch;
Circuit.inProver = Provable.inProver;
Circuit.inCheckedComputation = Provable.inCheckedComputation;
Circuit.log = Provable.log;
var Keypair = class {
  constructor(value) {
    this.value = value;
  }
  verificationKey() {
    return new VerificationKey2(Snarky.circuit.keypair.getVerificationKey(this.value));
  }
  /**
   * Returns a low-level JSON representation of the {@link Circuit} from its {@link Keypair}:
   * a list of gates, each of which represents a row in a table, with certain coefficients and wires to other (row, column) pairs
   * @example
   * ```ts
   * const keypair = await MyCircuit.generateKeypair();
   * const json = MyProvable.witnessFromKeypair(keypair);
   * ```
   */
  constraintSystem() {
    try {
      return gatesFromJson(Snarky.circuit.keypair.getConstraintSystemJSON(this.value)).gates;
    } catch (error) {
      throw prettifyStacktrace(error);
    }
  }
};
var Proof2 = class {
  constructor(value) {
    this.value = value;
  }
};
var VerificationKey2 = class {
  constructor(value) {
    this.value = value;
  }
};
function public_(target, _key, index) {
  if (target._public === void 0) {
    target._public = [];
  }
  target._public.push(index);
}
function mainFromCircuitData(data, privateInput) {
  return function main(publicInputFields) {
    let id = snarkContext.enter({ inCheckedComputation: true });
    try {
      let publicInput = data.publicInputType.fromFields(MlFieldArray.from(publicInputFields));
      let privateInput_ = Provable.witness(data.privateInputType, () => privateInput);
      data.main(publicInput, privateInput_);
    } finally {
      snarkContext.leave(id);
    }
  };
}
function circuitMain(target, propertyName, _descriptor) {
  const paramTypes = Reflect.getMetadata("design:paramtypes", target, propertyName);
  const numArgs = paramTypes.length;
  const publicIndexSet = new Set(target._public);
  const witnessIndexSet = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < numArgs; ++i2) {
    if (!publicIndexSet.has(i2))
      witnessIndexSet.add(i2);
  }
  target._main = {
    main(publicInput, privateInput) {
      let args = [];
      for (let i2 = 0; i2 < numArgs; ++i2) {
        let nextInput = publicIndexSet.has(i2) ? publicInput : privateInput;
        args.push(nextInput.shift());
      }
      return target[propertyName].apply(target, args);
    },
    publicInputType: provableFromTuple(Array.from(publicIndexSet).map((i2) => paramTypes[i2])),
    privateInputType: provableFromTuple(Array.from(witnessIndexSet).map((i2) => paramTypes[i2]))
  };
}
function provableFromTuple(typs) {
  return {
    sizeInFields: () => {
      return typs.reduce((acc, typ) => acc + typ.sizeInFields(), 0);
    },
    toFields: (t) => {
      if (t.length !== typs.length) {
        throw new Error(`typOfArray: Expected ${typs.length}, got ${t.length}`);
      }
      let res = [];
      for (let i2 = 0; i2 < t.length; ++i2) {
        res.push(...typs[i2].toFields(t[i2]));
      }
      return res;
    },
    toAuxiliary() {
      return [];
    },
    fromFields: (xs) => {
      let offset = 0;
      let res = [];
      typs.forEach((typ) => {
        const n = typ.sizeInFields();
        res.push(typ.fromFields(xs.slice(offset, offset + n)));
        offset += n;
      });
      return res;
    },
    check(xs) {
      typs.forEach((typ, i2) => typ.check(xs[i2]));
    }
  };
}

// dist/node/bindings/mina-transaction/gen/transaction.js
var transaction_exports = {};
__export(transaction_exports, {
  Account: () => Account,
  AccountUpdate: () => AccountUpdate,
  ActionState: () => ActionState,
  Actions: () => Actions,
  AuthRequired: () => AuthRequired,
  Bool: () => Bool4,
  Events: () => Events,
  Field: () => Field4,
  Json: () => transaction_json_exports,
  PublicKey: () => PublicKey2,
  ReceiptChainHash: () => ReceiptChainHash,
  Sign: () => Sign3,
  StateHash: () => StateHash,
  TokenId: () => TokenId,
  TokenSymbol: () => TokenSymbol2,
  TypeMap: () => TypeMap,
  UInt32: () => UInt322,
  UInt64: () => UInt642,
  VerificationKeyHash: () => VerificationKeyHash,
  ZkappCommand: () => ZkappCommand,
  ZkappUri: () => ZkappUri,
  customTypes: () => customTypes,
  empty: () => empty2,
  provableFromLayout: () => provableFromLayout,
  toJSONEssential: () => toJSONEssential
});

// dist/node/lib/events.js
function createEvents({ Field: Field5, Poseidon: Poseidon3 }) {
  function initialState() {
    return [Field5(0), Field5(0), Field5(0)];
  }
  function salt2(prefix) {
    return Poseidon3.update(initialState(), [prefixToField(Field5, prefix)]);
  }
  function hashWithPrefix3(prefix, input) {
    let init = salt2(prefix);
    return Poseidon3.update(init, input)[0];
  }
  function emptyHashWithPrefix2(prefix) {
    return salt2(prefix)[0];
  }
  const Events3 = {
    empty() {
      let hash3 = emptyHashWithPrefix2("MinaZkappEventsEmpty");
      return { hash: hash3, data: [] };
    },
    pushEvent(events, event) {
      let eventHash = hashWithPrefix3(prefixes.event, event);
      let hash3 = hashWithPrefix3(prefixes.events, [events.hash, eventHash]);
      return { hash: hash3, data: [event, ...events.data] };
    },
    fromList(events) {
      return [...events].reverse().reduce(Events3.pushEvent, Events3.empty());
    },
    hash(events) {
      return Events3.fromList(events).hash;
    }
  };
  const EventsProvable = {
    ...Events3,
    ...dataAsHash({
      empty: Events3.empty,
      toJSON(data) {
        return data.map((row) => row.map((e) => Field5.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field5.fromJSON(e)));
        let hash3 = Events3.hash(data);
        return { data, hash: hash3 };
      }
    })
  };
  const Actions3 = {
    // same as events but w/ different hash prefixes
    empty() {
      let hash3 = emptyHashWithPrefix2("MinaZkappActionsEmpty");
      return { hash: hash3, data: [] };
    },
    pushEvent(actions, event) {
      let eventHash = hashWithPrefix3(prefixes.event, event);
      let hash3 = hashWithPrefix3(prefixes.sequenceEvents, [
        actions.hash,
        eventHash
      ]);
      return { hash: hash3, data: [event, ...actions.data] };
    },
    fromList(events) {
      return [...events].reverse().reduce(Actions3.pushEvent, Actions3.empty());
    },
    hash(events) {
      return this.fromList(events).hash;
    },
    // different than events
    emptyActionState() {
      return emptyHashWithPrefix2("MinaZkappActionStateEmptyElt");
    },
    updateSequenceState(state3, sequenceEventsHash) {
      return hashWithPrefix3(prefixes.sequenceEvents, [
        state3,
        sequenceEventsHash
      ]);
    }
  };
  const SequenceEventsProvable = {
    ...Actions3,
    ...dataAsHash({
      empty: Actions3.empty,
      toJSON(data) {
        return data.map((row) => row.map((e) => Field5.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field5.fromJSON(e)));
        let hash3 = Actions3.hash(data);
        return { data, hash: hash3 };
      }
    })
  };
  return { Events: EventsProvable, Actions: SequenceEventsProvable };
}
function dataAsHash({ empty: empty4, toJSON, fromJSON }) {
  return {
    empty: empty4,
    sizeInFields() {
      return 1;
    },
    toFields({ hash: hash3 }) {
      return [hash3];
    },
    toAuxiliary(value) {
      return [value?.data ?? empty4().data];
    },
    fromFields([hash3], [data]) {
      return { data, hash: hash3 };
    },
    toJSON({ data }) {
      return toJSON(data);
    },
    fromJSON(json) {
      return fromJSON(json);
    },
    check() {
    },
    toInput({ hash: hash3 }) {
      return { fields: [hash3] };
    }
  };
}

// dist/node/bindings/mina-transaction/derived-leaves.js
var tokenSymbolLength = 6;
function derivedLeafTypes({ Field: Field5, Bool: Bool5, HashHelpers: HashHelpers3, packToFields: packToFields3 }) {
  let { provable: provable3 } = createDerivers();
  const Encoding = fieldEncodings(Field5);
  const fieldBase = provable3(Field5);
  return {
    TokenId: createEncodedField(fieldBase, Encoding.TokenId, Field5(defaultTokenId)),
    StateHash: createEncodedField(fieldBase, Encoding.StateHash),
    TokenSymbol: createTokenSymbol(provable3({ field: Field5, symbol: String }), Field5),
    AuthRequired: createAuthRequired(provable3({
      constant: Bool5,
      signatureNecessary: Bool5,
      signatureSufficient: Bool5
    }), Bool5),
    ZkappUri: createZkappUri(Field5, HashHelpers3, packToFields3)
  };
}
function derivedLeafTypesSignable({ Field: Field5, Bool: Bool5, HashHelpers: HashHelpers3, packToFields: packToFields3 }) {
  let { signable: signable2 } = createDerivers();
  const Encoding = fieldEncodings(Field5);
  const fieldBase = signable2(Field5);
  return {
    TokenId: createEncodedField(fieldBase, Encoding.TokenId, Field5(defaultTokenId)),
    StateHash: createEncodedField(fieldBase, Encoding.StateHash),
    TokenSymbol: createTokenSymbol(signable2({ field: Field5, symbol: String }), Field5),
    AuthRequired: createAuthRequired(signable2({
      constant: Bool5,
      signatureNecessary: Bool5,
      signatureSufficient: Bool5
    }), Bool5),
    ZkappUri: createZkappUri(Field5, HashHelpers3, packToFields3)
  };
}
var defaultTokenId = 1;
function createEncodedField(base, encoding, empty4) {
  return {
    ...base,
    empty: empty4 !== void 0 ? () => empty4 : base.empty,
    toJSON(x) {
      return encoding.toBase58(x);
    },
    fromJSON(x) {
      return encoding.fromBase58(x);
    }
  };
}
function createTokenSymbol(base, Field5) {
  return {
    ...base,
    toInput({ field }) {
      return { packed: [[field, 48]] };
    },
    toJSON({ symbol }) {
      return symbol;
    },
    fromJSON(symbol) {
      let bytesLength = stringLengthInBytes(symbol);
      if (bytesLength > tokenSymbolLength)
        throw Error(`Token symbol ${symbol} should be a maximum of 6 bytes, but is ${bytesLength}`);
      return { symbol, field: prefixToField(Field5, symbol) };
    }
  };
}
function createAuthRequired(base, Bool5) {
  return {
    ...base,
    empty() {
      return {
        constant: Bool5(true),
        signatureNecessary: Bool5(false),
        signatureSufficient: Bool5(true)
      };
    },
    toJSON(x) {
      let c = Number(Bool5.toJSON(x.constant));
      let n = Number(Bool5.toJSON(x.signatureNecessary));
      let s = Number(Bool5.toJSON(x.signatureSufficient));
      switch (`${c}${n}${s}`) {
        case "110":
          return "Impossible";
        case "101":
          return "None";
        case "000":
          return "Proof";
        case "011":
          return "Signature";
        case "001":
          return "Either";
        default:
          throw Error("Unexpected permission");
      }
    },
    fromJSON(json) {
      let map = {
        Impossible: "110",
        None: "101",
        Proof: "000",
        Signature: "011",
        Either: "001"
      };
      let code = map[json];
      if (code === void 0)
        throw Error("Unexpected permission");
      let [constant, signatureNecessary, signatureSufficient] = code.split("").map((s) => Bool5(!!Number(s)));
      return { constant, signatureNecessary, signatureSufficient };
    }
  };
}
function createZkappUri(Field5, HashHelpers3, packToFields3) {
  function hashZkappUri(uri) {
    let bits2 = bytesToBits(stringToBytes(uri));
    bits2.push(true);
    let input = {
      packed: bits2.map((b2) => [Field5(Number(b2)), 1])
    };
    let packed = packToFields3(input);
    return HashHelpers3.hashWithPrefix(prefixes.zkappUri, packed);
  }
  return dataAsHash({
    empty() {
      let hash3 = HashHelpers3.hashWithPrefix(prefixes.zkappUri, [
        Field5(0),
        Field5(0)
      ]);
      return { data: "", hash: hash3 };
    },
    toJSON(data) {
      return data;
    },
    fromJSON(json) {
      return { data: json, hash: hashZkappUri(json) };
    }
  });
}

// dist/node/bindings/mina-transaction/transaction-leaves.js
var { TokenId, StateHash, TokenSymbol: TokenSymbol2, AuthRequired, ZkappUri } = derivedLeafTypes({ Field: Field4, Bool: Bool4, HashHelpers, packToFields });
var { Events, Actions } = createEvents({ Field: Field4, Poseidon: Poseidon2 });
var ActionState = {
  ...provable(Field4),
  empty: Actions.emptyActionState
};
var VerificationKeyHash = {
  ...provable(Field4),
  empty: () => Field4(mocks.dummyVerificationKeyHash)
};
var ReceiptChainHash = {
  ...provable(Field4),
  empty: () => emptyHashWithPrefix("CodaReceiptEmpty")
};

// dist/node/bindings/lib/from-layout.js
function SignableFromLayout(TypeMap3, customTypes3) {
  const Field5 = TypeMap3.Field;
  function layoutFold(spec, typeData, value) {
    return genericLayoutFold(TypeMap3, customTypes3, spec, typeData, value);
  }
  function signableFromLayout2(typeData) {
    return {
      toJSON(value) {
        return toJSON(typeData, value);
      },
      fromJSON(json) {
        return fromJSON(typeData, json);
      },
      toInput(value) {
        return toInput(typeData, value);
      },
      empty() {
        return empty4(typeData);
      }
    };
  }
  function toJSON(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(_, object) {
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  function fromJSON(typeData, json) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes3[checkedTypeName].fromJSON(json);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      return json.map((json2) => fromJSON(arrayTypeData.inner, json2));
    }
    if (typeData.type === "option") {
      let optionTypeData = typeData;
      switch (optionTypeData.optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let isSome = TypeMap3.Bool.fromJSON(json !== null);
          let value;
          if (json !== null) {
            value = fromJSON(optionTypeData.inner, json);
          } else {
            value = empty4(optionTypeData.inner);
            if (optionTypeData.optionType === "closedInterval") {
              let innerInner = optionTypeData.inner.entries.lower;
              let innerType = TypeMap3[innerInner.type];
              value.lower = innerType.fromJSON(optionTypeData.rangeMin);
              value.upper = innerType.fromJSON(optionTypeData.rangeMax);
            }
          }
          return { isSome, value };
        }
        case "orUndefined": {
          return json === null ? void 0 : fromJSON(optionTypeData.inner, json);
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      for (let i2 = 0; i2 < keys.length; i2++) {
        let typeEntry = entries[keys[i2]];
        values[keys[i2]] = fromJSON(typeEntry, json[keys[i2]]);
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return primitiveTypeMap[typeData.type].fromJSON(json);
    }
    return TypeMap3[typeData.type].fromJSON(json);
  }
  function empty4(typeData) {
    return layoutFold({
      map(type) {
        return type.empty();
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(_, object) {
        return object;
      },
      reduceFlaggedOption({ isSome, value }, typeData2) {
        if (typeData2.optionType === "closedInterval") {
          let innerInner = typeData2.inner.entries.lower;
          let innerType = TypeMap3[innerInner.type];
          value.lower = innerType.fromJSON(typeData2.rangeMin);
          value.upper = innerType.fromJSON(typeData2.rangeMax);
        }
        return { isSome, value };
      },
      reduceOrUndefined() {
        return void 0;
      }
    }, typeData, void 0);
  }
  function toInput(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toInput(value2);
      },
      reduceArray(array) {
        let acc = { fields: [], packed: [] };
        for (let { fields, packed } of array) {
          if (fields)
            acc.fields.push(...fields);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceObject(keys, object) {
        let acc = { fields: [], packed: [] };
        for (let key of keys) {
          let { fields, packed } = object[key];
          if (fields)
            acc.fields.push(...fields);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return {
          fields: value2.fields,
          packed: isSome.packed.concat(value2.packed ?? [])
        };
      },
      reduceOrUndefined(_) {
        return {};
      }
    }, typeData, value);
  }
  function toJSONEssential3(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        if (array.length === 0 || array.every((x) => x === null))
          return null;
        return array;
      },
      reduceObject(_, object) {
        for (let key in object) {
          if (object[key] === null) {
            delete object[key];
          }
        }
        if (Object.keys(object).length === 0)
          return null;
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  return {
    signableFromLayout: signableFromLayout2,
    toInput,
    toJSON,
    fromJSON,
    empty: empty4,
    toJSONEssential: toJSONEssential3
  };
}
function ProvableFromLayout(TypeMap3, customTypes3) {
  const Field5 = TypeMap3.Field;
  const { toInput, toJSON, fromJSON, empty: empty4, toJSONEssential: toJSONEssential3 } = SignableFromLayout(TypeMap3, customTypes3);
  function layoutFold(spec, typeData, value) {
    return genericLayoutFold(TypeMap3, customTypes3, spec, typeData, value);
  }
  function provableFromLayout2(typeData) {
    return {
      sizeInFields() {
        return sizeInFields(typeData);
      },
      toFields(value) {
        return toFields(typeData, value);
      },
      toAuxiliary(value) {
        return toAuxiliary(typeData, value);
      },
      fromFields(fields, aux) {
        return fromFields(typeData, fields, aux);
      },
      toJSON(value) {
        return toJSON(typeData, value);
      },
      fromJSON(json) {
        return fromJSON(typeData, json);
      },
      check(value) {
        check(typeData, value);
      },
      toInput(value) {
        return toInput(typeData, value);
      },
      empty() {
        return empty4(typeData);
      }
    };
  }
  function toFields(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toFields(value2);
      },
      reduceArray(array) {
        return array.flat();
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).flat();
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return [isSome, value2].flat();
      },
      reduceOrUndefined(_) {
        return [];
      }
    }, typeData, value);
  }
  function toAuxiliary(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toAuxiliary(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]);
      },
      reduceFlaggedOption({ value: value2 }) {
        return value2;
      },
      reduceOrUndefined(value2) {
        return value2 === void 0 ? [false] : [true, value2];
      }
    }, typeData, value);
  }
  function sizeInFields(typeData) {
    let spec = {
      map(type) {
        return type.sizeInFields();
      },
      reduceArray(_, { inner, staticLength }) {
        let length = staticLength ?? NaN;
        return length * layoutFold(spec, inner);
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).reduce((x, y) => x + y);
      },
      reduceFlaggedOption({ isSome, value }) {
        return isSome + value;
      },
      reduceOrUndefined(_) {
        return 0;
      }
    };
    return layoutFold(spec, typeData);
  }
  function fromFields(typeData, fields, aux) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes3[checkedTypeName].fromFields(fields, aux);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      let size = sizeInFields(arrayTypeData.inner);
      let length = aux.length;
      let value = [];
      for (let i2 = 0, offset = 0; i2 < length; i2++, offset += size) {
        value[i2] = fromFields(arrayTypeData.inner, fields.slice(offset, offset + size), aux[i2]);
      }
      return value;
    }
    if (typeData.type === "option") {
      let { optionType, inner } = typeData;
      switch (optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let [first, ...rest] = fields;
          let isSome = TypeMap3.Bool.fromFields([first], []);
          let value = fromFields(inner, rest, aux);
          return { isSome, value };
        }
        case "orUndefined": {
          let [isDefined, value] = aux;
          return isDefined ? fromFields(inner, fields, value) : void 0;
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      let offset = 0;
      for (let i2 = 0; i2 < keys.length; i2++) {
        let typeEntry = entries[keys[i2]];
        let size = sizeInFields(typeEntry);
        values[keys[i2]] = fromFields(typeEntry, fields.slice(offset, offset + size), aux[i2]);
        offset += size;
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return primitiveTypeMap[typeData.type].fromFields(fields, aux);
    }
    return TypeMap3[typeData.type].fromFields(fields, aux);
  }
  function check(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.check(value2);
      },
      reduceArray() {
      },
      reduceObject() {
      },
      reduceFlaggedOption() {
      },
      reduceOrUndefined() {
      }
    }, typeData, value);
  }
  return { provableFromLayout: provableFromLayout2, toJSONEssential: toJSONEssential3, empty: empty4 };
}
function genericLayoutFold(TypeMap3, customTypes3, spec, typeData, value) {
  let { checkedTypeName } = typeData;
  if (checkedTypeName) {
    return spec.map(customTypes3[checkedTypeName], value, checkedTypeName);
  }
  if (typeData.type === "array") {
    let arrayTypeData = typeData;
    let v = value;
    if (arrayTypeData.staticLength !== null && v === void 0) {
      v = Array(arrayTypeData.staticLength).fill(void 0);
    }
    let array = v?.map((x) => genericLayoutFold(TypeMap3, customTypes3, spec, arrayTypeData.inner, x)) ?? [];
    return spec.reduceArray(array, arrayTypeData);
  }
  if (typeData.type === "option") {
    let { optionType, inner } = typeData;
    switch (optionType) {
      case "closedInterval":
      case "flaggedOption":
        let v = value;
        return spec.reduceFlaggedOption({
          isSome: spec.map(TypeMap3.Bool, v?.isSome, "Bool"),
          value: genericLayoutFold(TypeMap3, customTypes3, spec, inner, v?.value)
        }, typeData);
      case "orUndefined":
        let mapped = value === void 0 ? void 0 : genericLayoutFold(TypeMap3, customTypes3, spec, inner, value);
        return spec.reduceOrUndefined(mapped, inner);
      default:
        throw Error("bug");
    }
  }
  if (typeData.type === "object") {
    let { keys, entries } = typeData;
    let v = value;
    let object = {};
    keys.forEach((key) => {
      object[key] = genericLayoutFold(TypeMap3, customTypes3, spec, entries[key], v?.[key]);
    });
    return spec.reduceObject(keys, object);
  }
  if (primitiveTypes.has(typeData.type)) {
    return spec.map(primitiveTypeMap[typeData.type], value, typeData.type);
  }
  return spec.map(TypeMap3[typeData.type], value, typeData.type);
}

// dist/node/bindings/mina-transaction/gen/transaction-json.js
var transaction_json_exports = {};

// dist/node/bindings/mina-transaction/gen/js-layout.js
var jsLayout = {
  ZkappCommand: {
    type: "object",
    name: "ZkappCommand",
    docs: null,
    keys: ["feePayer", "accountUpdates", "memo"],
    entries: {
      feePayer: {
        type: "object",
        name: "ZkappFeePayer",
        docs: null,
        keys: ["body", "authorization"],
        entries: {
          body: {
            type: "object",
            name: "FeePayerBody",
            docs: null,
            keys: ["publicKey", "fee", "validUntil", "nonce"],
            entries: {
              publicKey: { type: "PublicKey" },
              fee: { type: "UInt64" },
              validUntil: {
                type: "option",
                optionType: "orUndefined",
                inner: { type: "UInt32" }
              },
              nonce: { type: "UInt32" }
            },
            docEntries: {
              publicKey: null,
              fee: null,
              validUntil: null,
              nonce: null
            }
          },
          authorization: { type: "string" }
        },
        docEntries: { body: null, authorization: null }
      },
      accountUpdates: {
        type: "array",
        inner: {
          type: "object",
          name: "ZkappAccountUpdate",
          docs: "An account update in a zkApp transaction",
          keys: ["body", "authorization"],
          entries: {
            body: {
              type: "object",
              name: "AccountUpdateBody",
              docs: null,
              keys: [
                "publicKey",
                "tokenId",
                "update",
                "balanceChange",
                "incrementNonce",
                "events",
                "actions",
                "callData",
                "callDepth",
                "preconditions",
                "useFullCommitment",
                "implicitAccountCreationFee",
                "mayUseToken",
                "authorizationKind"
              ],
              entries: {
                publicKey: { type: "PublicKey" },
                tokenId: { type: "TokenId" },
                update: {
                  type: "object",
                  name: "AccountUpdateModification",
                  docs: null,
                  keys: [
                    "appState",
                    "delegate",
                    "verificationKey",
                    "permissions",
                    "zkappUri",
                    "tokenSymbol",
                    "timing",
                    "votingFor"
                  ],
                  entries: {
                    appState: {
                      type: "array",
                      inner: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      staticLength: 8
                    },
                    delegate: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "PublicKey" }
                    },
                    verificationKey: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "VerificationKeyWithHash",
                        docs: null,
                        keys: ["data", "hash"],
                        entries: {
                          data: { type: "string" },
                          hash: { type: "Field" }
                        },
                        docEntries: { data: null, hash: null }
                      }
                    },
                    permissions: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Permissions",
                        docs: null,
                        keys: [
                          "editState",
                          "access",
                          "send",
                          "receive",
                          "setDelegate",
                          "setPermissions",
                          "setVerificationKey",
                          "setZkappUri",
                          "editActionState",
                          "setTokenSymbol",
                          "incrementNonce",
                          "setVotingFor",
                          "setTiming"
                        ],
                        entries: {
                          editState: { type: "AuthRequired" },
                          access: { type: "AuthRequired" },
                          send: { type: "AuthRequired" },
                          receive: { type: "AuthRequired" },
                          setDelegate: { type: "AuthRequired" },
                          setPermissions: { type: "AuthRequired" },
                          setVerificationKey: { type: "AuthRequired" },
                          setZkappUri: { type: "AuthRequired" },
                          editActionState: { type: "AuthRequired" },
                          setTokenSymbol: { type: "AuthRequired" },
                          incrementNonce: { type: "AuthRequired" },
                          setVotingFor: { type: "AuthRequired" },
                          setTiming: { type: "AuthRequired" }
                        },
                        docEntries: {
                          editState: null,
                          access: null,
                          send: null,
                          receive: null,
                          setDelegate: null,
                          setPermissions: null,
                          setVerificationKey: null,
                          setZkappUri: null,
                          editActionState: null,
                          setTokenSymbol: null,
                          incrementNonce: null,
                          setVotingFor: null,
                          setTiming: null
                        }
                      }
                    },
                    zkappUri: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: {
                          type: "object",
                          name: "Events",
                          docs: null,
                          keys: ["data", "hash"],
                          entries: {
                            data: { type: "string" },
                            hash: { type: "Field" }
                          },
                          docEntries: { data: null, hash: null }
                        },
                        checkedTypeName: "ZkappUri"
                      }
                    },
                    tokenSymbol: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: {
                          type: "object",
                          name: "Anonymous",
                          docs: null,
                          keys: ["symbol", "field"],
                          entries: {
                            symbol: { type: "string" },
                            field: { type: "Field" }
                          },
                          docEntries: { symbol: "", field: "" }
                        },
                        checkedTypeName: "TokenSymbol"
                      }
                    },
                    timing: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Timing",
                        docs: null,
                        keys: [
                          "initialMinimumBalance",
                          "cliffTime",
                          "cliffAmount",
                          "vestingPeriod",
                          "vestingIncrement"
                        ],
                        entries: {
                          initialMinimumBalance: { type: "UInt64" },
                          cliffTime: { type: "UInt32" },
                          cliffAmount: { type: "UInt64" },
                          vestingPeriod: { type: "UInt32" },
                          vestingIncrement: { type: "UInt64" }
                        },
                        docEntries: {
                          initialMinimumBalance: null,
                          cliffTime: null,
                          cliffAmount: null,
                          vestingPeriod: null,
                          vestingIncrement: null
                        }
                      }
                    },
                    votingFor: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "Field",
                        checkedType: { type: "Field" },
                        checkedTypeName: "StateHash"
                      }
                    }
                  },
                  docEntries: {
                    appState: null,
                    delegate: null,
                    verificationKey: null,
                    permissions: null,
                    zkappUri: null,
                    tokenSymbol: null,
                    timing: null,
                    votingFor: null
                  }
                },
                balanceChange: {
                  type: "object",
                  name: "BalanceChange",
                  docs: null,
                  keys: ["magnitude", "sgn"],
                  entries: {
                    magnitude: { type: "UInt64" },
                    sgn: { type: "Sign" }
                  },
                  docEntries: { magnitude: null, sgn: null }
                },
                incrementNonce: { type: "Bool" },
                events: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "Events"
                },
                actions: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "Actions"
                },
                callData: { type: "Field" },
                callDepth: { type: "number" },
                preconditions: {
                  type: "object",
                  name: "Preconditions",
                  docs: null,
                  keys: ["network", "account", "validWhile"],
                  entries: {
                    network: {
                      type: "object",
                      name: "NetworkPrecondition",
                      docs: null,
                      keys: [
                        "snarkedLedgerHash",
                        "blockchainLength",
                        "minWindowDensity",
                        "totalCurrency",
                        "globalSlotSinceGenesis",
                        "stakingEpochData",
                        "nextEpochData"
                      ],
                      entries: {
                        snarkedLedgerHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        blockchainLength: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        minWindowDensity: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        totalCurrency: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "CurrencyAmountInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        globalSlotSinceGenesis: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "GlobalSlotSinceGenesisInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        stakingEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        },
                        nextEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        }
                      },
                      docEntries: {
                        snarkedLedgerHash: null,
                        blockchainLength: null,
                        minWindowDensity: null,
                        totalCurrency: null,
                        globalSlotSinceGenesis: null,
                        stakingEpochData: null,
                        nextEpochData: null
                      }
                    },
                    account: {
                      type: "object",
                      name: "AccountPrecondition",
                      docs: null,
                      keys: [
                        "balance",
                        "nonce",
                        "receiptChainHash",
                        "delegate",
                        "state",
                        "actionState",
                        "provedState",
                        "isNew"
                      ],
                      entries: {
                        balance: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "BalanceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        nonce: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "NonceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        receiptChainHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        delegate: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "PublicKey" }
                        },
                        state: {
                          type: "array",
                          inner: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          staticLength: 8
                        },
                        actionState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: {
                            type: "Field",
                            checkedType: { type: "Field" },
                            checkedTypeName: "ActionState"
                          }
                        },
                        provedState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        },
                        isNew: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        }
                      },
                      docEntries: {
                        balance: null,
                        nonce: null,
                        receiptChainHash: null,
                        delegate: null,
                        state: null,
                        actionState: null,
                        provedState: null,
                        isNew: null
                      }
                    },
                    validWhile: {
                      type: "option",
                      optionType: "closedInterval",
                      rangeMin: "0",
                      rangeMax: "4294967295",
                      inner: {
                        type: "object",
                        name: "GlobalSlotSinceGenesisInterval",
                        docs: null,
                        keys: ["lower", "upper"],
                        entries: {
                          lower: { type: "UInt32" },
                          upper: { type: "UInt32" }
                        },
                        docEntries: { lower: null, upper: null }
                      }
                    }
                  },
                  docEntries: {
                    network: null,
                    account: null,
                    validWhile: null
                  }
                },
                useFullCommitment: { type: "Bool" },
                implicitAccountCreationFee: { type: "Bool" },
                mayUseToken: {
                  type: "object",
                  name: "MayUseToken",
                  docs: null,
                  keys: ["parentsOwnToken", "inheritFromParent"],
                  entries: {
                    parentsOwnToken: { type: "Bool" },
                    inheritFromParent: { type: "Bool" }
                  },
                  docEntries: {
                    parentsOwnToken: null,
                    inheritFromParent: null
                  }
                },
                authorizationKind: {
                  type: "object",
                  name: "AuthorizationKindStructured",
                  docs: null,
                  keys: ["isSigned", "isProved", "verificationKeyHash"],
                  entries: {
                    isSigned: { type: "Bool" },
                    isProved: { type: "Bool" },
                    verificationKeyHash: {
                      type: "Field",
                      checkedType: { type: "Field" },
                      checkedTypeName: "VerificationKeyHash"
                    }
                  },
                  docEntries: {
                    isSigned: null,
                    isProved: null,
                    verificationKeyHash: null
                  }
                }
              },
              docEntries: {
                publicKey: null,
                tokenId: null,
                update: null,
                balanceChange: null,
                incrementNonce: null,
                events: null,
                actions: null,
                callData: null,
                callDepth: null,
                preconditions: null,
                useFullCommitment: null,
                implicitAccountCreationFee: null,
                mayUseToken: null,
                authorizationKind: null
              }
            },
            authorization: {
              type: "object",
              name: "Control",
              docs: null,
              keys: ["proof", "signature"],
              entries: {
                proof: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                },
                signature: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                }
              },
              docEntries: { proof: null, signature: null }
            }
          },
          docEntries: { body: null, authorization: null }
        },
        staticLength: null
      },
      memo: { type: "string" }
    },
    docEntries: { feePayer: null, accountUpdates: null, memo: null }
  },
  AccountUpdate: {
    type: "object",
    name: "ZkappAccountUpdate",
    docs: "An account update in a zkApp transaction",
    keys: ["body", "authorization"],
    entries: {
      body: {
        type: "object",
        name: "AccountUpdateBody",
        docs: null,
        keys: [
          "publicKey",
          "tokenId",
          "update",
          "balanceChange",
          "incrementNonce",
          "events",
          "actions",
          "callData",
          "callDepth",
          "preconditions",
          "useFullCommitment",
          "implicitAccountCreationFee",
          "mayUseToken",
          "authorizationKind"
        ],
        entries: {
          publicKey: { type: "PublicKey" },
          tokenId: { type: "TokenId" },
          update: {
            type: "object",
            name: "AccountUpdateModification",
            docs: null,
            keys: [
              "appState",
              "delegate",
              "verificationKey",
              "permissions",
              "zkappUri",
              "tokenSymbol",
              "timing",
              "votingFor"
            ],
            entries: {
              appState: {
                type: "array",
                inner: {
                  type: "option",
                  optionType: "flaggedOption",
                  inner: { type: "Field" }
                },
                staticLength: 8
              },
              delegate: {
                type: "option",
                optionType: "flaggedOption",
                inner: { type: "PublicKey" }
              },
              verificationKey: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "VerificationKeyWithHash",
                  docs: null,
                  keys: ["data", "hash"],
                  entries: {
                    data: { type: "string" },
                    hash: { type: "Field" }
                  },
                  docEntries: { data: null, hash: null }
                }
              },
              permissions: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Permissions",
                  docs: null,
                  keys: [
                    "editState",
                    "access",
                    "send",
                    "receive",
                    "setDelegate",
                    "setPermissions",
                    "setVerificationKey",
                    "setZkappUri",
                    "editActionState",
                    "setTokenSymbol",
                    "incrementNonce",
                    "setVotingFor",
                    "setTiming"
                  ],
                  entries: {
                    editState: { type: "AuthRequired" },
                    access: { type: "AuthRequired" },
                    send: { type: "AuthRequired" },
                    receive: { type: "AuthRequired" },
                    setDelegate: { type: "AuthRequired" },
                    setPermissions: { type: "AuthRequired" },
                    setVerificationKey: { type: "AuthRequired" },
                    setZkappUri: { type: "AuthRequired" },
                    editActionState: { type: "AuthRequired" },
                    setTokenSymbol: { type: "AuthRequired" },
                    incrementNonce: { type: "AuthRequired" },
                    setVotingFor: { type: "AuthRequired" },
                    setTiming: { type: "AuthRequired" }
                  },
                  docEntries: {
                    editState: null,
                    access: null,
                    send: null,
                    receive: null,
                    setDelegate: null,
                    setPermissions: null,
                    setVerificationKey: null,
                    setZkappUri: null,
                    editActionState: null,
                    setTokenSymbol: null,
                    incrementNonce: null,
                    setVotingFor: null,
                    setTiming: null
                  }
                }
              },
              zkappUri: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: { type: "string" },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "ZkappUri"
                }
              },
              tokenSymbol: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: {
                    type: "object",
                    name: "Anonymous",
                    docs: null,
                    keys: ["symbol", "field"],
                    entries: {
                      symbol: { type: "string" },
                      field: { type: "Field" }
                    },
                    docEntries: { symbol: "", field: "" }
                  },
                  checkedTypeName: "TokenSymbol"
                }
              },
              timing: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Timing",
                  docs: null,
                  keys: [
                    "initialMinimumBalance",
                    "cliffTime",
                    "cliffAmount",
                    "vestingPeriod",
                    "vestingIncrement"
                  ],
                  entries: {
                    initialMinimumBalance: { type: "UInt64" },
                    cliffTime: { type: "UInt32" },
                    cliffAmount: { type: "UInt64" },
                    vestingPeriod: { type: "UInt32" },
                    vestingIncrement: { type: "UInt64" }
                  },
                  docEntries: {
                    initialMinimumBalance: null,
                    cliffTime: null,
                    cliffAmount: null,
                    vestingPeriod: null,
                    vestingIncrement: null
                  }
                }
              },
              votingFor: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "Field",
                  checkedType: { type: "Field" },
                  checkedTypeName: "StateHash"
                }
              }
            },
            docEntries: {
              appState: null,
              delegate: null,
              verificationKey: null,
              permissions: null,
              zkappUri: null,
              tokenSymbol: null,
              timing: null,
              votingFor: null
            }
          },
          balanceChange: {
            type: "object",
            name: "BalanceChange",
            docs: null,
            keys: ["magnitude", "sgn"],
            entries: { magnitude: { type: "UInt64" }, sgn: { type: "Sign" } },
            docEntries: { magnitude: null, sgn: null }
          },
          incrementNonce: { type: "Bool" },
          events: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "Events"
          },
          actions: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "Actions"
          },
          callData: { type: "Field" },
          callDepth: { type: "number" },
          preconditions: {
            type: "object",
            name: "Preconditions",
            docs: null,
            keys: ["network", "account", "validWhile"],
            entries: {
              network: {
                type: "object",
                name: "NetworkPrecondition",
                docs: null,
                keys: [
                  "snarkedLedgerHash",
                  "blockchainLength",
                  "minWindowDensity",
                  "totalCurrency",
                  "globalSlotSinceGenesis",
                  "stakingEpochData",
                  "nextEpochData"
                ],
                entries: {
                  snarkedLedgerHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  blockchainLength: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  minWindowDensity: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  totalCurrency: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "CurrencyAmountInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  globalSlotSinceGenesis: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "GlobalSlotSinceGenesisInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  stakingEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  },
                  nextEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  }
                },
                docEntries: {
                  snarkedLedgerHash: null,
                  blockchainLength: null,
                  minWindowDensity: null,
                  totalCurrency: null,
                  globalSlotSinceGenesis: null,
                  stakingEpochData: null,
                  nextEpochData: null
                }
              },
              account: {
                type: "object",
                name: "AccountPrecondition",
                docs: null,
                keys: [
                  "balance",
                  "nonce",
                  "receiptChainHash",
                  "delegate",
                  "state",
                  "actionState",
                  "provedState",
                  "isNew"
                ],
                entries: {
                  balance: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "BalanceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  nonce: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "NonceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  receiptChainHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  delegate: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "PublicKey" }
                  },
                  state: {
                    type: "array",
                    inner: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "Field" }
                    },
                    staticLength: 8
                  },
                  actionState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: {
                      type: "Field",
                      checkedType: { type: "Field" },
                      checkedTypeName: "ActionState"
                    }
                  },
                  provedState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  },
                  isNew: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  }
                },
                docEntries: {
                  balance: null,
                  nonce: null,
                  receiptChainHash: null,
                  delegate: null,
                  state: null,
                  actionState: null,
                  provedState: null,
                  isNew: null
                }
              },
              validWhile: {
                type: "option",
                optionType: "closedInterval",
                rangeMin: "0",
                rangeMax: "4294967295",
                inner: {
                  type: "object",
                  name: "GlobalSlotSinceGenesisInterval",
                  docs: null,
                  keys: ["lower", "upper"],
                  entries: {
                    lower: { type: "UInt32" },
                    upper: { type: "UInt32" }
                  },
                  docEntries: { lower: null, upper: null }
                }
              }
            },
            docEntries: { network: null, account: null, validWhile: null }
          },
          useFullCommitment: { type: "Bool" },
          implicitAccountCreationFee: { type: "Bool" },
          mayUseToken: {
            type: "object",
            name: "MayUseToken",
            docs: null,
            keys: ["parentsOwnToken", "inheritFromParent"],
            entries: {
              parentsOwnToken: { type: "Bool" },
              inheritFromParent: { type: "Bool" }
            },
            docEntries: { parentsOwnToken: null, inheritFromParent: null }
          },
          authorizationKind: {
            type: "object",
            name: "AuthorizationKindStructured",
            docs: null,
            keys: ["isSigned", "isProved", "verificationKeyHash"],
            entries: {
              isSigned: { type: "Bool" },
              isProved: { type: "Bool" },
              verificationKeyHash: {
                type: "Field",
                checkedType: { type: "Field" },
                checkedTypeName: "VerificationKeyHash"
              }
            },
            docEntries: {
              isSigned: null,
              isProved: null,
              verificationKeyHash: null
            }
          }
        },
        docEntries: {
          publicKey: null,
          tokenId: null,
          update: null,
          balanceChange: null,
          incrementNonce: null,
          events: null,
          actions: null,
          callData: null,
          callDepth: null,
          preconditions: null,
          useFullCommitment: null,
          implicitAccountCreationFee: null,
          mayUseToken: null,
          authorizationKind: null
        }
      },
      authorization: {
        type: "object",
        name: "Control",
        docs: null,
        keys: ["proof", "signature"],
        entries: {
          proof: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          },
          signature: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          }
        },
        docEntries: { proof: null, signature: null }
      }
    },
    docEntries: { body: null, authorization: null }
  },
  Account: {
    type: "object",
    name: "Account",
    docs: null,
    keys: [
      "publicKey",
      "tokenId",
      "tokenSymbol",
      "balance",
      "nonce",
      "receiptChainHash",
      "delegate",
      "votingFor",
      "timing",
      "permissions",
      "zkapp"
    ],
    entries: {
      publicKey: { type: "PublicKey" },
      tokenId: { type: "TokenId" },
      tokenSymbol: { type: "string" },
      balance: { type: "UInt64" },
      nonce: { type: "UInt32" },
      receiptChainHash: {
        type: "Field",
        checkedType: { type: "Field" },
        checkedTypeName: "ReceiptChainHash"
      },
      delegate: {
        type: "option",
        optionType: "orUndefined",
        inner: { type: "PublicKey" }
      },
      votingFor: { type: "Field" },
      timing: {
        type: "object",
        name: "AccountTiming",
        docs: null,
        keys: [
          "isTimed",
          "initialMinimumBalance",
          "cliffTime",
          "cliffAmount",
          "vestingPeriod",
          "vestingIncrement"
        ],
        entries: {
          isTimed: { type: "Bool" },
          initialMinimumBalance: { type: "UInt64" },
          cliffTime: { type: "UInt32" },
          cliffAmount: { type: "UInt64" },
          vestingPeriod: { type: "UInt32" },
          vestingIncrement: { type: "UInt64" }
        },
        docEntries: {
          isTimed: null,
          initialMinimumBalance: null,
          cliffTime: null,
          cliffAmount: null,
          vestingPeriod: null,
          vestingIncrement: null
        }
      },
      permissions: {
        type: "object",
        name: "Permissions",
        docs: null,
        keys: [
          "editState",
          "access",
          "send",
          "receive",
          "setDelegate",
          "setPermissions",
          "setVerificationKey",
          "setZkappUri",
          "editActionState",
          "setTokenSymbol",
          "incrementNonce",
          "setVotingFor",
          "setTiming"
        ],
        entries: {
          editState: { type: "AuthRequired" },
          access: { type: "AuthRequired" },
          send: { type: "AuthRequired" },
          receive: { type: "AuthRequired" },
          setDelegate: { type: "AuthRequired" },
          setPermissions: { type: "AuthRequired" },
          setVerificationKey: { type: "AuthRequired" },
          setZkappUri: { type: "AuthRequired" },
          editActionState: { type: "AuthRequired" },
          setTokenSymbol: { type: "AuthRequired" },
          incrementNonce: { type: "AuthRequired" },
          setVotingFor: { type: "AuthRequired" },
          setTiming: { type: "AuthRequired" }
        },
        docEntries: {
          editState: null,
          access: null,
          send: null,
          receive: null,
          setDelegate: null,
          setPermissions: null,
          setVerificationKey: null,
          setZkappUri: null,
          editActionState: null,
          setTokenSymbol: null,
          incrementNonce: null,
          setVotingFor: null,
          setTiming: null
        }
      },
      zkapp: {
        type: "option",
        optionType: "orUndefined",
        inner: {
          type: "object",
          name: "ZkappAccount",
          docs: null,
          keys: [
            "appState",
            "verificationKey",
            "zkappVersion",
            "actionState",
            "lastActionSlot",
            "provedState",
            "zkappUri"
          ],
          entries: {
            appState: {
              type: "array",
              inner: { type: "Field" },
              staticLength: 8
            },
            verificationKey: {
              type: "option",
              optionType: "orUndefined",
              inner: {
                type: "object",
                name: "VerificationKeyWithHash",
                docs: null,
                keys: ["data", "hash"],
                entries: { data: { type: "string" }, hash: { type: "Field" } },
                docEntries: { data: null, hash: null }
              }
            },
            zkappVersion: { type: "UInt32" },
            actionState: {
              type: "array",
              inner: { type: "Field" },
              staticLength: 5
            },
            lastActionSlot: { type: "UInt32" },
            provedState: { type: "Bool" },
            zkappUri: { type: "string" }
          },
          docEntries: {
            appState: null,
            verificationKey: null,
            zkappVersion: null,
            actionState: null,
            lastActionSlot: null,
            provedState: null,
            zkappUri: null
          }
        }
      }
    },
    docEntries: {
      publicKey: null,
      tokenId: null,
      tokenSymbol: null,
      balance: null,
      nonce: null,
      receiptChainHash: null,
      delegate: null,
      votingFor: null,
      timing: null,
      permissions: null,
      zkapp: null
    }
  }
};

// dist/node/bindings/mina-transaction/gen/transaction.js
var TypeMap = {
  PublicKey: PublicKey2,
  UInt64: UInt642,
  UInt32: UInt322,
  TokenId,
  Field: Field4,
  Bool: Bool4,
  AuthRequired,
  Sign: Sign3
};
var customTypes = {
  ZkappUri,
  TokenSymbol: TokenSymbol2,
  StateHash,
  Events,
  Actions,
  ActionState,
  VerificationKeyHash,
  ReceiptChainHash
};
var { provableFromLayout, toJSONEssential, empty: empty2 } = ProvableFromLayout(TypeMap, customTypes);
var ZkappCommand = provableFromLayout(jsLayout.ZkappCommand);
var AccountUpdate = provableFromLayout(jsLayout.AccountUpdate);
var Account = provableFromLayout(jsLayout.Account);

// dist/node/bindings/mina-transaction/gen/transaction-bigint.js
var transaction_bigint_exports = {};
__export(transaction_bigint_exports, {
  Account: () => Account2,
  AccountUpdate: () => AccountUpdate2,
  ActionState: () => ActionState2,
  Actions: () => Actions2,
  AuthRequired: () => AuthRequired2,
  Bool: () => Bool,
  Events: () => Events2,
  Field: () => Field,
  Json: () => transaction_json_exports,
  PublicKey: () => PublicKey,
  ReceiptChainHash: () => ReceiptChainHash2,
  Sign: () => Sign,
  StateHash: () => StateHash2,
  TokenId: () => TokenId2,
  TokenSymbol: () => TokenSymbol3,
  TypeMap: () => TypeMap2,
  UInt32: () => UInt32,
  UInt64: () => UInt64,
  VerificationKeyHash: () => VerificationKeyHash2,
  ZkappCommand: () => ZkappCommand2,
  ZkappUri: () => ZkappUri2,
  customTypes: () => customTypes2,
  empty: () => empty3,
  signableFromLayout: () => signableFromLayout,
  toJSONEssential: () => toJSONEssential2
});

// dist/node/bindings/mina-transaction/transaction-leaves-bigint.js
var { TokenId: TokenId2, StateHash: StateHash2, TokenSymbol: TokenSymbol3, AuthRequired: AuthRequired2, ZkappUri: ZkappUri2 } = derivedLeafTypesSignable({ Field, Bool, HashHelpers: HashHelpers2, packToFields: packToFields2 });
var { Events: Events2, Actions: Actions2 } = createEvents({ Field, Poseidon });
var ActionState2 = {
  ...Field,
  empty: Actions2.emptyActionState
};
var VerificationKeyHash2 = {
  ...Field,
  empty: () => Field(mocks.dummyVerificationKeyHash)
};
var ReceiptChainHash2 = {
  ...Field,
  empty: () => HashHelpers2.emptyHashWithPrefix("CodaReceiptEmpty")
};

// dist/node/bindings/mina-transaction/gen/transaction-bigint.js
var TypeMap2 = {
  PublicKey,
  UInt64,
  UInt32,
  TokenId: TokenId2,
  Field,
  Bool,
  AuthRequired: AuthRequired2,
  Sign
};
var customTypes2 = {
  ZkappUri: ZkappUri2,
  TokenSymbol: TokenSymbol3,
  StateHash: StateHash2,
  Events: Events2,
  Actions: Actions2,
  ActionState: ActionState2,
  VerificationKeyHash: VerificationKeyHash2,
  ReceiptChainHash: ReceiptChainHash2
};
var { signableFromLayout, toJSONEssential: toJSONEssential2, empty: empty3 } = SignableFromLayout(TypeMap2, customTypes2);
var ZkappCommand2 = signableFromLayout(jsLayout.ZkappCommand);
var AccountUpdate2 = signableFromLayout(jsLayout.AccountUpdate);
var Account2 = signableFromLayout(jsLayout.Account);

// dist/node/lib/mina.js
var mina_exports = {};
__export(mina_exports, {
  BerkeleyQANet: () => BerkeleyQANet,
  LocalBlockchain: () => LocalBlockchain,
  Network: () => Network2,
  Transaction: () => Transaction,
  accountCreationFee: () => accountCreationFee,
  activeInstance: () => activeInstance,
  createTransaction: () => createTransaction,
  currentSlot: () => currentSlot,
  currentTransaction: () => currentTransaction,
  faucet: () => faucet,
  fetchActions: () => fetchActions2,
  fetchEvents: () => fetchEvents2,
  filterGroups: () => filterGroups,
  getAccount: () => getAccount,
  getActions: () => getActions,
  getBalance: () => getBalance,
  getNetworkConstants: () => getNetworkConstants,
  getNetworkId: () => getNetworkId,
  getNetworkState: () => getNetworkState,
  getProofsEnabled: () => getProofsEnabled,
  hasAccount: () => hasAccount,
  sendTransaction: () => sendTransaction,
  sender: () => sender,
  setActiveInstance: () => setActiveInstance,
  transaction: () => transaction,
  waitForFunding: () => waitForFunding
});

// dist/node/lib/zkapp.js
var import_tslib5 = require("tslib");

// dist/node/bindings/lib/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  Bijective: () => Bijective,
  bytesFromFields: () => bytesFromFields,
  bytesToFields: () => bytesToFields,
  stringFromFields: () => stringFromFields,
  stringToFields: () => stringToFields
});
function stringToFields(message) {
  let bytes = new TextEncoder().encode(message);
  return bytesToFields(bytes);
}
function stringFromFields(fields) {
  let bytes = bytesFromFields(fields);
  return new TextDecoder().decode(bytes);
}
var STOP = 1;
function bytesToFields(bytes) {
  let fields = [];
  let currentBigInt = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    currentBigInt += BigInt(byte) << bitPosition;
    bitPosition += 8n;
    if (bitPosition === 248n) {
      fields.push(Field4(currentBigInt.toString()));
      currentBigInt = 0n;
      bitPosition = 0n;
    }
  }
  currentBigInt += BigInt(STOP) << bitPosition;
  fields.push(Field4(currentBigInt.toString()));
  return fields;
}
function bytesFromFields(fields) {
  let lastChunk = fields.pop();
  if (lastChunk === void 0)
    return new Uint8Array();
  let lastChunkBytes = bytesOfConstantField(lastChunk);
  let i2 = lastChunkBytes.lastIndexOf(STOP, 30);
  if (i2 === -1)
    throw Error("Error (bytesFromFields): Invalid encoding.");
  let bytes = new Uint8Array(fields.length * 31 + i2);
  bytes.set(lastChunkBytes.subarray(0, i2), fields.length * 31);
  i2 = 0;
  for (let field of fields) {
    bytes.set(bytesOfConstantField(field).subarray(0, 31), i2);
    i2 += 31;
  }
  fields.push(lastChunk);
  return bytes;
}
var p2 = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
var q2 = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;
var bytesPerBigInt = 32;
var bytesBase = 256n ** BigInt(bytesPerBigInt);
var Bijective = {
  Fp: {
    toBytes: (fields) => toBytesBijective(fields, p2),
    fromBytes: (bytes) => toFieldsBijective(bytes, p2),
    toString(fields) {
      return new TextDecoder().decode(toBytesBijective(fields, p2));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, p2);
    }
  },
  Fq: {
    toBytes: (fields) => toBytesBijective(fields, q2),
    fromBytes: (bytes) => toFieldsBijective(bytes, q2),
    toString(fields) {
      return new TextDecoder().decode(toBytesBijective(fields, q2));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, q2);
    }
  }
};
function toBytesBijective(fields, p3) {
  let fieldsBigInts = fields.map((x) => x.toBigInt());
  let bytesBig = changeBase(fieldsBigInts, p3, bytesBase);
  let bytes = bigIntArrayToBytes(bytesBig, bytesPerBigInt);
  return bytes;
}
function toFieldsBijective(bytes, p3) {
  let bytesBig = bytesToBigIntArray(bytes, bytesPerBigInt);
  let fieldsBigInts = changeBase(bytesBig, bytesBase, p3);
  let fields = fieldsBigInts.map(Field4);
  return fields;
}
function bytesOfConstantField(field) {
  return Uint8Array.from(Field4.toBytes(field));
}
function bigIntToBytes2(x, length) {
  let bytes = [];
  for (; x > 0; x >>= 8n) {
    bytes.push(Number(x & 0xffn));
  }
  let array = new Uint8Array(bytes);
  if (length === void 0)
    return array;
  if (array.length > length)
    throw Error(`bigint doesn't fit into ${length} bytes.`);
  let sizedArray = new Uint8Array(length);
  sizedArray.set(array);
  return sizedArray;
}
function bytesToBigIntArray(bytes, bytesPerBigInt2) {
  let bigints = [];
  for (let i2 = 0; i2 < bytes.byteLength; i2 += bytesPerBigInt2) {
    bigints.push(bytesToBigInt(bytes.subarray(i2, i2 + bytesPerBigInt2)));
  }
  return bigints;
}
function bigIntArrayToBytes(bigints, bytesPerBigInt2) {
  let bytes = new Uint8Array(bigints.length * bytesPerBigInt2);
  let offset = 0;
  for (let b2 of bigints) {
    bytes.set(bigIntToBytes2(b2, bytesPerBigInt2), offset);
    offset += bytesPerBigInt2;
  }
  let i2 = bytes.byteLength - 1;
  for (; i2 >= 0; i2--) {
    if (bytes[i2] !== 0)
      break;
  }
  return bytes.slice(0, i2 + 1);
}

// dist/node/lib/precondition.js
function preconditions(accountUpdate, isSelf) {
  initializePreconditions(accountUpdate, isSelf);
  return {
    account: Account3(accountUpdate),
    network: Network(accountUpdate),
    currentSlot: CurrentSlot(accountUpdate)
  };
}
function Network(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.network;
  let context = getPreconditionContextExn(accountUpdate);
  let network = preconditionClass(layout, "network", accountUpdate, context);
  let timestamp = {
    get() {
      let slot = network.globalSlotSinceGenesis.get();
      return globalSlotToTimestamp(slot);
    },
    getAndRequireEquals() {
      let slot = network.globalSlotSinceGenesis.getAndRequireEquals();
      return globalSlotToTimestamp(slot);
    },
    getAndAssertEquals() {
      return this.getAndRequireEquals();
    },
    requireEquals(value) {
      let { genesisTimestamp, slotTime } = getNetworkConstants();
      let slot = timestampToGlobalSlot(value, `Timestamp precondition unsatisfied: the timestamp can only equal numbers of the form ${genesisTimestamp} + k*${slotTime},
i.e., the genesis timestamp plus an integer number of slots.`);
      return network.globalSlotSinceGenesis.requireEquals(slot);
    },
    assertEquals(value) {
      return this.requireEquals(value);
    },
    requireBetween(lower, upper) {
      let [slotLower, slotUpper] = timestampToGlobalSlotRange(lower, upper);
      return network.globalSlotSinceGenesis.requireBetween(slotLower, slotUpper);
    },
    assertBetween(lower, upper) {
      return this.requireBetween(lower, upper);
    },
    requireNothing() {
      return network.globalSlotSinceGenesis.requireNothing();
    },
    assertNothing() {
      return this.requireNothing();
    }
  };
  return { ...network, timestamp };
}
function Account3(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.account;
  let context = getPreconditionContextExn(accountUpdate);
  let identity = (x) => x;
  let update = {
    delegate: {
      ...preconditionSubclass(accountUpdate, "account.delegate", PublicKey2, context),
      ...updateSubclass(accountUpdate, "delegate", identity)
    },
    verificationKey: updateSubclass(accountUpdate, "verificationKey", identity),
    permissions: updateSubclass(accountUpdate, "permissions", identity),
    zkappUri: updateSubclass(accountUpdate, "zkappUri", ZkappUri.fromJSON),
    tokenSymbol: updateSubclass(accountUpdate, "tokenSymbol", TokenSymbol.from),
    timing: updateSubclass(accountUpdate, "timing", identity),
    votingFor: updateSubclass(accountUpdate, "votingFor", identity)
  };
  return {
    ...preconditionClass(layout, "account", accountUpdate, context),
    ...update
  };
}
function updateSubclass(accountUpdate, key, transform) {
  return {
    set(value) {
      accountUpdate.body.update[key].isSome = Bool4(true);
      accountUpdate.body.update[key].value = transform(value);
    }
  };
}
function CurrentSlot(accountUpdate) {
  let context = getPreconditionContextExn(accountUpdate);
  return {
    requireBetween(lower, upper) {
      context.constrained.add("validWhile");
      let property = accountUpdate.body.preconditions.validWhile;
      property.isSome = Bool4(true);
      property.value.lower = lower;
      property.value.upper = upper;
    },
    assertBetween(lower, upper) {
      this.requireBetween(lower, upper);
    }
  };
}
var unimplementedPreconditions = [
  // unimplemented because its not checked in the protocol
  "network.stakingEpochData.seed",
  "network.nextEpochData.seed"
];
var baseMap = { UInt64: UInt642, UInt32: UInt322, Field: Field4, Bool: Bool4, PublicKey: PublicKey2 };
function preconditionClass(layout, baseKey, accountUpdate, context) {
  if (layout.type === "option") {
    if (layout.optionType === "closedInterval") {
      let lower = layout.inner.entries.lower.type;
      let baseType = baseMap[lower];
      return preconditionSubClassWithRange(accountUpdate, baseKey, baseType, context);
    } else if (layout.optionType === "flaggedOption") {
      let baseType = baseMap[layout.inner.type];
      return preconditionSubclass(accountUpdate, baseKey, baseType, context);
    }
  } else if (layout.type === "array") {
    return {};
  } else if (layout.type === "object") {
    return Object.fromEntries(layout.keys.map((key) => {
      let value = layout.entries[key];
      return [
        key,
        preconditionClass(value, `${baseKey}.${key}`, accountUpdate, context)
      ];
    }));
  } else
    throw Error("bug");
}
function preconditionSubClassWithRange(accountUpdate, longKey, fieldType, context) {
  return {
    ...preconditionSubclass(accountUpdate, longKey, fieldType, context),
    requireBetween(lower, upper) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      property.isSome = Bool4(true);
      property.value.lower = lower;
      property.value.upper = upper;
    },
    assertBetween(lower, upper) {
      this.requireBetween(lower, upper);
    }
  };
}
function preconditionSubclass(accountUpdate, longKey, fieldType, context) {
  if (fieldType === void 0) {
    throw Error(`this.${longKey}: fieldType undefined`);
  }
  let obj = {
    get() {
      if (unimplementedPreconditions.includes(longKey)) {
        let self = context.isSelf ? "this" : "accountUpdate";
        throw Error(`${self}.${longKey}.get() is not implemented yet.`);
      }
      let { read, vars } = context;
      read.add(longKey);
      return vars[longKey] ??= getVariable(accountUpdate, longKey, fieldType);
    },
    getAndRequireEquals() {
      let value = obj.get();
      obj.requireEquals(value);
      return value;
    },
    getAndAssertEquals() {
      return this.getAndRequireEquals();
    },
    requireEquals(value) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      if ("isSome" in property) {
        property.isSome = Bool4(true);
        if ("lower" in property.value && "upper" in property.value) {
          property.value.lower = value;
          property.value.upper = value;
        } else {
          property.value = value;
        }
      } else {
        setPath(accountUpdate.body.preconditions, longKey, value);
      }
    },
    assertEquals(value) {
      this.requireEquals(value);
    },
    requireNothing() {
      context.constrained.add(longKey);
    },
    assertNothing() {
      this.requireNothing();
    }
  };
  return obj;
}
function getVariable(accountUpdate, longKey, fieldType) {
  return Provable.witness(fieldType, () => {
    let [accountOrNetwork, ...rest] = longKey.split(".");
    let key = rest.join(".");
    let value;
    if (accountOrNetwork === "account") {
      let account = getAccountPreconditions(accountUpdate.body);
      value = account[key];
    } else if (accountOrNetwork === "network") {
      let networkState = getNetworkState();
      value = getPath(networkState, key);
    } else if (accountOrNetwork === "validWhile") {
      let networkState = getNetworkState();
      value = networkState.globalSlotSinceGenesis;
    } else {
      throw Error("impossible");
    }
    return value;
  });
}
function globalSlotToTimestamp(slot) {
  let { genesisTimestamp, slotTime } = getNetworkConstants();
  return UInt642.from(slot).mul(slotTime).add(genesisTimestamp);
}
function timestampToGlobalSlot(timestamp, message) {
  let { genesisTimestamp, slotTime } = getNetworkConstants();
  let { quotient: slot, rest } = timestamp.sub(genesisTimestamp).divMod(slotTime);
  rest.value.assertEquals(Field4(0), message);
  return slot.toUInt32();
}
function timestampToGlobalSlotRange(tsLower, tsUpper) {
  let { genesisTimestamp, slotTime } = getNetworkConstants();
  let tsLowerInt = Int64.from(tsLower).sub(genesisTimestamp).add(slotTime).sub(1);
  let lowerCapped = Provable.if(tsLowerInt.isPositive(), UInt642, tsLowerInt.magnitude, UInt642.from(0));
  let slotLower = lowerCapped.div(slotTime).toUInt32Clamped();
  let slotUpper = tsUpper.sub(genesisTimestamp).div(slotTime).toUInt32Clamped();
  return [slotLower, slotUpper];
}
function getAccountPreconditions(body) {
  let { publicKey, tokenId } = body;
  let hasAccount2 = hasAccount(publicKey, tokenId);
  if (!hasAccount2) {
    return {
      balance: UInt642.zero,
      nonce: UInt322.zero,
      receiptChainHash: emptyReceiptChainHash(),
      actionState: Actions.emptyActionState(),
      delegate: publicKey,
      provedState: Bool4(false),
      isNew: Bool4(true)
    };
  }
  let account = getAccount(publicKey, tokenId);
  return {
    balance: account.balance,
    nonce: account.nonce,
    receiptChainHash: account.receiptChainHash,
    actionState: account.zkapp?.actionState?.[0] ?? Actions.emptyActionState(),
    delegate: account.delegate ?? account.publicKey,
    provedState: account.zkapp?.provedState ?? Bool4(false),
    isNew: Bool4(false)
  };
}
function initializePreconditions(accountUpdate, isSelf) {
  preconditionContexts.set(accountUpdate, {
    read: /* @__PURE__ */ new Set(),
    constrained: /* @__PURE__ */ new Set(),
    vars: {},
    isSelf
  });
}
function cleanPreconditionsCache(accountUpdate) {
  let context = preconditionContexts.get(accountUpdate);
  if (context !== void 0)
    context.vars = {};
}
function assertPreconditionInvariants(accountUpdate) {
  let context = getPreconditionContextExn(accountUpdate);
  let self = context.isSelf ? "this" : "accountUpdate";
  let dummyPreconditions = Preconditions.ignoreAll();
  for (let preconditionPath of context.read) {
    if (context.constrained.has(preconditionPath))
      continue;
    let precondition = getPath(accountUpdate.body.preconditions, preconditionPath);
    let dummy = getPath(dummyPreconditions, preconditionPath);
    if (!circuitValueEquals(precondition, dummy))
      continue;
    let hasAssertBetween = isRangeCondition(precondition);
    let shortPath = preconditionPath.split(".").pop();
    let errorMessage = `You used \`${self}.${preconditionPath}.get()\` without adding a precondition that links it to the actual ${shortPath}.
Consider adding this line to your code:
${self}.${preconditionPath}.assertEquals(${self}.${preconditionPath}.get());${hasAssertBetween ? `
You can also add more flexible preconditions with \`${self}.${preconditionPath}.assertBetween(...)\`.` : ""}`;
    throw Error(errorMessage);
  }
}
function getPreconditionContextExn(accountUpdate) {
  let c = preconditionContexts.get(accountUpdate);
  if (c === void 0)
    throw Error("bug: precondition context not found");
  return c;
}
var preconditionContexts = /* @__PURE__ */ new WeakMap();
function isRangeCondition(condition) {
  return "isSome" in condition && "lower" in condition.value;
}
function getPath(obj, path) {
  let pathArray = path.split(".").reverse();
  while (pathArray.length > 0) {
    let key = pathArray.pop();
    obj = obj[key];
  }
  return obj;
}
function setPath(obj, path, value) {
  let pathArray = path.split(".");
  let key = pathArray.pop();
  getPath(obj, pathArray.join("."))[key] = value;
}

// dist/node/lib/fetch.js
var import_isomorphic_fetch = require("isomorphic-fetch");

// dist/node/lib/base58-encodings.js
var { TokenId: TokenId3, ReceiptChainHash: ReceiptChainHash3, EpochSeed, LedgerHash, StateHash: StateHash3 } = fieldEncodings(Field4);

// dist/node/lib/mina/account.js
var Account4 = transaction_exports.Account;
var accountQuery = (publicKey, tokenId) => `{
  account(publicKey: "${publicKey}", token: "${tokenId}") {
    publicKey
    token
    nonce
    balance { total }
    tokenSymbol
    receiptChainHash
    timing {
      initialMinimumBalance
      cliffTime
      cliffAmount
      vestingPeriod
      vestingIncrement
    }
    permissions {
      editState
      access
      send
      receive
      setDelegate
      setPermissions
      setVerificationKey
      setZkappUri
      editActionState
      setTokenSymbol
      incrementNonce
      setVotingFor
      setTiming
    }
    delegateAccount { publicKey }
    votingFor
    zkappState
    verificationKey {
      verificationKey
      hash
    }
    actionState
    provedState
    zkappUri
  }
}
`;
function parseFetchedAccount({ publicKey, nonce, zkappState, balance, permissions, timing: { cliffAmount, cliffTime, initialMinimumBalance, vestingIncrement, vestingPeriod }, delegateAccount, receiptChainHash, actionState, token, tokenSymbol, verificationKey, provedState, zkappUri }) {
  let hasZkapp = zkappState !== null || verificationKey !== null || actionState !== null || zkappUri !== null || provedState;
  let partialAccount = {
    publicKey: PublicKey2.fromBase58(publicKey),
    tokenId: TokenId3.fromBase58(token),
    tokenSymbol: tokenSymbol ?? void 0,
    balance: balance && UInt642.from(balance.total),
    nonce: UInt322.from(nonce),
    receiptChainHash: receiptChainHash && ReceiptChainHash3.fromBase58(receiptChainHash) || void 0,
    delegate: (delegateAccount && PublicKey2.fromBase58(delegateAccount.publicKey)) ?? void 0,
    votingFor: void 0,
    timing: cliffAmount && cliffTime && initialMinimumBalance && vestingIncrement && vestingPeriod && {
      isTimed: Bool4(true),
      cliffAmount: UInt642.from(cliffAmount),
      cliffTime: UInt322.from(cliffTime),
      initialMinimumBalance: UInt642.from(initialMinimumBalance),
      vestingIncrement: UInt642.from(vestingIncrement),
      vestingPeriod: UInt322.from(vestingPeriod)
    } || void 0,
    permissions: (permissions && Permissions.fromJSON(permissions)) ?? Permissions.initial(),
    zkapp: hasZkapp ? {
      appState: (zkappState && zkappState.map(Field4)) ?? void 0,
      verificationKey: (verificationKey && {
        data: verificationKey.verificationKey,
        hash: Field4(verificationKey.hash)
      }) ?? void 0,
      zkappVersion: void 0,
      actionState: (actionState && actionState.map(Field4)) ?? void 0,
      lastActionSlot: void 0,
      provedState: provedState !== null ? Bool4(provedState) : void 0,
      zkappUri: zkappUri !== null ? zkappUri : void 0
    } : void 0
  };
  return fillPartialAccount(partialAccount);
}
function fillPartialAccount(account) {
  return genericLayoutFold(TypeMap, customTypes, {
    map(type, value) {
      if (value !== void 0)
        return value;
      return type.empty();
    },
    reduceArray(array) {
      return array;
    },
    reduceObject(_, record2) {
      return record2;
    },
    reduceFlaggedOption() {
      throw Error("not relevant");
    },
    reduceOrUndefined(value) {
      return value;
    }
  }, jsLayout.Account, account);
}

// dist/node/lib/fetch.js
var networkConfig = {
  minaEndpoint: "",
  minaFallbackEndpoints: [],
  archiveEndpoint: "",
  archiveFallbackEndpoints: [],
  lightnetAccountManagerEndpoint: ""
};
function checkForValidUrl(url2) {
  try {
    new URL(url2);
    return true;
  } catch (e) {
    return false;
  }
}
function setGraphqlEndpoints([graphqlEndpoint, ...fallbackEndpoints]) {
  setGraphqlEndpoint(graphqlEndpoint);
  setMinaGraphqlFallbackEndpoints(fallbackEndpoints);
}
function setGraphqlEndpoint(graphqlEndpoint) {
  if (!checkForValidUrl(graphqlEndpoint)) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoint}. Please specify a valid URL.`);
  }
  networkConfig.minaEndpoint = graphqlEndpoint;
}
function setMinaGraphqlFallbackEndpoints(graphqlEndpoints) {
  if (graphqlEndpoints.some((endpoint) => !checkForValidUrl(endpoint))) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoints}. Please specify a valid URL.`);
  }
  networkConfig.minaFallbackEndpoints = graphqlEndpoints;
}
function setArchiveGraphqlEndpoint(graphqlEndpoint) {
  if (!checkForValidUrl(graphqlEndpoint)) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoint}. Please specify a valid URL.`);
  }
  networkConfig.archiveEndpoint = graphqlEndpoint;
}
function setArchiveGraphqlFallbackEndpoints(graphqlEndpoints) {
  if (graphqlEndpoints.some((endpoint) => !checkForValidUrl(endpoint))) {
    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoints}. Please specify a valid URL.`);
  }
  networkConfig.archiveFallbackEndpoints = graphqlEndpoints;
}
function setLightnetAccountManagerEndpoint(endpoint) {
  if (!checkForValidUrl(endpoint)) {
    throw new Error(`Invalid account manager endpoint: ${endpoint}. Please specify a valid URL.`);
  }
  networkConfig.lightnetAccountManagerEndpoint = endpoint;
}
async function fetchAccount(accountInfo, graphqlEndpoint = networkConfig.minaEndpoint, { timeout = defaultTimeout } = {}) {
  let publicKeyBase58 = accountInfo.publicKey instanceof PublicKey2 ? accountInfo.publicKey.toBase58() : accountInfo.publicKey;
  let tokenIdBase58 = typeof accountInfo.tokenId === "string" || !accountInfo.tokenId ? accountInfo.tokenId : TokenId4.toBase58(accountInfo.tokenId);
  return await fetchAccountInternal({ publicKey: publicKeyBase58, tokenId: tokenIdBase58 }, graphqlEndpoint, {
    timeout
  });
}
async function fetchAccountInternal(accountInfo, graphqlEndpoint = networkConfig.minaEndpoint, config) {
  const { publicKey, tokenId } = accountInfo;
  let [response, error] = await makeGraphqlRequest(accountQuery(publicKey, tokenId ?? TokenId4.toBase58(TokenId4.default)), graphqlEndpoint, networkConfig.minaFallbackEndpoints, config);
  if (error !== void 0)
    return { account: void 0, error };
  let fetchedAccount = response.data.account;
  if (fetchedAccount === null) {
    return {
      account: void 0,
      error: {
        statusCode: 404,
        statusText: `fetchAccount: Account with public key ${publicKey} does not exist.`
      }
    };
  }
  let account = parseFetchedAccount(fetchedAccount);
  addCachedAccountInternal(account, graphqlEndpoint);
  return {
    account,
    error: void 0
  };
}
var defaultTimeout = 5 * 60 * 1e3;
var accountCache = {};
var networkCache = {};
var actionsCache = {};
var accountsToFetch = {};
var networksToFetch = {};
var actionsToFetch = {};
var genesisConstantsCache = {};
function markAccountToBeFetched(publicKey, tokenId, graphqlEndpoint) {
  let publicKeyBase58 = publicKey.toBase58();
  let tokenBase58 = TokenId4.toBase58(tokenId);
  accountsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {
    publicKey: publicKeyBase58,
    tokenId: tokenBase58,
    graphqlEndpoint
  };
}
function markNetworkToBeFetched(graphqlEndpoint) {
  networksToFetch[graphqlEndpoint] = { graphqlEndpoint };
}
function markActionsToBeFetched(publicKey, tokenId, graphqlEndpoint, actionStates = {}) {
  let publicKeyBase58 = publicKey.toBase58();
  let tokenBase58 = TokenId4.toBase58(tokenId);
  let { fromActionState, endActionState } = actionStates;
  let fromActionStateBase58 = fromActionState ? fromActionState.toString() : void 0;
  let endActionStateBase58 = endActionState ? endActionState.toString() : void 0;
  actionsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {
    publicKey: publicKeyBase58,
    tokenId: tokenBase58,
    actionStates: {
      fromActionState: fromActionStateBase58,
      endActionState: endActionStateBase58
    },
    graphqlEndpoint
  };
}
async function fetchMissingData(graphqlEndpoint, archiveEndpoint) {
  let promises = Object.entries(accountsToFetch).map(async ([key, { publicKey, tokenId }]) => {
    let response = await fetchAccountInternal({ publicKey, tokenId }, graphqlEndpoint);
    if (response.error === void 0)
      delete accountsToFetch[key];
  });
  let actionPromises = Object.entries(actionsToFetch).map(async ([key, { publicKey, actionStates, tokenId }]) => {
    let response = await fetchActions({ publicKey, actionStates, tokenId }, archiveEndpoint);
    if (!("error" in response) || response.error === void 0)
      delete actionsToFetch[key];
  });
  promises.push(...actionPromises);
  let network = Object.entries(networksToFetch).find(([, network2]) => {
    return network2.graphqlEndpoint === graphqlEndpoint;
  });
  if (network !== void 0) {
    promises.push((async () => {
      try {
        await fetchLastBlock(graphqlEndpoint);
        await fetchGenesisConstants(graphqlEndpoint);
        delete networksToFetch[network[0]];
      } catch {
      }
    })());
  }
  await Promise.all(promises);
}
function getCachedAccount(publicKey, tokenId, graphqlEndpoint = networkConfig.minaEndpoint) {
  return accountCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.account;
}
function getCachedNetwork(graphqlEndpoint = networkConfig.minaEndpoint) {
  return networkCache[graphqlEndpoint]?.network;
}
function getCachedActions(publicKey, tokenId, graphqlEndpoint = networkConfig.archiveEndpoint) {
  return actionsCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.actions;
}
function getCachedGenesisConstants(graphqlEndpoint = networkConfig.minaEndpoint) {
  return genesisConstantsCache[graphqlEndpoint];
}
function addCachedAccount(partialAccount, graphqlEndpoint = networkConfig.minaEndpoint) {
  let account = fillPartialAccount(partialAccount);
  addCachedAccountInternal(account, graphqlEndpoint);
}
function addCachedAccountInternal(account, graphqlEndpoint) {
  accountCache[accountCacheKey(account.publicKey, account.tokenId, graphqlEndpoint)] = {
    account,
    graphqlEndpoint,
    timestamp: Date.now()
  };
}
function addCachedActions({ publicKey, tokenId }, actions, graphqlEndpoint) {
  actionsCache[`${publicKey};${tokenId};${graphqlEndpoint}`] = {
    actions,
    graphqlEndpoint,
    timestamp: Date.now()
  };
}
function accountCacheKey(publicKey, tokenId, graphqlEndpoint) {
  return `${publicKey.toBase58()};${TokenId4.toBase58(tokenId)};${graphqlEndpoint}`;
}
async function fetchLastBlock(graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(lastBlockQuery, graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let lastBlock = resp?.data?.bestChain?.[0];
  if (lastBlock === void 0) {
    throw Error("Failed to fetch latest network state.");
  }
  let network = parseFetchedBlock(lastBlock);
  networkCache[graphqlEndpoint] = {
    network,
    graphqlEndpoint,
    timestamp: Date.now()
  };
  return network;
}
var lastBlockQuery = `{
  bestChain(maxLength: 1) {
    protocolState {
      blockchainState {
        snarkedLedgerHash
        stagedLedgerHash
        date
        utcDate
        stagedLedgerProofEmitted
      }
      previousStateHash
      consensusState {
        blockHeight
        slotSinceGenesis
        slot
        nextEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        stakingEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        epochCount
        minWindowDensity
        totalCurrency
        epoch
      }
    }
  }
}`;
var lastBlockQueryFailureCheck = (length) => `{
  bestChain(maxLength: ${length}) {
    transactions {
      zkappCommands {
        hash
        failureReason {
          failures
          index
        }
      }
    }
  }
}`;
async function fetchLatestBlockZkappStatus(blockLength, graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(lastBlockQueryFailureCheck(blockLength), graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(`Error making GraphQL request: ${error.statusText}`);
  let bestChain = resp?.data;
  if (bestChain === void 0) {
    throw Error("Failed to fetch the latest zkApp transaction status. The response data is undefined.");
  }
  return bestChain;
}
async function checkZkappTransaction(txnId, blockLength = 20) {
  let bestChainBlocks = await fetchLatestBlockZkappStatus(blockLength);
  for (let block of bestChainBlocks.bestChain) {
    for (let zkappCommand of block.transactions.zkappCommands) {
      if (zkappCommand.hash === txnId) {
        if (zkappCommand.failureReason !== null) {
          let failureReason = zkappCommand.failureReason.reverse().map((failure) => {
            return ` AccountUpdate #${failure.index} failed. Reason: "${failure.failures.join(", ")}"`;
          });
          return {
            success: false,
            failureReason
          };
        } else {
          return {
            success: true,
            failureReason: null
          };
        }
      }
    }
  }
  return {
    success: false,
    failureReason: null
  };
}
function parseFetchedBlock({ protocolState: { blockchainState: { snarkedLedgerHash, utcDate }, consensusState: { blockHeight, minWindowDensity, totalCurrency, slot, slotSinceGenesis, nextEpochData, stakingEpochData } } }) {
  return {
    snarkedLedgerHash: LedgerHash.fromBase58(snarkedLedgerHash),
    // TODO: use date or utcDate?
    blockchainLength: UInt322.from(blockHeight),
    minWindowDensity: UInt322.from(minWindowDensity),
    totalCurrency: UInt642.from(totalCurrency),
    globalSlotSinceGenesis: UInt322.from(slotSinceGenesis),
    nextEpochData: parseEpochData(nextEpochData),
    stakingEpochData: parseEpochData(stakingEpochData)
  };
}
function parseEpochData({ ledger: { hash: hash3, totalCurrency }, seed, startCheckpoint, lockCheckpoint, epochLength }) {
  return {
    ledger: {
      hash: LedgerHash.fromBase58(hash3),
      totalCurrency: UInt642.from(totalCurrency)
    },
    seed: EpochSeed.fromBase58(seed),
    startCheckpoint: StateHash3.fromBase58(startCheckpoint),
    lockCheckpoint: StateHash3.fromBase58(lockCheckpoint),
    epochLength: UInt322.from(epochLength)
  };
}
var transactionStatusQuery = (txId) => `query {
  transactionStatus(zkappTransaction:"${txId}")
}`;
async function fetchTransactionStatus(txId, graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(transactionStatusQuery(txId), graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let txStatus = resp?.data?.transactionStatus;
  if (txStatus === void 0 || txStatus === null) {
    throw Error(`Failed to fetch transaction status. TransactionId: ${txId}`);
  }
  return txStatus;
}
function sendZkapp(json, graphqlEndpoint = networkConfig.minaEndpoint, { timeout = defaultTimeout } = {}) {
  return makeGraphqlRequest(sendZkappQuery(json), graphqlEndpoint, networkConfig.minaFallbackEndpoints, {
    timeout
  });
}
function sendZkappQuery(json) {
  return `mutation {
  sendZkapp(input: {
    zkappCommand: ${removeJsonQuotes(json)}
  }) {
    zkapp {
      hash
      id
      failureReason {
        failures
        index
      }
      zkappCommand {
        memo
        feePayer {
          body {
            publicKey
          }
        }
        accountUpdates {
          body {
            publicKey
            useFullCommitment
            incrementNonce
          }
        }
      }
    }
  }
}
`;
}
var getEventsQuery = (publicKey, tokenId, filterOptions) => {
  const { to, from } = filterOptions ?? {};
  let input = `address: "${publicKey}", tokenId: "${tokenId}"`;
  if (to !== void 0) {
    input += `, to: ${to}`;
  }
  if (from !== void 0) {
    input += `, from: ${from}`;
  }
  return `{
  events(input: { ${input} }) {
    blockInfo {
      distanceFromMaxBlockHeight
      height
      globalSlotSinceGenesis
      stateHash
      parentHash
      chainStatus
    }
    eventData {
      transactionInfo {
        hash
        memo
        status
      }
      data
    }
  }
}`;
};
var getActionsQuery = (publicKey, actionStates, tokenId, _filterOptions) => {
  const { fromActionState, endActionState } = actionStates ?? {};
  let input = `address: "${publicKey}", tokenId: "${tokenId}"`;
  if (fromActionState !== void 0) {
    input += `, fromActionState: "${fromActionState}"`;
  }
  if (endActionState !== void 0) {
    input += `, endActionState: "${endActionState}"`;
  }
  return `{
  actions(input: { ${input} }) {
    blockInfo {
      distanceFromMaxBlockHeight
    }
    actionState {
      actionStateOne
      actionStateTwo
    }
    actionData {
      accountUpdateId
      data
    }
  }
}`;
};
var genesisConstantsQuery = `{
    genesisConstants {
      genesisTimestamp
      coinbase
      accountCreationFee
    }
    daemonStatus {
      consensusConfiguration {
        epochDuration
        k
        slotDuration
        slotsPerEpoch
      }
    }
  }`;
async function fetchEvents(accountInfo, graphqlEndpoint = networkConfig.archiveEndpoint, filterOptions = {}) {
  if (!graphqlEndpoint)
    throw new Error("fetchEvents: Specified GraphQL endpoint is undefined. Please specify a valid endpoint.");
  const { publicKey, tokenId } = accountInfo;
  let [response, error] = await makeGraphqlRequest(getEventsQuery(publicKey, tokenId ?? TokenId4.toBase58(TokenId4.default), filterOptions), graphqlEndpoint, networkConfig.archiveFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let fetchedEvents = response?.data.events;
  if (fetchedEvents === void 0) {
    throw Error(`Failed to fetch events data. Account: ${publicKey} Token: ${tokenId}`);
  }
  let numberOfBestTipBlocks = 0;
  for (let i2 = 0; i2 < fetchedEvents.length; i2++) {
    if (fetchedEvents[i2].blockInfo.distanceFromMaxBlockHeight === 0) {
      numberOfBestTipBlocks++;
    }
    if (numberOfBestTipBlocks > 1) {
      fetchedEvents = fetchedEvents.filter((event) => {
        return event.blockInfo.distanceFromMaxBlockHeight !== 0;
      });
      break;
    }
  }
  return fetchedEvents.map((event) => {
    let events = event.eventData.map(({ data, transactionInfo }) => {
      return {
        data,
        transactionInfo
      };
    });
    return {
      events,
      blockHeight: UInt322.from(event.blockInfo.height),
      blockHash: event.blockInfo.stateHash,
      parentBlockHash: event.blockInfo.parentHash,
      globalSlot: UInt322.from(event.blockInfo.globalSlotSinceGenesis),
      chainStatus: event.blockInfo.chainStatus
    };
  });
}
async function fetchActions(accountInfo, graphqlEndpoint = networkConfig.archiveEndpoint) {
  if (!graphqlEndpoint)
    throw new Error("fetchActions: Specified GraphQL endpoint is undefined. Please specify a valid endpoint.");
  const { publicKey, actionStates, tokenId = TokenId4.toBase58(TokenId4.default) } = accountInfo;
  let [response, error] = await makeGraphqlRequest(getActionsQuery(publicKey, actionStates, tokenId), graphqlEndpoint, networkConfig.archiveFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  let fetchedActions = response?.data.actions;
  if (fetchedActions === void 0) {
    return {
      error: {
        statusCode: 404,
        statusText: `fetchActions: Account with public key ${publicKey} with tokenId ${tokenId} does not exist.`
      }
    };
  }
  let numberOfBestTipBlocks = 0;
  for (let i2 = 0; i2 < fetchedActions.length; i2++) {
    if (fetchedActions[i2].blockInfo.distanceFromMaxBlockHeight === 0) {
      numberOfBestTipBlocks++;
    }
    if (numberOfBestTipBlocks > 1) {
      fetchedActions = fetchedActions.filter((action) => {
        return action.blockInfo.distanceFromMaxBlockHeight !== 0;
      });
      break;
    }
  }
  let actionsList = [];
  if (fetchedActions.length !== 0 && fetchedActions[0].actionState.actionStateOne === actionStates.fromActionState) {
    fetchedActions = fetchedActions.slice(1);
  }
  fetchedActions.forEach((actionBlock) => {
    let { actionData } = actionBlock;
    let latestActionState = Field4(actionBlock.actionState.actionStateTwo);
    let actionState = actionBlock.actionState.actionStateOne;
    if (actionData.length === 0)
      throw Error(`No action data was found for the account ${publicKey} with the latest action state ${actionState}`);
    let actionsByAccountUpdate = [];
    let currentAccountUpdateId = "none";
    let currentActions;
    actionData.forEach(({ accountUpdateId, data }) => {
      if (accountUpdateId === currentAccountUpdateId) {
        currentActions.push(data);
      } else {
        currentAccountUpdateId = accountUpdateId;
        currentActions = [data];
        actionsByAccountUpdate.push(currentActions);
      }
    });
    for (let actions of actionsByAccountUpdate) {
      latestActionState = updateActionState(actions, latestActionState);
      actionsList.push({ actions, hash: latestActionState.toString() });
    }
    const finalActionState = latestActionState.toString();
    const expectedActionState = actionState;
    if (finalActionState !== expectedActionState) {
      throw new Error(`Failed to derive correct actions hash for ${publicKey}.
        Derived hash: ${finalActionState}, expected hash: ${expectedActionState}).
        All action hashes derived: ${JSON.stringify(actionsList, null, 2)}
        Please try a different Archive Node API endpoint.
        `);
    }
  });
  addCachedActions({ publicKey, tokenId }, actionsList, graphqlEndpoint);
  return actionsList;
}
async function fetchGenesisConstants(graphqlEndpoint = networkConfig.minaEndpoint) {
  let [resp, error] = await makeGraphqlRequest(genesisConstantsQuery, graphqlEndpoint, networkConfig.minaFallbackEndpoints);
  if (error)
    throw Error(error.statusText);
  const genesisConstants = resp?.data?.genesisConstants;
  const consensusConfiguration = resp?.data?.daemonStatus?.consensusConfiguration;
  if (genesisConstants === void 0 || consensusConfiguration === void 0) {
    throw Error("Failed to fetch genesis constants.");
  }
  const data = {
    genesisTimestamp: genesisConstants.genesisTimestamp,
    coinbase: Number(genesisConstants.coinbase),
    accountCreationFee: Number(genesisConstants.accountCreationFee),
    epochDuration: Number(consensusConfiguration.epochDuration),
    k: Number(consensusConfiguration.k),
    slotDuration: Number(consensusConfiguration.slotDuration),
    slotsPerEpoch: Number(consensusConfiguration.slotsPerEpoch)
  };
  genesisConstantsCache[graphqlEndpoint] = data;
  return data;
}
var Lightnet;
(function(Lightnet2) {
  async function acquireKeyPair(options = {}) {
    const { isRegularAccount = true, lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint } = options;
    const response = await fetch(`${lightnetAccountManagerEndpoint}/acquire-account?isRegularAccount=${isRegularAccount}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (response.ok) {
      const data = await response.json();
      if (data) {
        return {
          publicKey: PublicKey2.fromBase58(data.pk),
          privateKey: PrivateKey2.fromBase58(data.sk)
        };
      }
    }
    throw new Error("Failed to acquire the key pair");
  }
  Lightnet2.acquireKeyPair = acquireKeyPair;
  async function releaseKeyPair(options) {
    const { publicKey, lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint } = options;
    const response = await fetch(`${lightnetAccountManagerEndpoint}/release-account`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        pk: publicKey
      })
    });
    if (response.ok) {
      const data = await response.json();
      if (data) {
        return data.message;
      }
    }
    return null;
  }
  Lightnet2.releaseKeyPair = releaseKeyPair;
  async function listAcquiredKeyPairs(options) {
    const { lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint } = options;
    const response = await fetch(`${lightnetAccountManagerEndpoint}/list-acquired-accounts`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (response.ok) {
      const data = await response.json();
      if (data) {
        return data.map((account) => ({
          publicKey: PublicKey2.fromBase58(account.pk),
          privateKey: PrivateKey2.fromBase58(account.sk)
        }));
      }
    }
    return null;
  }
  Lightnet2.listAcquiredKeyPairs = listAcquiredKeyPairs;
})(Lightnet || (Lightnet = {}));
function updateActionState(actions, actionState) {
  let actionHash = Actions.fromJSON(actions).hash;
  return Actions.updateSequenceState(actionState, actionHash);
}
function removeJsonQuotes(json) {
  let cleaned = JSON.stringify(JSON.parse(json), null, 2);
  return cleaned.replace(/\"(\S+)\"\s*:/gm, "$1:");
}
async function makeGraphqlRequest(query, graphqlEndpoint = networkConfig.minaEndpoint, fallbackEndpoints, { timeout = defaultTimeout } = {}) {
  if (graphqlEndpoint === "none")
    throw Error("Should have made a graphql request, but don't know to which endpoint. Try calling `setGraphqlEndpoint` first.");
  let timeouts = [];
  const clearTimeouts = () => {
    timeouts.forEach((t) => clearTimeout(t));
    timeouts = [];
  };
  const makeRequest = async (url2) => {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeout);
    timeouts.push(timer);
    let body = JSON.stringify({ operationName: null, query, variables: {} });
    try {
      let response = await fetch(url2, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body,
        signal: controller.signal
      });
      return checkResponseStatus(response);
    } finally {
      clearTimeouts();
    }
  };
  let timeoutErrors = [];
  let urls = [graphqlEndpoint, ...fallbackEndpoints];
  for (let i2 = 0; i2 < urls.length; i2 += 2) {
    let url1 = urls[i2];
    let url2 = urls[i2 + 1];
    if (url2 === void 0) {
      try {
        return await makeRequest(url1);
      } catch (error) {
        return [void 0, inferError(error)];
      }
    }
    try {
      return await Promise.race([makeRequest(url1), makeRequest(url2)]);
    } catch (unknownError) {
      let error = inferError(unknownError);
      if (error.statusCode === 408) {
        timeoutErrors.push({ url1, url2, error });
      } else {
        return [void 0, error];
      }
    }
  }
  const statusText = timeoutErrors.map(({ url1, url2, error }) => `Request to ${url1} and ${url2} timed out. Error: ${error}`).join("\n");
  return [void 0, { statusCode: 408, statusText }];
}
async function checkResponseStatus(response) {
  if (response.ok) {
    let jsonResponse = await response.json();
    if (jsonResponse.errors && jsonResponse.errors.length > 0) {
      return [
        void 0,
        {
          statusCode: response.status,
          statusText: jsonResponse.errors.map((error) => error.message).join("\n")
        }
      ];
    } else if (jsonResponse.data === void 0) {
      return [
        void 0,
        {
          statusCode: response.status,
          statusText: `GraphQL response data is undefined`
        }
      ];
    }
    return [jsonResponse, void 0];
  } else {
    return [
      void 0,
      {
        statusCode: response.status,
        statusText: response.statusText
      }
    ];
  }
}
function inferError(error) {
  let errorMessage = JSON.stringify(error);
  if (error instanceof AbortSignal) {
    return { statusCode: 408, statusText: `Request Timeout: ${errorMessage}` };
  } else {
    return {
      statusCode: 500,
      statusText: `Unknown Error: ${errorMessage}`
    };
  }
}

// dist/node/lib/state.js
function State2() {
  return createState();
}
function state2(stateType) {
  return function(target, key, _descriptor) {
    const ZkappClass = target.constructor;
    if (reservedPropNames.has(key)) {
      throw Error(`Property name ${key} is reserved.`);
    }
    let sc = smartContracts.get(ZkappClass);
    if (sc === void 0) {
      sc = { states: [], layout: void 0 };
      smartContracts.set(ZkappClass, sc);
    }
    sc.states.push([key, stateType]);
    Object.defineProperty(target, key, {
      get() {
        return this._?.[key];
      },
      set(v) {
        if (v._contract !== void 0)
          throw Error("A State should only be assigned once to a SmartContract");
        if (this._?.[key])
          throw Error("A @state should only be assigned once");
        v._contract = {
          key,
          stateType,
          instance: this,
          class: ZkappClass,
          wasConstrained: false,
          wasRead: false,
          cachedVariable: void 0
        };
        (this._ ??= {})[key] = v;
      }
    });
  };
}
function declareState(SmartContract2, states) {
  for (let key in states) {
    let CircuitValue2 = states[key];
    state2(CircuitValue2)(SmartContract2.prototype, key);
  }
}
function createState() {
  return {
    _contract: void 0,
    set(state3) {
      if (this._contract === void 0)
        throw Error("set can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state3);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i2) => {
        AccountUpdate3.setValue(accountUpdate.body.update.appState[layout.offset + i2], x);
      });
    },
    requireEquals(state3) {
      if (this._contract === void 0)
        throw Error("requireEquals can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state3);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i2) => {
        AccountUpdate3.assertEquals(accountUpdate.body.preconditions.account.state[layout.offset + i2], x);
      });
      this._contract.wasConstrained = true;
    },
    assertEquals(state3) {
      this.requireEquals(state3);
    },
    requireNothing() {
      if (this._contract === void 0)
        throw Error("requireNothing can only be called when the State is assigned to a SmartContract @state.");
      this._contract.wasConstrained = true;
    },
    assertNothing() {
      this.requireNothing();
    },
    get() {
      if (this._contract === void 0)
        throw Error("get can only be called when the State is assigned to a SmartContract @state.");
      if (this._contract.cachedVariable !== void 0 && // `inCheckedComputation() === true` here always implies being inside a wrapped smart contract method,
      // which will ensure that the cache is cleaned up before & after each method run.
      Provable.inCheckedComputation()) {
        this._contract.wasRead = true;
        return this._contract.cachedVariable;
      }
      let layout = getLayoutPosition(this._contract);
      let contract = this._contract;
      let inProver_ = Provable.inProver();
      let stateFieldsType = Provable.Array(Field4, layout.length);
      let stateAsFields = Provable.witness(stateFieldsType, () => {
        let account;
        try {
          account = getAccount(contract.instance.address, contract.instance.self.body.tokenId);
        } catch (err) {
          if (inProver_) {
            throw err;
          }
          let message = `${contract.key}.get() failed, either:
1. We can't find this zkapp account in the ledger
2. Because the zkapp account was not found in the cache. Try calling \`await fetchAccount(zkappAddress)\` first.
If none of these are the case, then please reach out on Discord at #zkapp-developers and/or open an issue to tell us!`;
          if (err.message) {
            err.message = message + `

${err.message}`;
            throw err;
          } else {
            throw Error(message);
          }
        }
        if (account.zkapp?.appState === void 0) {
          return Array(layout.length).fill(Field4(0));
        } else {
          let stateAsFields2 = [];
          for (let i2 = 0; i2 < layout.length; ++i2) {
            stateAsFields2.push(account.zkapp.appState[layout.offset + i2]);
          }
          return stateAsFields2;
        }
      });
      let state3 = this._contract.stateType.fromFields(stateAsFields);
      if (Provable.inCheckedComputation())
        this._contract.stateType.check?.(state3);
      this._contract.wasRead = true;
      this._contract.cachedVariable = state3;
      return state3;
    },
    getAndRequireEquals() {
      let state3 = this.get();
      this.requireEquals(state3);
      return state3;
    },
    getAndAssertEquals() {
      return this.getAndRequireEquals();
    },
    async fetch() {
      if (this._contract === void 0)
        throw Error("fetch can only be called when the State is assigned to a SmartContract @state.");
      if (currentTransaction.has())
        throw Error("fetch is not intended to be called inside a transaction block.");
      let layout = getLayoutPosition(this._contract);
      let address = this._contract.instance.address;
      let { account } = await fetchAccount({
        publicKey: address,
        tokenId: TokenId4.toBase58(TokenId4.default)
      });
      if (account === void 0)
        return void 0;
      let stateAsFields;
      if (account.zkapp?.appState === void 0) {
        stateAsFields = Array(layout.length).fill(Field4(0));
      } else {
        stateAsFields = [];
        for (let i2 = 0; i2 < layout.length; i2++) {
          stateAsFields.push(account.zkapp.appState[layout.offset + i2]);
        }
      }
      return this._contract.stateType.fromFields(stateAsFields);
    },
    fromAppState(appState) {
      if (this._contract === void 0)
        throw Error("fromAppState() can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = [];
      for (let i2 = 0; i2 < layout.length; ++i2) {
        stateAsFields.push(appState[layout.offset + i2]);
      }
      return this._contract.stateType.fromFields(stateAsFields);
    }
  };
}
function getLayoutPosition({ key, class: contractClass }) {
  let layout = getLayout(contractClass);
  let stateLayout = layout.get(key);
  if (stateLayout === void 0) {
    throw new Error(`state ${key} not found`);
  }
  return stateLayout;
}
function getLayout(scClass) {
  let sc = smartContracts.get(scClass);
  if (sc === void 0)
    throw Error("bug");
  if (sc.layout === void 0) {
    let layout = /* @__PURE__ */ new Map();
    sc.layout = layout;
    let offset = 0;
    sc.states.forEach(([key, stateType]) => {
      let length = stateType.sizeInFields();
      layout.set(key, { offset, length });
      offset += length;
    });
  }
  return sc.layout;
}
var smartContracts = /* @__PURE__ */ new WeakMap();
var reservedPropNames = /* @__PURE__ */ new Set(["_methods", "_"]);
function assertStatePrecondition(sc) {
  try {
    for (let [key, context] of getStateContexts(sc)) {
      if (!context?.wasRead || context.wasConstrained)
        continue;
      let errorMessage = `You used \`this.${key}.get()\` without adding a precondition that links it to the actual on-chain state.
Consider adding this line to your code:
this.${key}.assertEquals(this.${key}.get());`;
      throw Error(errorMessage);
    }
  } finally {
    cleanStatePrecondition(sc);
  }
}
function cleanStatePrecondition(sc) {
  for (let [, context] of getStateContexts(sc)) {
    if (context === void 0)
      continue;
    context.wasRead = false;
    context.wasConstrained = false;
    context.cachedVariable = void 0;
  }
}
function getStateContexts(sc) {
  let scClass = sc.constructor;
  let scInfo = smartContracts.get(scClass);
  if (scInfo === void 0)
    return [];
  return scInfo.states.map(([key]) => [key, sc[key]?._contract]);
}

// dist/node/lib/zkapp.js
var _SmartContract_executionState;
var _SmartContract__senderState;
var reservedPropNames2 = /* @__PURE__ */ new Set(["_methods", "_"]);
function method(target, methodName, descriptor) {
  const ZkappClass = target.constructor;
  if (reservedPropNames2.has(methodName)) {
    throw Error(`Property name ${methodName} is reserved.`);
  }
  if (typeof target[methodName] !== "function") {
    throw Error(`@method decorator was applied to \`${methodName}\`, which is not a function.`);
  }
  let paramTypes = Reflect.getMetadata("design:paramtypes", target, methodName);
  let returnType = Reflect.getMetadata("design:returntype", target, methodName);
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = ZkappPublicInput;
  SelfProof2.publicOutputType = Empty;
  SelfProof2.tag = () => ZkappClass;
  let internalMethodEntry = sortMethodArguments(ZkappClass.name, methodName, paramTypes, SelfProof2);
  let methodEntry = sortMethodArguments(ZkappClass.name, methodName, [PublicKey2, Field4, ...paramTypes], SelfProof2);
  if (isAsFields(returnType)) {
    internalMethodEntry.returnType = returnType;
    methodEntry.returnType = returnType;
  }
  ZkappClass._methods ??= [];
  ZkappClass._methods.push(methodEntry);
  ZkappClass._maxProofsVerified ??= 0;
  ZkappClass._maxProofsVerified = Math.max(ZkappClass._maxProofsVerified, methodEntry.proofArgs.length);
  let func = descriptor.value;
  descriptor.value = wrapMethod(func, ZkappClass, internalMethodEntry);
}
function wrapMethod(method2, ZkappClass, methodIntf) {
  let methodName = methodIntf.methodName;
  return function wrappedMethod(...actualArgs) {
    cleanStatePrecondition(this);
    actualArgs.forEach((arg) => {
      if (arg instanceof AccountUpdate3) {
        AccountUpdate3.unlink(arg);
      }
    });
    let insideContract = smartContractContext.get();
    if (!insideContract) {
      const context = {
        this: this,
        methodCallDepth: 0,
        selfUpdate: selfAccountUpdate(this, methodName)
      };
      let id2 = smartContractContext.enter(context);
      try {
        if (inCompile() || inProver() || inAnalyze()) {
          let proverData = inProver() ? zkAppProver.getData() : void 0;
          let txId = currentTransaction.enter({
            sender: proverData?.transaction.feePayer.body.publicKey,
            accountUpdates: [],
            fetchMode: inProver() ? "cached" : "test",
            isFinalRunOutsideCircuit: false,
            numberOfRuns: void 0
          });
          try {
            let publicInput = actualArgs.shift();
            let accountUpdate = this.self;
            let blindingValue = Provable.witness(Field4, getBlindingValue);
            let context2 = memoizationContext() ?? {
              memoized: [],
              currentIndex: 0
            };
            let id3 = memoizationContext.enter({ ...context2, blindingValue });
            let result;
            try {
              let clonedArgs = actualArgs.map(cloneCircuitValue);
              result = method2.apply(this, clonedArgs);
            } finally {
              memoizationContext.leave(id3);
            }
            let callDataFields = computeCallData(methodIntf, actualArgs, result, blindingValue);
            accountUpdate.body.callData = Poseidon2.hash(callDataFields);
            Authorization.setProofAuthorizationKind(accountUpdate);
            if (DEBUG_PUBLIC_INPUT_CHECK) {
              Provable.asProver(() => {
                function diff(prover, input) {
                  delete prover.id;
                  delete prover.callDepth;
                  delete input.id;
                  delete input.callDepth;
                  if (JSON.stringify(prover) !== JSON.stringify(input)) {
                    console.log("transaction:", ZkappCommand3.toPretty(transaction2));
                    console.log("index", index);
                    console.log("inconsistent account updates:");
                    console.log("update created by the prover:");
                    console.log(prover);
                    console.log("update created in transaction block:");
                    console.log(input);
                  }
                }
                function diffRecursive(prover, input) {
                  diff(prover.toPretty(), input.toPretty());
                  let nChildren = input.children.accountUpdates.length;
                  for (let i2 = 0; i2 < nChildren; i2++) {
                    let inputChild = input.children.accountUpdates[i2];
                    let child = prover.children.accountUpdates[i2];
                    if (!inputChild || !child)
                      return;
                    diffRecursive(child, inputChild);
                  }
                }
                let { accountUpdate: inputUpdate, transaction: transaction2, index } = zkAppProver.getData();
                diffRecursive(accountUpdate, inputUpdate);
              });
            }
            checkPublicInput(publicInput, accountUpdate);
            assertPreconditionInvariants(accountUpdate);
            cleanPreconditionsCache(accountUpdate);
            assertStatePrecondition(this);
            return result;
          } finally {
            currentTransaction.leave(txId);
          }
        } else if (!currentTransaction.has()) {
          let result = method2.apply(this, actualArgs);
          assertPreconditionInvariants(this.self);
          cleanPreconditionsCache(this.self);
          assertStatePrecondition(this);
          return result;
        } else {
          let accountUpdate = context.selfUpdate;
          currentTransaction()?.accountUpdates.push(accountUpdate);
          let clonedArgs = cloneCircuitValue(actualArgs);
          let blindingValue = getBlindingValue();
          let memoContext = { memoized: [], currentIndex: 0, blindingValue };
          let memoId = memoizationContext.enter(memoContext);
          let result;
          try {
            result = method2.apply(this, actualArgs.map((a2, i2) => {
              let arg = methodIntf.allArgs[i2];
              if (arg.type === "witness") {
                let type = methodIntf.witnessArgs[arg.index];
                return Provable.witness(type, () => a2);
              }
              return a2;
            }));
          } finally {
            memoizationContext.leave(memoId);
          }
          let { memoized } = memoContext;
          assertStatePrecondition(this);
          let callDataFields = computeCallData(methodIntf, clonedArgs, result, blindingValue);
          accountUpdate.body.callData = Poseidon2.hash(callDataFields);
          if (!Authorization.hasAny(accountUpdate)) {
            Authorization.setLazyProof(accountUpdate, {
              methodName: methodIntf.methodName,
              args: clonedArgs,
              // proofs actually don't have to be cloned
              previousProofs: getPreviousProofsForProver(actualArgs, methodIntf),
              ZkappClass,
              memoized,
              blindingValue
            }, currentTransaction().accountUpdates);
          }
          return result;
        }
      } finally {
        smartContractContext.leave(id2);
      }
    }
    let parentAccountUpdate = insideContract.this.self;
    let methodCallDepth = insideContract.methodCallDepth;
    let innerContext = {
      this: this,
      methodCallDepth: methodCallDepth + 1,
      selfUpdate: selfAccountUpdate(this, methodName)
    };
    let id = smartContractContext.enter(innerContext);
    try {
      let { returnType } = methodIntf;
      let noReturnTypeError = `To return a result from ${methodIntf.methodName}() inside another zkApp, you need to declare the return type.
This can be done by annotating the type at the end of the function signature. For example:

@method ${methodIntf.methodName}(): Field {
  // ...
}

Note: Only types built out of \`Field\` are valid return types. This includes o1js primitive types and custom CircuitValues.`;
      if (ZkappClass._methodMetadata?.[methodIntf.methodName]?.hasReturn && returnType === void 0) {
        throw Error(noReturnTypeError);
      }
      let blindingValue = getBlindingValue();
      let runCalledContract = () => {
        let constantArgs = methodArgumentsToConstant(methodIntf, actualArgs);
        let constantBlindingValue = blindingValue.toConstant();
        let accountUpdate2 = this.self;
        accountUpdate2.body.callDepth = parentAccountUpdate.body.callDepth + 1;
        accountUpdate2.parent = parentAccountUpdate;
        let memoContext = {
          memoized: [],
          currentIndex: 0,
          blindingValue: constantBlindingValue
        };
        let memoId = memoizationContext.enter(memoContext);
        let result2;
        try {
          result2 = method2.apply(this, constantArgs.map(cloneCircuitValue));
        } finally {
          memoizationContext.leave(memoId);
        }
        let { memoized } = memoContext;
        assertStatePrecondition(this);
        if (result2 !== void 0) {
          if (returnType === void 0) {
            throw Error(noReturnTypeError);
          } else {
            result2 = toConstant2(returnType, result2);
          }
        }
        let callDataFields2 = computeCallData(methodIntf, constantArgs, result2, constantBlindingValue);
        accountUpdate2.body.callData = hashConstant(callDataFields2);
        if (!Authorization.hasAny(accountUpdate2)) {
          Authorization.setLazyProof(accountUpdate2, {
            methodName: methodIntf.methodName,
            args: constantArgs,
            previousProofs: getPreviousProofsForProver(constantArgs, methodIntf),
            ZkappClass,
            memoized,
            blindingValue: constantBlindingValue
          }, currentTransaction().accountUpdates);
        }
        return { accountUpdate: accountUpdate2, result: result2 ?? null };
      };
      let { accountUpdate, result } = methodCallDepth === 0 ? AccountUpdate3.witness(returnType ?? provable(null), runCalledContract, { skipCheck: true }) : runCalledContract();
      innerContext.selfUpdate = accountUpdate;
      accountUpdate.body.callDepth = parentAccountUpdate.body.callDepth + 1;
      accountUpdate.parent = parentAccountUpdate;
      accountUpdate.children.callsType = { type: "Witness" };
      parentAccountUpdate.children.accountUpdates.push(accountUpdate);
      accountUpdate.body.publicKey.assertEquals(this.address);
      accountUpdate.body.tokenId.assertEquals(this.self.body.tokenId);
      let callDataFields = computeCallData(methodIntf, actualArgs, result, blindingValue);
      let callData = Poseidon2.hash(callDataFields);
      accountUpdate.body.callData.assertEquals(callData);
      return result;
    } finally {
      smartContractContext.leave(id);
    }
  };
}
function checkPublicInput({ accountUpdate, calls }, self) {
  let otherInput = self.toPublicInput();
  accountUpdate.assertEquals(otherInput.accountUpdate);
  calls.assertEquals(otherInput.calls);
}
function computeCallData(methodIntf, argumentValues, returnValue, blindingValue) {
  let { returnType, methodName } = methodIntf;
  let args = methodArgumentTypesAndValues(methodIntf, argumentValues);
  let argSizesAndFields = args.map(({ type, value }) => [
    Field4(type.sizeInFields()),
    ...type.toFields(value)
  ]);
  let totalArgSize = Field4(args.map(({ type }) => type.sizeInFields()).reduce((s, t) => s + t, 0));
  let totalArgFields = argSizesAndFields.flat();
  let returnSize = Field4(returnType?.sizeInFields() ?? 0);
  let returnFields = returnType?.toFields(returnValue) ?? [];
  let methodNameFields = stringToFields(methodName);
  return [
    // we have to encode the sizes of arguments / return value, so that fields can't accidentally shift
    // from one argument to another, or from arguments to the return value, or from the return value to the method name
    totalArgSize,
    ...totalArgFields,
    returnSize,
    ...returnFields,
    // we don't have to encode the method name size because the blinding value is fixed to one field element,
    // so method name fields can't accidentally become the blinding value and vice versa
    ...methodNameFields,
    blindingValue
  ];
}
var Callback = class _Callback extends GenericArgument {
  static create(instance, methodName, args) {
    let ZkappClass = instance.constructor;
    let methodIntf_ = (ZkappClass._methods ?? []).find((i2) => i2.methodName === methodName);
    if (methodIntf_ === void 0)
      throw Error(`Callback: could not find method ${ZkappClass.name}.${String(methodName)}`);
    let methodIntf = {
      ...methodIntf_,
      returnType: methodIntf_.returnType ?? provable(null)
    };
    let result = instance[methodName](...args);
    let accountUpdate = instance.self;
    let callback = new _Callback({
      instance,
      methodIntf,
      args,
      result,
      accountUpdate,
      isEmpty: false
    });
    return callback;
  }
  constructor(self) {
    super();
    Object.assign(this, self);
  }
};
var SmartContract = class {
  /**
   * Returns a Proof type that belongs to this {@link SmartContract}.
   */
  static Proof() {
    var _a;
    let Contract = this;
    return _a = class extends Proof {
    }, _a.publicInputType = ZkappPublicInput, _a.publicOutputType = Empty, _a.tag = () => Contract, _a;
  }
  constructor(address, tokenId) {
    _SmartContract_executionState.set(this, void 0);
    _SmartContract__senderState.set(this, void 0);
    this.events = {};
    this.address = address;
    this.tokenId = tokenId ?? TokenId4.default;
    Object.defineProperty(this, "reducer", {
      set(reducer) {
        (this._ ??= {}).reducer = reducer;
      },
      get() {
        return getReducer(this);
      }
    });
  }
  /**
   * Compile your smart contract.
   *
   * This generates both the prover functions, needed to create proofs for running `@method`s,
   * and the verification key, needed to deploy your zkApp.
   *
   * Although provers and verification key are returned by this method, they are also cached internally and used when needed,
   * so you don't actually have to use the return value of this function.
   *
   * Under the hood, "compiling" means calling into the lower-level [Pickles and Kimchi libraries](https://o1-labs.github.io/proof-systems/kimchi/overview.html) to
   * create multiple prover & verifier indices (one for each smart contract method as part of a "step circuit" and one for the "wrap circuit" which recursively wraps
   * it so that proofs end up in the original finite field). These are fairly expensive operations, so **expect compiling to take at least 20 seconds**,
   * up to several minutes if your circuit is large or your hardware is not optimal for these operations.
   */
  static async compile({ cache: cache2 = Cache.FileSystemDefault, forceRecompile = false } = {}) {
    let methodIntfs = this._methods ?? [];
    let methods = methodIntfs.map(({ methodName }) => {
      return (publicInput, publicKey, tokenId, ...args) => {
        let instance = new this(publicKey, tokenId);
        instance[methodName](publicInput, ...args);
      };
    });
    let methodsMeta = this.analyzeMethods();
    let gates = methodIntfs.map((intf) => methodsMeta[intf.methodName].gates);
    let { verificationKey, provers, verify: verify3 } = await compileProgram({
      publicInputType: ZkappPublicInput,
      publicOutputType: Empty,
      methodIntfs,
      methods,
      gates,
      proofSystemTag: this,
      cache: cache2,
      forceRecompile
    });
    this._provers = provers;
    this._verificationKey = verificationKey;
    return { verificationKey, provers, verify: verify3 };
  }
  /**
   * Computes a hash of your smart contract, which will reliably change _whenever one of your method circuits changes_.
   * This digest is quick to compute. it is designed to help with deciding whether a contract should be re-compiled or
   * a cached verification key can be used.
   * @returns the digest, as a hex string
   */
  static digest() {
    let methodData = this.analyzeMethods();
    let hash3 = hashConstant(Object.values(methodData).map((d) => Field4(BigInt("0x" + d.digest))));
    return hash3.toBigInt().toString(16);
  }
  /**
   * Deploys a {@link SmartContract}.
   *
   * ```ts
   * let tx = await Mina.transaction(sender, () => {
   *   AccountUpdate.fundNewAccount(sender);
   *   zkapp.deploy();
   * });
   * tx.sign([senderKey, zkAppKey]);
   * ```
   */
  deploy({ verificationKey, zkappKey } = {}) {
    let accountUpdate = this.newSelf("deploy");
    verificationKey ??= this.constructor._verificationKey;
    if (verificationKey === void 0) {
      if (!getProofsEnabled()) {
        let [, data2, hash4] = Pickles.dummyVerificationKey();
        verificationKey = { data: data2, hash: Field4(hash4) };
      } else {
        throw Error(`\`${this.constructor.name}.deploy()\` was called but no verification key was found.
Try calling \`await ${this.constructor.name}.compile()\` first, this will cache the verification key in the background.`);
      }
    }
    let { hash: hash_, data } = verificationKey;
    let hash3 = Field4.from(hash_);
    accountUpdate.account.verificationKey.set({ hash: hash3, data });
    accountUpdate.account.permissions.set(Permissions.default());
    accountUpdate.sign(zkappKey);
    AccountUpdate3.attachToTransaction(accountUpdate);
    let shouldInit = !hasAccount(this.address) || getAccount(this.address).zkapp?.verificationKey === void 0;
    if (!shouldInit)
      return;
    else
      this.init();
    let initUpdate = this.self;
    (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, {
      transactionId: (0, import_tslib5.__classPrivateFieldGet)(this, _SmartContract_executionState, "f").transactionId,
      accountUpdate
    }, "f");
    let isFirstRun = currentTransaction()?.numberOfRuns === 0;
    if (!isFirstRun)
      return;
    Provable.asProver(() => {
      if (initUpdate.update.appState.some(({ isSome }) => !isSome.toBoolean())) {
        console.warn(`WARNING: the \`init()\` method was called without overwriting the entire state. This means that your zkApp will lack
the \`provedState === true\` status which certifies that the current state was verifiably produced by proofs (and not arbitrarily set by the zkApp developer).
To make sure the entire state is reset, consider adding this line to the beginning of your \`init()\` method:
super.init();
`);
      }
    });
  }
  // TODO make this a @method and create a proof during `zk deploy` (+ add mechanism to skip this)
  /**
   * `SmartContract.init()` will be called only when a {@link SmartContract} will be first deployed, not for redeployment.
   * This method can be overridden as follows
   * ```
   * class MyContract extends SmartContract {
   *  init() {
   *    super.init();
   *    this.account.permissions.set(...);
   *    this.x.set(Field(1));
   *  }
   * }
   * ```
   */
  init() {
    this.account.provedState.assertEquals(Bool4(false));
    let accountUpdate = this.self;
    for (let i2 = 0; i2 < ZkappStateLength; i2++) {
      AccountUpdate3.setValue(accountUpdate.body.update.appState[i2], Field4(0));
    }
    AccountUpdate3.attachToTransaction(accountUpdate);
  }
  /**
   * Use this command if the account update created by this SmartContract should be signed by the account owner,
   * instead of authorized with a proof.
   *
   * Note that the smart contract's {@link Permissions} determine which updates have to be (can be) authorized by a signature.
   *
   * If you only want to avoid creating proofs for quicker testing, we advise you to
   * use `LocalBlockchain({ proofsEnabled: false })` instead of `requireSignature()`. Setting
   * `proofsEnabled` to `false` allows you to test your transactions with the same authorization flow as in production,
   * with the only difference being that quick mock proofs are filled in instead of real proofs.
   */
  requireSignature() {
    this.self.requireSignature();
  }
  /**
   * @deprecated `this.sign()` is deprecated in favor of `this.requireSignature()`
   */
  sign(zkappKey) {
    this.self.sign(zkappKey);
  }
  /**
   * Use this command if the account update created by this SmartContract should have no authorization on it,
   * instead of being authorized with a proof.
   *
   * WARNING: This is a method that should rarely be useful. If you want to disable proofs for quicker testing, take a look
   * at `LocalBlockchain({ proofsEnabled: false })`, which causes mock proofs to be created and doesn't require changing the
   * authorization flow.
   */
  skipAuthorization() {
    Authorization.setLazyNone(this.self);
  }
  /**
   * Returns the current {@link AccountUpdate} associated to this {@link SmartContract}.
   */
  get self() {
    let inTransaction = currentTransaction.has();
    let inSmartContract = smartContractContext.get();
    if (!inTransaction && !inSmartContract) {
      return selfAccountUpdate(this);
    }
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    if (inSmartContract && inSmartContract.this === this) {
      let accountUpdate2 = inSmartContract.selfUpdate;
      (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, { accountUpdate: accountUpdate2, transactionId }, "f");
      return accountUpdate2;
    }
    let executionState = (0, import_tslib5.__classPrivateFieldGet)(this, _SmartContract_executionState, "f");
    if (executionState !== void 0 && executionState.transactionId === transactionId) {
      return executionState.accountUpdate;
    }
    let accountUpdate = selfAccountUpdate(this);
    (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  // same as this.self, but explicitly creates a _new_ account update
  /**
   * Same as `SmartContract.self` but explicitly creates a new {@link AccountUpdate}.
   */
  newSelf(methodName) {
    let inTransaction = currentTransaction.has();
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    let accountUpdate = selfAccountUpdate(this, methodName);
    (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  /**
   * The public key of the current transaction's sender account.
   *
   * Throws an error if not inside a transaction, or the sender wasn't passed in.
   *
   * **Warning**: The fact that this public key equals the current sender is not part of the proof.
   * A malicious prover could use any other public key without affecting the validity of the proof.
   */
  get sender() {
    if (!currentTransaction.has()) {
      throw Error(`this.sender is not available outside a transaction. Make sure you only use it within \`Mina.transaction\` blocks or smart contract methods.`);
    }
    let transactionId = currentTransaction.id();
    if ((0, import_tslib5.__classPrivateFieldGet)(this, _SmartContract__senderState, "f")?.transactionId === transactionId) {
      return (0, import_tslib5.__classPrivateFieldGet)(this, _SmartContract__senderState, "f").sender;
    } else {
      let sender2 = Provable.witness(PublicKey2, () => sender());
      (0, import_tslib5.__classPrivateFieldSet)(this, _SmartContract__senderState, { transactionId, sender: sender2 }, "f");
      return sender2;
    }
  }
  /**
   * Current account of the {@link SmartContract}.
   */
  get account() {
    return this.self.account;
  }
  /**
   * Current network state of the {@link SmartContract}.
   */
  get network() {
    return this.self.network;
  }
  /**
   * Current global slot on the network. This is the slot at which this transaction is included in a block. Since we cannot know this value
   * at the time of transaction construction, this only has the `assertBetween()` method but no `get()` (impossible to implement)
   * or `assertEquals()` (confusing, because the developer can't know the exact slot at which this will be included either)
   */
  get currentSlot() {
    return this.self.currentSlot;
  }
  /**
   * Token of the {@link SmartContract}.
   */
  get token() {
    return this.self.token();
  }
  /**
   * Approve an account update or callback. This will include the account update in the zkApp's public input,
   * which means it allows you to read and use its content in a proof, make assertions about it, and modify it.
   *
   * If this is called with a callback as the first parameter, it will first extract the account update produced by that callback.
   * The extracted account update is returned.
   *
   * ```ts
   * \@method myApprovingMethod(callback: Callback) {
   *   let approvedUpdate = this.approve(callback);
   * }
   * ```
   *
   * Under the hood, "approving" just means that the account update is made a child of the zkApp in the
   * tree of account updates that forms the transaction.
   * The second parameter `layout` allows you to also make assertions about the approved update's _own_ children,
   * by specifying a certain expected layout of children. See {@link AccountUpdate.Layout}.
   *
   * @param updateOrCallback
   * @param layout
   * @returns The account update that was approved (needed when passing in a Callback)
   */
  approve(updateOrCallback, layout) {
    let accountUpdate = updateOrCallback instanceof AccountUpdate3 ? updateOrCallback : Provable.witness(AccountUpdate3, () => updateOrCallback.accountUpdate);
    this.self.approve(accountUpdate, layout);
    return accountUpdate;
  }
  send(args) {
    return this.self.send(args);
  }
  /**
   * @deprecated use `this.account.tokenSymbol`
   */
  get tokenSymbol() {
    return this.self.tokenSymbol;
  }
  /**
   * Balance of this {@link SmartContract}.
   */
  get balance() {
    return this.self.balance;
  }
  // TODO: not able to type event such that it is inferred correctly so far
  /**
   * Emits an event. Events will be emitted as a part of the transaction and can be collected by archive nodes.
   */
  emitEvent(type, event) {
    let accountUpdate = this.self;
    let eventTypes = Object.keys(this.events);
    if (eventTypes.length === 0)
      throw Error(`emitEvent: You are trying to emit an event without having declared the types of your events.
Make sure to add a property \`events\` on ${this.constructor.name}, for example: 
class ${this.constructor.name} extends SmartContract {
  events = { 'my-event': Field }
}`);
    let eventNumber = eventTypes.sort().indexOf(type);
    if (eventNumber === -1)
      throw Error(`emitEvent: Unknown event type "${type}". The declared event types are: ${eventTypes.join(", ")}.`);
    let eventType = this.events[type];
    let eventFields;
    if (eventTypes.length === 1) {
      eventFields = eventType.toFields(event);
    } else {
      eventFields = [Field4(eventNumber), ...eventType.toFields(event)];
    }
    accountUpdate.body.events = Events.pushEvent(accountUpdate.body.events, eventFields);
  }
  /**
   * Asynchronously fetches events emitted by this {@link SmartContract} and returns an array of events with their corresponding types.
   * @async
   * @param [start=UInt32.from(0)] - The start height of the events to fetch.
   * @param end - The end height of the events to fetch. If not provided, fetches events up to the latest height.
   * @returns A promise that resolves to an array of objects, each containing the event type and event data for the specified range.
   * @throws If there is an error fetching events from the Mina network.
   * @example
   * const startHeight = UInt32.from(1000);
   * const endHeight = UInt32.from(2000);
   * const events = await myZkapp.fetchEvents(startHeight, endHeight);
   * console.log(events);
   */
  async fetchEvents(start = UInt322.from(0), end) {
    let events = (await fetchEvents2(this.address, this.self.body.tokenId, {
      from: start,
      to: end
    })).filter((eventData) => {
      let height = UInt322.from(eventData.blockHeight);
      return end === void 0 ? start.lessThanOrEqual(height).toBoolean() : start.lessThanOrEqual(height).toBoolean() && height.lessThanOrEqual(end).toBoolean();
    }).map((event) => {
      return event.events.map((eventData) => {
        let { events: events2, ...rest } = event;
        return {
          ...rest,
          event: eventData
        };
      });
    }).flat();
    let sortedEventTypes = Object.keys(this.events).sort();
    return events.map((eventData) => {
      if (sortedEventTypes.length === 1) {
        let type = sortedEventTypes[0];
        let event = this.events[type].fromFields(eventData.event.data.map((f) => Field4(f)));
        return {
          ...eventData,
          type,
          event: {
            data: event,
            transactionInfo: {
              transactionHash: eventData.event.transactionInfo.hash,
              transactionStatus: eventData.event.transactionInfo.status,
              transactionMemo: eventData.event.transactionInfo.memo
            }
          }
        };
      } else {
        let eventObjectIndex = Number(eventData.event.data[0]);
        let type = sortedEventTypes[eventObjectIndex];
        let eventProps = eventData.event.data.slice(1);
        let event = this.events[type].fromFields(eventProps.map((f) => Field4(f)));
        return {
          ...eventData,
          type,
          event: {
            data: event,
            transactionInfo: {
              transactionHash: eventData.event.transactionInfo.hash,
              transactionStatus: eventData.event.transactionInfo.status,
              transactionMemo: eventData.event.transactionInfo.memo
            }
          }
        };
      }
    });
  }
  static runOutsideCircuit(run) {
    if (currentTransaction()?.isFinalRunOutsideCircuit || inProver())
      Provable.asProver(run);
  }
  // TODO: this could also be used to quickly perform any invariant checks on account updates construction
  /**
   * This function is run internally before compiling a smart contract, to collect metadata about what each of your
   * smart contract methods does.
   *
   * For external usage, this function can be handy because calling it involves running all methods in the same "mode" as `compile()` does,
   * so it serves as a quick-to-run check for whether your contract can be compiled without errors, which can greatly speed up iterating.
   *
   * `analyzeMethods()` will also return the number of `rows` of each of your method circuits (i.e., the number of constraints in the underlying proof system),
   * which is a good indicator for circuit size and the time it will take to create proofs.
   * To inspect the created circuit in detail, you can look at the returned `gates`.
   *
   * Note: If this function was already called before, it will short-circuit and just return the metadata collected the first time.
   *
   * @returns an object, keyed by method name, each entry containing:
   *  - `rows` the size of the constraint system created by this method
   *  - `digest` a digest of the method circuit
   *  - `hasReturn` a boolean indicating whether the method returns a value
   *  - `actions` the number of actions the method dispatches
   *  - `gates` the constraint system, represented as an array of gates
   */
  static analyzeMethods() {
    let ZkappClass = this;
    let methodMetadata = ZkappClass._methodMetadata ??= {};
    let methodIntfs = ZkappClass._methods ?? [];
    if (!methodIntfs.every((m) => m.methodName in methodMetadata) && !inAnalyze()) {
      if (snarkContext.get().inRunAndCheck) {
        let err = new Error("Can not analyze methods inside Provable.runAndCheck, because this creates a circuit nested in another circuit");
        err.bootstrap = () => ZkappClass.analyzeMethods();
        throw err;
      }
      let id;
      let insideSmartContract = !!smartContractContext.get();
      if (insideSmartContract)
        id = smartContractContext.enter(null);
      try {
        for (let methodIntf of methodIntfs) {
          let accountUpdate;
          let { rows, digest, result, gates } = analyzeMethod(ZkappPublicInput, methodIntf, (publicInput, publicKey, tokenId, ...args) => {
            let instance = new ZkappClass(publicKey, tokenId);
            let result2 = instance[methodIntf.methodName](publicInput, ...args);
            accountUpdate = (0, import_tslib5.__classPrivateFieldGet)(instance, _SmartContract_executionState, "f").accountUpdate;
            return result2;
          });
          methodMetadata[methodIntf.methodName] = {
            actions: accountUpdate.body.actions.data.length,
            rows,
            digest,
            hasReturn: result !== void 0,
            gates
          };
        }
      } finally {
        if (insideSmartContract)
          smartContractContext.leave(id);
      }
    }
    return methodMetadata;
  }
  /**
   * @deprecated use `this.account.<field>.set()`
   */
  setValue(maybeValue, value) {
    AccountUpdate3.setValue(maybeValue, value);
  }
  /**
   * @deprecated use `this.account.permissions.set()`
   */
  setPermissions(permissions) {
    this.self.account.permissions.set(permissions);
  }
};
_SmartContract_executionState = /* @__PURE__ */ new WeakMap(), _SmartContract__senderState = /* @__PURE__ */ new WeakMap();
function getReducer(contract) {
  let reducer = (contract._ ??= {}).reducer;
  if (reducer === void 0)
    throw Error(`You are trying to use a reducer without having declared its type.
Make sure to add a property \`reducer\` on ${contract.constructor.name}, for example:
class ${contract.constructor.name} extends SmartContract {
  reducer = { actionType: Field };
}`);
  return {
    dispatch(action) {
      let accountUpdate = contract.self;
      let eventFields = reducer.actionType.toFields(action);
      accountUpdate.body.actions = Actions.pushEvent(accountUpdate.body.actions, eventFields);
    },
    reduce(actionLists, stateType, reduce, { state: state3, actionState }, { maxTransactionsWithActions = 32, skipActionStatePrecondition = false } = {}) {
      if (actionLists.length > maxTransactionsWithActions) {
        throw Error(`reducer.reduce: Exceeded the maximum number of lists of actions, ${maxTransactionsWithActions}.
Use the optional \`maxTransactionsWithActions\` argument to increase this number.`);
      }
      let methodData = contract.constructor.analyzeMethods();
      let possibleActionsPerTransaction = [
        ...new Set(Object.values(methodData).map((o) => o.actions)).add(0)
      ].sort((x, y) => x - y);
      let possibleActionTypes = possibleActionsPerTransaction.map((n) => Provable.Array(reducer.actionType, n));
      for (let i2 = 0; i2 < maxTransactionsWithActions; i2++) {
        let actions = i2 < actionLists.length ? actionLists[i2] : [];
        let length = actions.length;
        let lengths = possibleActionsPerTransaction.map((n) => Provable.witness(Bool4, () => Bool4(length === n)));
        let actionss = possibleActionsPerTransaction.map((n, i3) => {
          let type = possibleActionTypes[i3];
          return Provable.witness(type, () => length === n ? actions : emptyValue(type));
        });
        let eventsHashes = actionss.map((actions2) => {
          let events = actions2.map((a2) => reducer.actionType.toFields(a2));
          return Actions.hash(events);
        });
        let eventsHash = Provable.switch(lengths, Field4, eventsHashes);
        let newActionsHash = Actions.updateSequenceState(actionState, eventsHash);
        let isEmpty = lengths[0];
        actionState = Provable.if(isEmpty, actionState, newActionsHash);
        let newStates = actionss.map((actions2) => {
          let newState = Provable.witness(stateType, () => state3);
          Provable.assertEqual(stateType, newState, state3);
          [...actions2].reverse().forEach((action) => {
            newState = reduce(newState, action);
          });
          return newState;
        });
        state3 = Provable.switch(lengths, stateType, newStates);
      }
      if (!skipActionStatePrecondition) {
        contract.account.actionState.assertEquals(actionState);
      }
      return { state: state3, actionState };
    },
    forEach(actionLists, callback, fromActionState, config) {
      const stateType = provable(null);
      let { actionState } = this.reduce(actionLists, stateType, (_, action) => {
        callback(action);
        return null;
      }, { state: null, actionState: fromActionState }, config);
      return actionState;
    },
    getActions(config) {
      let actionsForAccount = [];
      Provable.asProver(() => {
        let actions = getActions(contract.address, config, contract.self.tokenId);
        actionsForAccount = actions.map((event) => (
          // putting our string-Fields back into the original action type
          event.actions.map((action) => reducer.actionType.fromFields(action.map(Field4)))
        ));
      });
      return actionsForAccount;
    },
    async fetchActions(config) {
      let result = await fetchActions2(contract.address, config, contract.self.tokenId);
      if ("error" in result) {
        throw Error(JSON.stringify(result));
      }
      return result.map((event) => (
        // putting our string-Fields back into the original action type
        event.actions.map((action) => reducer.actionType.fromFields(action.map(Field4)))
      ));
    }
  };
}
function selfAccountUpdate(zkapp, methodName) {
  let body = Body.keepAll(zkapp.address, zkapp.tokenId);
  let update = new AccountUpdate3(body, {}, true);
  update.label = methodName ? `${zkapp.constructor.name}.${methodName}()` : `${zkapp.constructor.name}, no method`;
  return update;
}
function Account5(address, tokenId) {
  if (smartContractContext.get()) {
    return AccountUpdate3.create(address, tokenId).account;
  } else {
    return AccountUpdate3.defaultAccountUpdate(address, tokenId).account;
  }
}
function declareMethods(SmartContract2, methodArguments) {
  for (let key in methodArguments) {
    let argumentTypes = methodArguments[key];
    let target = SmartContract2.prototype;
    Reflect.metadata("design:paramtypes", argumentTypes)(target, key);
    let descriptor = Object.getOwnPropertyDescriptor(target, key);
    method(SmartContract2.prototype, key, descriptor);
    Object.defineProperty(target, key, descriptor);
  }
}
var Reducer = Object.defineProperty(function(reducer) {
  return reducer;
}, "initialActionState", { get: Actions.emptyActionState });
var DEBUG_PUBLIC_INPUT_CHECK = false;

// dist/node/mina-signer/src/memo.js
function fromString(memo) {
  let length = stringLengthInBytes(memo);
  if (length > 32)
    throw Error("Memo.fromString: string too long");
  return `${String.fromCharCode(length)}${memo}` + "\0".repeat(32 - length);
}
function toString(memo) {
  let totalLength = stringLengthInBytes(memo);
  if (totalLength !== 34) {
    throw Error(`Memo.toString: length ${totalLength} does not equal 34`);
  }
  if (memo[0] !== "") {
    throw Error("Memo.toString: expected memo to start with 0x01 byte");
  }
  let length = memo.charCodeAt(1);
  if (length > 32)
    throw Error("Memo.toString: invalid length encoding");
  let bytes = stringToBytes(memo).slice(2, 2 + length);
  return stringFromBytes(bytes);
}
function hash2(memo) {
  let bits2 = Memo.toBits(memo);
  let fields = packToFieldsLegacy(HashInputLegacy.bits(bits2));
  return hashWithPrefix2(prefixes.zkappMemo, fields);
}
var SIZE = 34;
var Binable = defineBinable({
  toBytes(memo) {
    return stringToBytes(memo);
  },
  readBytes(bytes, start) {
    let end = start + SIZE;
    let memo = stringFromBytes(bytes.slice(start, end));
    return [memo, end];
  }
});
var Memo = {
  fromString,
  toString,
  hash: hash2,
  ...withBits(Binable, SIZE * 8),
  ...base58(Binable, versionBytes.userCommandMemo),
  sizeInBytes: SIZE,
  empty() {
    return Memo.fromString("");
  },
  toValidString(memo = "") {
    if (stringLengthInBytes(memo) > 32)
      throw Error("Memo: string too long");
    return memo;
  }
};

// dist/node/mina-signer/src/sign-zkapp-command.js
function verifyAccountUpdateSignature(update, transactionCommitments2, networkId) {
  if (update.authorization.signature === void 0)
    return false;
  let { publicKey, useFullCommitment } = update.body;
  let { commitment, fullCommitment } = transactionCommitments2;
  let usedCommitment = useFullCommitment === 1n ? fullCommitment : commitment;
  let signature = Signature.fromBase58(update.authorization.signature);
  return verifyFieldElement(signature, usedCommitment, publicKey, networkId);
}
function transactionCommitments(zkappCommand) {
  if (!isCallDepthValid(zkappCommand)) {
    throw Error("zkapp command: invalid call depth");
  }
  let callForest = accountUpdatesToCallForest(zkappCommand.accountUpdates);
  let commitment = callForestHash(callForest);
  let memoHash = Memo.hash(Memo.fromBase58(zkappCommand.memo));
  let feePayerDigest = feePayerHash(zkappCommand.feePayer);
  let fullCommitment = hashWithPrefix2(prefixes.accountUpdateCons, [
    memoHash,
    feePayerDigest,
    commitment
  ]);
  return { commitment, fullCommitment };
}
function accountUpdatesToCallForest(updates, callDepth = 0) {
  let remainingUpdates = callDepth > 0 ? updates : [...updates];
  let forest = [];
  while (remainingUpdates.length > 0) {
    let accountUpdate = remainingUpdates[0];
    if (accountUpdate.body.callDepth < callDepth)
      return forest;
    remainingUpdates.shift();
    let children = accountUpdatesToCallForest(remainingUpdates, callDepth + 1);
    forest.push({ accountUpdate, children });
  }
  return forest;
}
function accountUpdateHash(update) {
  assertAuthorizationKindValid(update);
  let input = AccountUpdate2.toInput(update);
  let fields = packToFields2(input);
  return hashWithPrefix2(prefixes.body, fields);
}
function callForestHash(forest) {
  let stackHash = 0n;
  for (let callTree of [...forest].reverse()) {
    let calls = callForestHash(callTree.children);
    let treeHash = accountUpdateHash(callTree.accountUpdate);
    let nodeHash = hashWithPrefix2(prefixes.accountUpdateNode, [
      treeHash,
      calls
    ]);
    stackHash = hashWithPrefix2(prefixes.accountUpdateCons, [
      nodeHash,
      stackHash
    ]);
  }
  return stackHash;
}
function feePayerHash(feePayer) {
  let accountUpdate = accountUpdateFromFeePayer(feePayer);
  return accountUpdateHash(accountUpdate);
}
function accountUpdateFromFeePayer({ body: { fee, nonce, publicKey, validUntil }, authorization: signature }) {
  let { body } = AccountUpdate2.empty();
  body.publicKey = publicKey;
  body.balanceChange = { magnitude: fee, sgn: Sign(-1) };
  body.incrementNonce = Bool(true);
  body.preconditions.network.globalSlotSinceGenesis = {
    isSome: Bool(true),
    value: { lower: UInt32(0), upper: validUntil ?? UInt32.maxValue }
  };
  body.preconditions.account.nonce = {
    isSome: Bool(true),
    value: { lower: nonce, upper: nonce }
  };
  body.useFullCommitment = Bool(true);
  body.implicitAccountCreationFee = Bool(true);
  body.authorizationKind = {
    isProved: Bool(false),
    isSigned: Bool(true),
    verificationKeyHash: Field(mocks.dummyVerificationKeyHash)
  };
  return { body, authorization: { signature } };
}
function isCallDepthValid(zkappCommand) {
  let callDepths = zkappCommand.accountUpdates.map((a2) => a2.body.callDepth);
  let current = callDepths.shift() ?? 0;
  if (current !== 0)
    return false;
  for (let callDepth of callDepths) {
    if (callDepth < 0)
      return false;
    if (callDepth - current > 1)
      return false;
    current = callDepth;
  }
  return true;
}
function assertAuthorizationKindValid(accountUpdate) {
  let { isSigned, isProved, verificationKeyHash } = accountUpdate.body.authorizationKind;
  if (isProved && isSigned)
    throw Error("Invalid authorization kind: Only one of `isProved` and `isSigned` may be true.");
  if (!isProved && verificationKeyHash !== Field(mocks.dummyVerificationKeyHash))
    throw Error(`Invalid authorization kind: If \`isProved\` is false, verification key hash must be ${mocks.dummyVerificationKeyHash}, got ${verificationKeyHash}`);
}

// dist/node/lib/account_update.js
var ZkappStateLength = 8;
var smartContractContext = Context.create({
  default: null
});
var zkAppProver = Prover();
var True = () => Bool4(true);
var False = () => Bool4(false);
var Permission = {
  /**
   * Modification is impossible.
   */
  impossible: () => ({
    constant: True(),
    signatureNecessary: True(),
    signatureSufficient: False()
  }),
  /**
   * Modification is always permitted
   */
  none: () => ({
    constant: True(),
    signatureNecessary: False(),
    signatureSufficient: True()
  }),
  /**
   * Modification is permitted by zkapp proofs only
   */
  proof: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: False()
  }),
  /**
   * Modification is permitted by signatures only, using the private key of the zkapp account
   */
  signature: () => ({
    constant: False(),
    signatureNecessary: True(),
    signatureSufficient: True()
  }),
  /**
   * Modification is permitted by zkapp proofs or signatures
   */
  proofOrSignature: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: True()
  })
};
var Permissions = {
  ...Permission,
  /**
   * Default permissions are:
   *
   *   {@link Permissions.editState} = {@link Permission.proof}
   *
   *   {@link Permissions.send} = {@link Permission.signature}
   *
   *   {@link Permissions.receive} = {@link Permission.none}
   *
   *   {@link Permissions.setDelegate} = {@link Permission.signature}
   *
   *   {@link Permissions.setPermissions} = {@link Permission.signature}
   *
   *   {@link Permissions.setVerificationKey} = {@link Permission.signature}
   *
   *   {@link Permissions.setZkappUri} = {@link Permission.signature}
   *
   *   {@link Permissions.editActionState} = {@link Permission.proof}
   *
   *   {@link Permissions.setTokenSymbol} = {@link Permission.signature}
   *
   */
  default: () => ({
    editState: Permission.proof(),
    send: Permission.proof(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.signature(),
    setZkappUri: Permission.signature(),
    editActionState: Permission.proof(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature(),
    setTiming: Permission.signature(),
    access: Permission.none()
  }),
  initial: () => ({
    editState: Permission.signature(),
    send: Permission.signature(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.signature(),
    setZkappUri: Permission.signature(),
    editActionState: Permission.signature(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature(),
    setTiming: Permission.signature(),
    access: Permission.none()
  }),
  dummy: () => ({
    editState: Permission.none(),
    send: Permission.none(),
    receive: Permission.none(),
    access: Permission.none(),
    setDelegate: Permission.none(),
    setPermissions: Permission.none(),
    setVerificationKey: Permission.none(),
    setZkappUri: Permission.none(),
    editActionState: Permission.none(),
    setTokenSymbol: Permission.none(),
    incrementNonce: Permission.none(),
    setVotingFor: Permission.none(),
    setTiming: Permission.none()
  }),
  allImpossible: () => ({
    editState: Permission.impossible(),
    send: Permission.impossible(),
    receive: Permission.impossible(),
    access: Permission.impossible(),
    setDelegate: Permission.impossible(),
    setPermissions: Permission.impossible(),
    setVerificationKey: Permission.impossible(),
    setZkappUri: Permission.impossible(),
    editActionState: Permission.impossible(),
    setTokenSymbol: Permission.impossible(),
    incrementNonce: Permission.impossible(),
    setVotingFor: Permission.impossible(),
    setTiming: Permission.impossible()
  }),
  fromString: (permission) => {
    switch (permission) {
      case "None":
        return Permission.none();
      case "Either":
        return Permission.proofOrSignature();
      case "Proof":
        return Permission.proof();
      case "Signature":
        return Permission.signature();
      case "Impossible":
        return Permission.impossible();
      default:
        throw Error(`Cannot parse invalid permission. ${permission} does not exist.`);
    }
  },
  fromJSON: (permissions) => {
    return Object.fromEntries(Object.entries(permissions).map(([k, v]) => [
      k,
      Permissions.fromString(v)
    ]));
  }
};
var Body = {
  /**
   * A body that doesn't change the underlying account record
   */
  keepAll(publicKey, tokenId, mayUseToken) {
    let { body } = transaction_exports.AccountUpdate.empty();
    body.publicKey = publicKey;
    if (tokenId) {
      body.tokenId = tokenId;
      body.mayUseToken = Provable.if(tokenId.equals(TokenId4.default), AccountUpdate3.MayUseToken.type, AccountUpdate3.MayUseToken.No, AccountUpdate3.MayUseToken.ParentsOwnToken);
    }
    if (mayUseToken) {
      body.mayUseToken = mayUseToken;
    }
    return body;
  },
  dummy() {
    return transaction_exports.AccountUpdate.empty().body;
  }
};
var FeePayerBody = {
  keepAll(publicKey, nonce) {
    return {
      publicKey,
      nonce,
      fee: UInt642.zero,
      validUntil: void 0
    };
  }
};
var NetworkPrecondition = {
  ignoreAll() {
    let stakingEpochData = {
      ledger: { hash: ignore(Field4(0)), totalCurrency: ignore(uint64()) },
      seed: ignore(Field4(0)),
      startCheckpoint: ignore(Field4(0)),
      lockCheckpoint: ignore(Field4(0)),
      epochLength: ignore(uint32())
    };
    let nextEpochData = cloneCircuitValue(stakingEpochData);
    return {
      snarkedLedgerHash: ignore(Field4(0)),
      blockchainLength: ignore(uint32()),
      minWindowDensity: ignore(uint32()),
      totalCurrency: ignore(uint64()),
      globalSlotSinceGenesis: ignore(uint32()),
      stakingEpochData,
      nextEpochData
    };
  }
};
function ignore(dummy) {
  return { isSome: Bool4(false), value: dummy };
}
var uint32 = () => ({ lower: UInt322.from(0), upper: UInt322.MAXINT() });
var uint64 = () => ({ lower: UInt642.from(0), upper: UInt642.MAXINT() });
var AccountPrecondition = {
  ignoreAll() {
    let appState = [];
    for (let i2 = 0; i2 < ZkappStateLength; ++i2) {
      appState.push(ignore(Field4(0)));
    }
    return {
      balance: ignore(uint64()),
      nonce: ignore(uint32()),
      receiptChainHash: ignore(Field4(0)),
      delegate: ignore(PublicKey2.empty()),
      state: appState,
      actionState: ignore(Actions.emptyActionState()),
      provedState: ignore(Bool4(false)),
      isNew: ignore(Bool4(false))
    };
  },
  nonce(nonce) {
    let p3 = AccountPrecondition.ignoreAll();
    AccountUpdate3.assertEquals(p3.nonce, nonce);
    return p3;
  }
};
var GlobalSlotPrecondition = {
  ignoreAll() {
    return ignore(uint32());
  }
};
var Preconditions = {
  ignoreAll() {
    return {
      account: AccountPrecondition.ignoreAll(),
      network: NetworkPrecondition.ignoreAll(),
      validWhile: GlobalSlotPrecondition.ignoreAll()
    };
  }
};
var AccountId = provable({ tokenOwner: PublicKey2, parentTokenId: Field4 });
var TokenId4 = {
  ...transaction_exports.TokenId,
  ...TokenId3,
  get default() {
    return Field4(1);
  },
  derive(tokenOwner, parentTokenId = Field4(1)) {
    let input = AccountId.toInput({ tokenOwner, parentTokenId });
    return hashWithPrefix(prefixes.deriveTokenId, packToFields(input));
  }
};
var Token = class {
  static getId(tokenOwner, parentTokenId = TokenId4.default) {
    return TokenId4.derive(tokenOwner, parentTokenId);
  }
  constructor({ tokenOwner, parentTokenId = TokenId4.default }) {
    this.parentTokenId = parentTokenId;
    this.tokenOwner = tokenOwner;
    try {
      this.id = TokenId4.derive(tokenOwner, parentTokenId);
    } catch (e) {
      throw new Error(`Could not create a custom token id:
Error: ${e.message}`);
    }
  }
};
Token.Id = TokenId4;
var AccountUpdate3 = class _AccountUpdate {
  constructor(body, authorization = {}, isSelf = false) {
    this.label = "";
    this.lazyAuthorization = void 0;
    this.children = {
      callsType: { type: "None" },
      accountUpdates: []
    };
    this.parent = void 0;
    this.id = Math.random();
    this.body = body;
    this.authorization = authorization;
    let { account, network, currentSlot: currentSlot2 } = preconditions(this, isSelf);
    this.account = account;
    this.network = network;
    this.currentSlot = currentSlot2;
    this.isSelf = isSelf;
  }
  /**
   * Clones the {@link AccountUpdate}.
   */
  static clone(accountUpdate) {
    let body = cloneCircuitValue(accountUpdate.body);
    let authorization = cloneCircuitValue(accountUpdate.authorization);
    let cloned = new _AccountUpdate(body, authorization, accountUpdate.isSelf);
    cloned.lazyAuthorization = accountUpdate.lazyAuthorization;
    cloned.children.callsType = accountUpdate.children.callsType;
    cloned.children.accountUpdates = accountUpdate.children.accountUpdates.map(_AccountUpdate.clone);
    cloned.id = accountUpdate.id;
    cloned.label = accountUpdate.label;
    cloned.parent = accountUpdate.parent;
    return cloned;
  }
  token() {
    let thisAccountUpdate = this;
    let tokenOwner = this.publicKey;
    let parentTokenId = this.tokenId;
    let id = TokenId4.derive(tokenOwner, parentTokenId);
    function getApprovedAccountUpdate(accountLike, label) {
      if (accountLike instanceof SmartContract) {
        accountLike = accountLike.self;
      }
      if (accountLike instanceof _AccountUpdate) {
        accountLike.tokenId.assertEquals(id);
        thisAccountUpdate.approve(accountLike);
      }
      if (accountLike instanceof PublicKey2) {
        accountLike = _AccountUpdate.defaultAccountUpdate(accountLike, id);
        makeChildAccountUpdate(thisAccountUpdate, accountLike);
      }
      if (!accountLike.label)
        accountLike.label = `${thisAccountUpdate.label ?? "Unlabeled"}.${label}`;
      return accountLike;
    }
    return {
      id,
      parentTokenId,
      tokenOwner,
      /**
       * Mints token balance to `address`. Returns the mint account update.
       */
      mint({ address, amount }) {
        let receiver = getApprovedAccountUpdate(address, "token.mint()");
        receiver.balance.addInPlace(amount);
        return receiver;
      },
      /**
       * Burn token balance on `address`. Returns the burn account update.
       */
      burn({ address, amount }) {
        let sender2 = getApprovedAccountUpdate(address, "token.burn()");
        sender2.balance.subInPlace(amount);
        sender2.body.useFullCommitment = Bool4(true);
        Authorization.setLazySignature(sender2);
        return sender2;
      },
      /**
       * Move token balance from `from` to `to`. Returns the `to` account update.
       */
      send({ from, to, amount }) {
        let sender2 = getApprovedAccountUpdate(from, "token.send() (sender)");
        sender2.balance.subInPlace(amount);
        sender2.body.useFullCommitment = Bool4(true);
        Authorization.setLazySignature(sender2);
        let receiver = getApprovedAccountUpdate(to, "token.send() (receiver)");
        receiver.balance.addInPlace(amount);
        return receiver;
      }
    };
  }
  get tokenId() {
    return this.body.tokenId;
  }
  /**
   * @deprecated use `this.account.tokenSymbol`
   */
  get tokenSymbol() {
    let accountUpdate = this;
    return {
      set(tokenSymbol) {
        accountUpdate.account.tokenSymbol.set(tokenSymbol);
      }
    };
  }
  send({ to, amount }) {
    let receiver;
    if (to instanceof _AccountUpdate) {
      receiver = to;
      receiver.body.tokenId.assertEquals(this.body.tokenId);
    } else if (to instanceof SmartContract) {
      receiver = to.self;
      receiver.body.tokenId.assertEquals(this.body.tokenId);
    } else {
      receiver = _AccountUpdate.defaultAccountUpdate(to, this.body.tokenId);
      receiver.label = `${this.label ?? "Unlabeled"}.send()`;
      this.approve(receiver);
    }
    this.body.balanceChange = Int64.fromObject(this.body.balanceChange).sub(amount);
    receiver.body.balanceChange = Int64.fromObject(receiver.body.balanceChange).add(amount);
    return receiver;
  }
  /**
   * Makes an {@link AccountUpdate} a child-{@link AccountUpdate} of this and
   * approves it.
   */
  approve(childUpdate, layout = _AccountUpdate.Layout.NoChildren) {
    makeChildAccountUpdate(this, childUpdate);
    _AccountUpdate.witnessChildren(childUpdate, layout, { skipCheck: true });
  }
  get balance() {
    let accountUpdate = this;
    return {
      addInPlace(x) {
        let { magnitude, sgn } = accountUpdate.body.balanceChange;
        accountUpdate.body.balanceChange = new Int64(magnitude, sgn).add(x);
      },
      subInPlace(x) {
        let { magnitude, sgn } = accountUpdate.body.balanceChange;
        accountUpdate.body.balanceChange = new Int64(magnitude, sgn).sub(x);
      }
    };
  }
  get update() {
    return this.body.update;
  }
  static setValue(maybeValue, value) {
    maybeValue.isSome = Bool4(true);
    maybeValue.value = value;
  }
  /**
   * Constrain a property to lie between lower and upper bounds.
   *
   * @param property The property to constrain
   * @param lower The lower bound
   * @param upper The upper bound
   *
   * Example: To constrain the account balance of a SmartContract to lie between
   * 0 and 20 MINA, you can use
   *
   * ```ts
   * \@method onlyRunsWhenBalanceIsLow() {
   *   let lower = UInt64.zero;
   *   let upper = UInt64.from(20e9);
   *   AccountUpdate.assertBetween(this.self.body.preconditions.account.balance, lower, upper);
   *   // ...
   * }
   * ```
   */
  static assertBetween(property, lower, upper) {
    property.isSome = Bool4(true);
    property.value.lower = lower;
    property.value.upper = upper;
  }
  // TODO: assertGreaterThan, assertLowerThan?
  /**
   * Fix a property to a certain value.
   *
   * @param property The property to constrain
   * @param value The value it is fixed to
   *
   * Example: To fix the account nonce of a SmartContract to 0, you can use
   *
   * ```ts
   * \@method onlyRunsWhenNonceIsZero() {
   *   AccountUpdate.assertEquals(this.self.body.preconditions.account.nonce, UInt32.zero);
   *   // ...
   * }
   * ```
   */
  static assertEquals(property, value) {
    property.isSome = Bool4(true);
    if ("lower" in property.value && "upper" in property.value) {
      property.value.lower = value;
      property.value.upper = value;
    } else {
      property.value = value;
    }
  }
  get publicKey() {
    return this.body.publicKey;
  }
  /**
   * Use this command if this account update should be signed by the account
   * owner, instead of not having any authorization.
   *
   * If you use this and are not relying on a wallet to sign your transaction,
   * then you should use the following code before sending your transaction:
   *
   * ```ts
   * let tx = Mina.transaction(...); // create transaction as usual, using `requireSignature()` somewhere
   * tx.sign([privateKey]); // pass the private key of this account to `sign()`!
   * ```
   *
   * Note that an account's {@link Permissions} determine which updates have to
   * be (can be) authorized by a signature.
   */
  requireSignature() {
    this.sign();
  }
  /**
   * @deprecated `.sign()` is deprecated in favor of `.requireSignature()`
   */
  sign(privateKey) {
    let { nonce, isSameAsFeePayer } = _AccountUpdate.getSigningInfo(this);
    this.body.useFullCommitment = isSameAsFeePayer;
    this.body.implicitAccountCreationFee = Bool4(false);
    let doIncrementNonce = isSameAsFeePayer.not();
    this.body.incrementNonce = doIncrementNonce;
    let lower = Provable.if(doIncrementNonce, UInt322, nonce, UInt322.zero);
    let upper = Provable.if(doIncrementNonce, UInt322, nonce, UInt322.MAXINT());
    this.body.preconditions.account.nonce.isSome = doIncrementNonce;
    this.body.preconditions.account.nonce.value.lower = lower;
    this.body.preconditions.account.nonce.value.upper = upper;
    Authorization.setLazySignature(this, { privateKey });
  }
  static signFeePayerInPlace(feePayer, privateKey) {
    feePayer.body.nonce = this.getNonce(feePayer);
    feePayer.authorization = dummySignature();
    feePayer.lazyAuthorization = { kind: "lazy-signature", privateKey };
  }
  static getNonce(accountUpdate) {
    return _AccountUpdate.getSigningInfo(accountUpdate).nonce;
  }
  static getSigningInfo(accountUpdate) {
    return memoizeWitness(_AccountUpdate.signingInfo, () => _AccountUpdate.getSigningInfoUnchecked(accountUpdate));
  }
  static getSigningInfoUnchecked(update) {
    let publicKey = update.body.publicKey;
    let tokenId = update instanceof _AccountUpdate ? update.body.tokenId : TokenId4.default;
    let nonce = Number(getAccountPreconditions(update.body).nonce.toString());
    let isFeePayer = currentTransaction()?.sender?.equals(publicKey);
    let isSameAsFeePayer = !!isFeePayer?.and(tokenId.equals(TokenId4.default)).toBoolean();
    if (isSameAsFeePayer)
      nonce++;
    CallForest.forEachPredecessor(currentTransaction.get().accountUpdates, update, (otherUpdate) => {
      let shouldIncreaseNonce = otherUpdate.publicKey.equals(publicKey).and(otherUpdate.tokenId.equals(tokenId)).and(otherUpdate.body.incrementNonce);
      if (shouldIncreaseNonce.toBoolean())
        nonce++;
    });
    return {
      nonce: UInt322.from(nonce),
      isSameAsFeePayer: Bool4(isSameAsFeePayer)
    };
  }
  toJSON() {
    return transaction_exports.AccountUpdate.toJSON(this);
  }
  static toJSON(a2) {
    return transaction_exports.AccountUpdate.toJSON(a2);
  }
  static fromJSON(json) {
    let accountUpdate = transaction_exports.AccountUpdate.fromJSON(json);
    return new _AccountUpdate(accountUpdate.body, accountUpdate.authorization);
  }
  hash() {
    if (Provable.inCheckedComputation()) {
      let input = transaction_exports.AccountUpdate.toInput(this);
      return hashWithPrefix(prefixes.body, packToFields(input));
    } else {
      let json = transaction_exports.AccountUpdate.toJSON(this);
      return Field4(Test.hashFromJson.accountUpdate(JSON.stringify(json)));
    }
  }
  toPublicInput() {
    let accountUpdate = this.hash();
    let calls = CallForest.hashChildren(this);
    return { accountUpdate, calls };
  }
  toPrettyLayout() {
    let indent = 0;
    let layout = "";
    let i2 = 0;
    let print = (a2) => {
      layout += " ".repeat(indent) + `AccountUpdate(${i2}, ${a2.label || "<no label>"}, ${a2.children.callsType.type})
`;
      i2++;
      indent += 2;
      for (let child of a2.children.accountUpdates) {
        print(child);
      }
      indent -= 2;
    };
    print(this);
    return layout;
  }
  static defaultAccountUpdate(address, tokenId) {
    return new _AccountUpdate(Body.keepAll(address, tokenId));
  }
  static dummy() {
    let dummy = new _AccountUpdate(Body.dummy());
    dummy.label = "Dummy";
    return dummy;
  }
  isDummy() {
    return this.body.publicKey.isEmpty();
  }
  static defaultFeePayer(address, nonce) {
    let body = FeePayerBody.keepAll(address, nonce);
    return {
      body,
      authorization: dummySignature(),
      lazyAuthorization: { kind: "lazy-signature" }
    };
  }
  static dummyFeePayer() {
    let body = FeePayerBody.keepAll(PublicKey2.empty(), UInt322.zero);
    return { body, authorization: dummySignature() };
  }
  /**
   * Creates an account update. If this is inside a transaction, the account
   * update becomes part of the transaction. If this is inside a smart contract
   * method, the account update will not only become part of the transaction,
   * but also becomes available for the smart contract to modify, in a way that
   * becomes part of the proof.
   */
  static create(publicKey, tokenId) {
    let accountUpdate = _AccountUpdate.defaultAccountUpdate(publicKey, tokenId);
    let insideContract = smartContractContext.get();
    if (insideContract) {
      let self = insideContract.this.self;
      self.approve(accountUpdate);
      accountUpdate.label = `${self.label || "Unlabeled"} > AccountUpdate.create()`;
    } else {
      currentTransaction()?.accountUpdates.push(accountUpdate);
      accountUpdate.label = `Mina.transaction > AccountUpdate.create()`;
    }
    return accountUpdate;
  }
  /**
   * Attach account update to the current transaction
   * -- if in a smart contract, to its children
   */
  static attachToTransaction(accountUpdate) {
    let insideContract = smartContractContext.get();
    if (insideContract) {
      let selfUpdate = insideContract.this.self;
      if (selfUpdate === accountUpdate)
        return;
      insideContract.this.self.approve(accountUpdate);
    } else {
      if (!currentTransaction.has())
        return;
      let updates = currentTransaction.get().accountUpdates;
      if (!updates.find((update) => update.id === accountUpdate.id)) {
        updates.push(accountUpdate);
      }
    }
  }
  /**
   * Disattach an account update from where it's currently located in the transaction
   */
  static unlink(accountUpdate) {
    let siblings = accountUpdate.parent?.children.accountUpdates ?? currentTransaction()?.accountUpdates;
    if (siblings === void 0)
      return;
    let i2 = siblings?.findIndex((update) => update.id === accountUpdate.id);
    if (i2 !== void 0 && i2 !== -1) {
      siblings.splice(i2, 1);
    }
    accountUpdate.parent === void 0;
  }
  static createSigned(signer, tokenId) {
    let publicKey = signer instanceof PrivateKey2 ? signer.toPublicKey() : signer;
    let accountUpdate = _AccountUpdate.create(publicKey, tokenId);
    accountUpdate.label = accountUpdate.label.replace(".create()", ".createSigned()");
    if (signer instanceof PrivateKey2) {
      accountUpdate.sign(signer);
    } else {
      accountUpdate.requireSignature();
    }
    return accountUpdate;
  }
  static fundNewAccount(feePayer, numberOfAccounts) {
    let accountUpdate = _AccountUpdate.createSigned(feePayer);
    accountUpdate.label = "AccountUpdate.fundNewAccount()";
    let fee = getNetworkConstants().accountCreationFee;
    numberOfAccounts ??= 1;
    if (typeof numberOfAccounts === "number")
      fee = fee.mul(numberOfAccounts);
    else
      fee = fee.add(UInt642.from(numberOfAccounts.initialBalance ?? 0));
    accountUpdate.balance.subInPlace(fee);
    return accountUpdate;
  }
  static toAuxiliary(a2) {
    let aux = transaction_exports.AccountUpdate.toAuxiliary(a2);
    let children = {
      callsType: { type: "None" },
      accountUpdates: []
    };
    let lazyAuthorization = a2 && a2.lazyAuthorization;
    if (a2) {
      children.callsType = a2.children.callsType;
      children.accountUpdates = a2.children.accountUpdates.map(_AccountUpdate.clone);
    }
    let parent = a2?.parent;
    let id = a2?.id ?? Math.random();
    let label = a2?.label ?? "";
    return [{ lazyAuthorization, children, parent, id, label }, aux];
  }
  static empty() {
    return _AccountUpdate.dummy();
  }
  static fromFields(fields, [other, aux]) {
    let accountUpdate = transaction_exports.AccountUpdate.fromFields(fields, aux);
    return Object.assign(new _AccountUpdate(accountUpdate.body, accountUpdate.authorization), other);
  }
  static witness(type, compute, { skipCheck = false } = {}) {
    let accountUpdateType = skipCheck ? { ...provable(_AccountUpdate), check() {
    } } : _AccountUpdate;
    let combinedType = provable({
      accountUpdate: accountUpdateType,
      result: type
    });
    return Provable.witness(combinedType, compute);
  }
  static witnessChildren(accountUpdate, childLayout, options) {
    if (childLayout === _AccountUpdate.Layout.AnyChildren) {
      accountUpdate.children.callsType = { type: "Witness" };
      return;
    }
    if (childLayout === _AccountUpdate.Layout.NoDelegation) {
      accountUpdate.children.callsType = { type: "Witness" };
      accountUpdate.body.mayUseToken.parentsOwnToken.assertFalse();
      accountUpdate.body.mayUseToken.inheritFromParent.assertFalse();
      return;
    }
    accountUpdate.children.callsType = { type: "None" };
    let childArray = typeof childLayout === "number" ? Array(childLayout).fill(_AccountUpdate.Layout.NoChildren) : childLayout;
    let n = childArray.length;
    for (let i2 = 0; i2 < n; i2++) {
      accountUpdate.children.accountUpdates[i2] = _AccountUpdate.witnessTree(provable(null), childArray[i2], () => ({
        accountUpdate: accountUpdate.children.accountUpdates[i2] ?? _AccountUpdate.dummy(),
        result: null
      }), options).accountUpdate;
    }
    if (n === 0) {
      accountUpdate.children.callsType = {
        type: "Equals",
        value: CallForest.emptyHash()
      };
    }
  }
  /**
   * Like AccountUpdate.witness, but lets you specify a layout for the
   * accountUpdate's children, which also get witnessed
   */
  static witnessTree(resultType, childLayout, compute, options) {
    let { accountUpdate, result } = _AccountUpdate.witness(resultType, compute, options);
    _AccountUpdate.witnessChildren(accountUpdate, childLayout, options);
    return { accountUpdate, result };
  }
  static get MayUseToken() {
    return {
      type: provablePure({ parentsOwnToken: Bool4, inheritFromParent: Bool4 }),
      No: { parentsOwnToken: Bool4(false), inheritFromParent: Bool4(false) },
      ParentsOwnToken: {
        parentsOwnToken: Bool4(true),
        inheritFromParent: Bool4(false)
      },
      InheritFromParent: {
        parentsOwnToken: Bool4(false),
        inheritFromParent: Bool4(true)
      },
      isNo({ body: { mayUseToken: { parentsOwnToken, inheritFromParent } } }) {
        return parentsOwnToken.or(inheritFromParent).not();
      },
      isParentsOwnToken(a2) {
        return a2.body.mayUseToken.parentsOwnToken;
      },
      isInheritFromParent(a2) {
        return a2.body.mayUseToken.inheritFromParent;
      }
    };
  }
  /**
   * Returns a JSON representation of only the fields that differ from the
   * default {@link AccountUpdate}.
   */
  toPretty() {
    function short(s) {
      return ".." + s.slice(-4);
    }
    let jsonUpdate = toJSONEssential(jsLayout.AccountUpdate, this);
    let body = jsonUpdate.body;
    delete body.callData;
    body.publicKey = short(body.publicKey);
    if (body.balanceChange?.magnitude === "0")
      delete body.balanceChange;
    if (body.tokenId === TokenId4.toBase58(TokenId4.default)) {
      delete body.tokenId;
    } else {
      body.tokenId = short(body.tokenId);
    }
    if (body.callDepth === 0)
      delete body.callDepth;
    if (body.incrementNonce === false)
      delete body.incrementNonce;
    if (body.useFullCommitment === false)
      delete body.useFullCommitment;
    if (body.implicitAccountCreationFee === false)
      delete body.implicitAccountCreationFee;
    if (body.events?.length === 0)
      delete body.events;
    if (body.actions?.length === 0)
      delete body.actions;
    if (body.preconditions?.account) {
      body.preconditions.account = JSON.stringify(body.preconditions.account);
    }
    if (body.preconditions?.network) {
      body.preconditions.network = JSON.stringify(body.preconditions.network);
    }
    if (body.preconditions?.validWhile) {
      body.preconditions.validWhile = JSON.stringify(body.preconditions.validWhile);
    }
    if (jsonUpdate.authorization?.proof) {
      jsonUpdate.authorization.proof = short(jsonUpdate.authorization.proof);
    }
    if (jsonUpdate.authorization?.signature) {
      jsonUpdate.authorization.signature = short(jsonUpdate.authorization.signature);
    }
    if (body.update?.verificationKey) {
      body.update.verificationKey = JSON.stringify({
        data: short(body.update.verificationKey.data),
        hash: short(body.update.verificationKey.hash)
      });
    }
    for (let key of ["permissions", "appState", "timing"]) {
      if (body.update?.[key]) {
        body.update[key] = JSON.stringify(body.update[key]);
      }
    }
    for (let key of ["events", "actions"]) {
      if (body[key]) {
        body[key] = JSON.stringify(body[key]);
      }
    }
    if (body.authorizationKind?.isProved === false) {
      delete body.authorizationKind?.verificationKeyHash;
    }
    if (body.authorizationKind?.isProved === false && body.authorizationKind?.isSigned === false) {
      delete body.authorizationKind;
    }
    if (jsonUpdate.authorization !== void 0 || body.authorizationKind?.isProved === true || body.authorizationKind?.isSigned === true) {
      body.authorization = jsonUpdate.authorization;
    }
    body.mayUseToken = {
      parentsOwnToken: this.body.mayUseToken.parentsOwnToken.toBoolean(),
      inheritFromParent: this.body.mayUseToken.inheritFromParent.toBoolean()
    };
    let pretty = { ...body };
    let withId = false;
    if (withId)
      pretty = { id: Math.floor(this.id * 1e3), ...pretty };
    if (this.label)
      pretty = { label: this.label, ...pretty };
    return pretty;
  }
};
AccountUpdate3.Actions = Actions;
AccountUpdate3.signingInfo = provable({
  isSameAsFeePayer: Bool4,
  nonce: UInt322
});
AccountUpdate3.sizeInFields = transaction_exports.AccountUpdate.sizeInFields;
AccountUpdate3.toFields = transaction_exports.AccountUpdate.toFields;
AccountUpdate3.toInput = transaction_exports.AccountUpdate.toInput;
AccountUpdate3.check = transaction_exports.AccountUpdate.check;
AccountUpdate3.Layout = {
  StaticChildren: (...args) => {
    if (args.length === 1 && typeof args[0] === "number")
      return args[0];
    if (args.length === 0)
      return 0;
    return args;
  },
  NoChildren: 0,
  AnyChildren: "AnyChildren",
  NoDelegation: "NoDelegation"
};
var CallForest = {
  // similar to Mina_base.ZkappCommand.Call_forest.to_account_updates_list
  // takes a list of accountUpdates, which each can have children, so they form a "forest" (list of trees)
  // returns a flattened list, with `accountUpdate.body.callDepth` specifying positions in the forest
  // also removes any "dummy" accountUpdates
  toFlatList(forest, mutate = true, depth = 0) {
    let accountUpdates = [];
    for (let accountUpdate of forest) {
      if (accountUpdate.isDummy().toBoolean())
        continue;
      if (mutate)
        accountUpdate.body.callDepth = depth;
      let children = accountUpdate.children.accountUpdates;
      accountUpdates.push(accountUpdate, ...CallForest.toFlatList(children, mutate, depth + 1));
    }
    return accountUpdates;
  },
  // Mina_base.Zkapp_command.Digest.Forest.empty
  emptyHash() {
    return Field4(0);
  },
  // similar to Mina_base.Zkapp_command.Call_forest.accumulate_hashes
  // hashes a accountUpdate's children (and their children, and ...) to compute
  // the `calls` field of ZkappPublicInput
  hashChildren(update) {
    let { callsType } = update.children;
    if (callsType.type === "Witness") {
      return Provable.witness(Field4, () => CallForest.hashChildrenBase(update));
    }
    let calls = CallForest.hashChildrenBase(update);
    if (callsType.type === "Equals" && Provable.inCheckedComputation()) {
      calls.assertEquals(callsType.value);
    }
    return calls;
  },
  hashChildrenBase({ children }) {
    let stackHash = CallForest.emptyHash();
    for (let accountUpdate of [...children.accountUpdates].reverse()) {
      let calls = CallForest.hashChildren(accountUpdate);
      let nodeHash = hashWithPrefix(prefixes.accountUpdateNode, [
        accountUpdate.hash(),
        calls
      ]);
      let newHash = hashWithPrefix(prefixes.accountUpdateCons, [
        nodeHash,
        stackHash
      ]);
      stackHash = Provable.if(accountUpdate.isDummy(), stackHash, newHash);
    }
    return stackHash;
  },
  // Mina_base.Zkapp_command.Call_forest.add_callers
  // TODO: currently unused, but could come back when we add caller to the
  // public input
  addCallers(updates, context = {
    self: TokenId4.default,
    caller: TokenId4.default
  }) {
    let withCallers = [];
    for (let update of updates) {
      let { mayUseToken } = update.body;
      let caller = Provable.if(mayUseToken.parentsOwnToken, context.self, Provable.if(mayUseToken.inheritFromParent, context.caller, TokenId4.default));
      let self = TokenId4.derive(update.body.publicKey, update.body.tokenId);
      let childContext = { caller, self };
      withCallers.push({
        accountUpdate: update,
        caller,
        children: CallForest.addCallers(update.children.accountUpdates, childContext)
      });
    }
    return withCallers;
  },
  /**
   * Used in the prover to witness the context from which to compute its caller
   *
   * TODO: currently unused, but could come back when we add caller to the
   * public input
   */
  computeCallerContext(update) {
    let current = update;
    let ancestors = [];
    while (true) {
      let parent = current.parent;
      if (parent === void 0)
        break;
      ancestors.unshift(parent);
      current = parent;
    }
    let context = { self: TokenId4.default, caller: TokenId4.default };
    for (let update2 of ancestors) {
      if (update2.body.mayUseToken.parentsOwnToken.toBoolean()) {
        context.caller = context.self;
      } else if (!update2.body.mayUseToken.inheritFromParent.toBoolean()) {
        context.caller = TokenId4.default;
      }
      context.self = TokenId4.derive(update2.body.publicKey, update2.body.tokenId);
    }
    return context;
  },
  callerContextType: provablePure({ self: Field4, caller: Field4 }),
  computeCallDepth(update) {
    for (let callDepth = 0; ; callDepth++) {
      if (update.parent === void 0)
        return callDepth;
      update = update.parent;
    }
  },
  map(updates, map) {
    let newUpdates = [];
    for (let update of updates) {
      let newUpdate = map(update);
      newUpdate.children.accountUpdates = CallForest.map(update.children.accountUpdates, map);
      newUpdates.push(newUpdate);
    }
    return newUpdates;
  },
  forEach(updates, callback) {
    for (let update of updates) {
      callback(update);
      CallForest.forEach(update.children.accountUpdates, callback);
    }
  },
  forEachPredecessor(updates, update, callback) {
    let isPredecessor = true;
    CallForest.forEach(updates, (otherUpdate) => {
      if (otherUpdate.id === update.id)
        isPredecessor = false;
      if (isPredecessor)
        callback(otherUpdate);
    });
  }
};
function createChildAccountUpdate(parent, childAddress, tokenId) {
  let child = AccountUpdate3.defaultAccountUpdate(childAddress, tokenId);
  makeChildAccountUpdate(parent, child);
  return child;
}
function makeChildAccountUpdate(parent, child) {
  child.body.callDepth = parent.body.callDepth + 1;
  let wasChildAlready = parent.children.accountUpdates.find((update) => update.id === child.id);
  if (!wasChildAlready) {
    parent.children.accountUpdates.push(child);
    AccountUpdate3.unlink(child);
  }
  child.parent = parent;
}
var ZkappCommand3 = {
  toPretty(transaction2) {
    let feePayer = ZkappCommand3.toJSON(transaction2).feePayer;
    feePayer.body.publicKey = ".." + feePayer.body.publicKey.slice(-4);
    feePayer.body.authorization = ".." + feePayer.authorization.slice(-4);
    if (feePayer.body.validUntil === null)
      delete feePayer.body.validUntil;
    return [
      { label: "feePayer", ...feePayer.body },
      ...transaction2.accountUpdates.map((a2) => a2.toPretty())
    ];
  },
  fromJSON(json) {
    let { feePayer } = transaction_exports.ZkappCommand.fromJSON({
      feePayer: json.feePayer,
      accountUpdates: [],
      memo: json.memo
    });
    let memo = Memo.toString(Memo.fromBase58(json.memo));
    let accountUpdates = json.accountUpdates.map(AccountUpdate3.fromJSON);
    return { feePayer, accountUpdates, memo };
  },
  toJSON({ feePayer, accountUpdates, memo }) {
    memo = Memo.toBase58(Memo.fromString(memo));
    return transaction_exports.ZkappCommand.toJSON({ feePayer, accountUpdates, memo });
  }
};
var Authorization = {
  hasLazyProof(accountUpdate) {
    return accountUpdate.lazyAuthorization?.kind === "lazy-proof";
  },
  hasAny(accountUpdate) {
    let { authorization: auth, lazyAuthorization: lazyAuth } = accountUpdate;
    return !!(lazyAuth || "proof" in auth || "signature" in auth);
  },
  setSignature(accountUpdate, signature) {
    accountUpdate.authorization = { signature };
    accountUpdate.lazyAuthorization = void 0;
  },
  setProof(accountUpdate, proof) {
    accountUpdate.authorization = { proof };
    accountUpdate.lazyAuthorization = void 0;
    return accountUpdate;
  },
  setLazySignature(accountUpdate, signature) {
    signature ??= {};
    accountUpdate.body.authorizationKind.isSigned = Bool4(true);
    accountUpdate.body.authorizationKind.isProved = Bool4(false);
    accountUpdate.body.authorizationKind.verificationKeyHash = Field4(mocks.dummyVerificationKeyHash);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { ...signature, kind: "lazy-signature" };
  },
  setProofAuthorizationKind({ body, id }, priorAccountUpdates) {
    body.authorizationKind.isSigned = Bool4(false);
    body.authorizationKind.isProved = Bool4(true);
    let hash3 = Provable.witness(Field4, () => {
      let proverData = zkAppProver.getData();
      let isProver = proverData !== void 0;
      assert2(isProver || priorAccountUpdates !== void 0, "Called `setProofAuthorizationKind()` outside the prover without passing in `priorAccountUpdates`.");
      let myAccountUpdateId = isProver ? proverData.accountUpdate.id : id;
      priorAccountUpdates ??= proverData.transaction.accountUpdates;
      priorAccountUpdates = priorAccountUpdates.filter((a2) => a2.id !== myAccountUpdateId);
      let priorAccountUpdatesFlat = CallForest.toFlatList(priorAccountUpdates, false);
      let accountUpdate = [...priorAccountUpdatesFlat].reverse().find((body_) => body_.update.verificationKey.isSome.and(body_.tokenId.equals(body.tokenId)).and(body_.publicKey.equals(body.publicKey)).toBoolean());
      if (accountUpdate !== void 0) {
        return accountUpdate.body.update.verificationKey.value.hash;
      }
      try {
        let account = getAccount(body.publicKey, body.tokenId);
        return account.zkapp?.verificationKey?.hash ?? Field4(0);
      } catch {
        return Field4(0);
      }
    });
    body.authorizationKind.verificationKeyHash = hash3;
  },
  setLazyProof(accountUpdate, proof, priorAccountUpdates) {
    Authorization.setProofAuthorizationKind(accountUpdate, priorAccountUpdates);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { ...proof, kind: "lazy-proof" };
  },
  setLazyNone(accountUpdate) {
    accountUpdate.body.authorizationKind.isSigned = Bool4(false);
    accountUpdate.body.authorizationKind.isProved = Bool4(false);
    accountUpdate.body.authorizationKind.verificationKeyHash = Field4(mocks.dummyVerificationKeyHash);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { kind: "lazy-none" };
  }
};
function addMissingSignatures(zkappCommand, additionalKeys = []) {
  let additionalPublicKeys = additionalKeys.map((sk) => sk.toPublicKey());
  let { commitment, fullCommitment } = transactionCommitments(transaction_bigint_exports.ZkappCommand.fromJSON(ZkappCommand3.toJSON(zkappCommand)));
  function addFeePayerSignature(accountUpdate) {
    let { body, authorization, lazyAuthorization } = cloneCircuitValue(accountUpdate);
    if (lazyAuthorization === void 0)
      return { body, authorization };
    let { privateKey } = lazyAuthorization;
    if (privateKey === void 0) {
      let i2 = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
      if (i2 === -1) {
        return { body, authorization: dummySignature() };
      }
      privateKey = additionalKeys[i2];
    }
    let signature = signFieldElement(fullCommitment, privateKey.toBigInt(), getNetworkId());
    return { body, authorization: Signature.toBase58(signature) };
  }
  function addSignature(accountUpdate) {
    accountUpdate = AccountUpdate3.clone(accountUpdate);
    if (accountUpdate.lazyAuthorization?.kind !== "lazy-signature") {
      return accountUpdate;
    }
    let { privateKey } = accountUpdate.lazyAuthorization;
    if (privateKey === void 0) {
      let i2 = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
      if (i2 === -1) {
        Authorization.setSignature(accountUpdate, dummySignature());
        return accountUpdate;
      }
      privateKey = additionalKeys[i2];
    }
    let transactionCommitment = accountUpdate.body.useFullCommitment.toBoolean() ? fullCommitment : commitment;
    let signature = signFieldElement(transactionCommitment, privateKey.toBigInt(), getNetworkId());
    Authorization.setSignature(accountUpdate, Signature.toBase58(signature));
    return accountUpdate;
  }
  let { feePayer, accountUpdates, memo } = zkappCommand;
  return {
    feePayer: addFeePayerSignature(feePayer),
    accountUpdates: accountUpdates.map(addSignature),
    memo
  };
}
function dummySignature() {
  return Signature.toBase58(Signature.dummy());
}
var ZkappPublicInput = provablePure({ accountUpdate: Field4, calls: Field4 });
async function addMissingProofs(zkappCommand, { proofsEnabled = true }) {
  let { feePayer, accountUpdates, memo } = zkappCommand;
  let accountUpdatesProved = [];
  let proofs = [];
  for (let i2 = 0; i2 < accountUpdates.length; i2++) {
    let { accountUpdateProved, proof } = await addProof(zkappCommand, i2, proofsEnabled);
    accountUpdatesProved.push(accountUpdateProved);
    proofs.push(proof);
  }
  return {
    zkappCommand: { feePayer, accountUpdates: accountUpdatesProved, memo },
    proofs
  };
}
async function addProof(transaction2, index, proofsEnabled) {
  let accountUpdate = transaction2.accountUpdates[index];
  accountUpdate = AccountUpdate3.clone(accountUpdate);
  if (accountUpdate.lazyAuthorization?.kind !== "lazy-proof") {
    return {
      accountUpdateProved: accountUpdate,
      proof: void 0
    };
  }
  if (!proofsEnabled) {
    Authorization.setProof(accountUpdate, await dummyBase64Proof());
    return {
      accountUpdateProved: accountUpdate,
      proof: void 0
    };
  }
  let lazyProof = accountUpdate.lazyAuthorization;
  let prover = getZkappProver(lazyProof);
  let proverData = { transaction: transaction2, accountUpdate, index };
  let proof = await createZkappProof(prover, lazyProof, proverData);
  let accountUpdateProved = Authorization.setProof(accountUpdate, Pickles.proofToBase64Transaction(proof.proof));
  return { accountUpdateProved, proof };
}
async function createZkappProof(prover, { methodName, args, previousProofs, ZkappClass, memoized, blindingValue }, { transaction: transaction2, accountUpdate, index }) {
  let publicInput = accountUpdate.toPublicInput();
  let publicInputFields = MlFieldConstArray.to(ZkappPublicInput.toFields(publicInput));
  let [, , proof] = await zkAppProver.run([accountUpdate.publicKey, accountUpdate.tokenId, ...args], { transaction: transaction2, accountUpdate, index }, async () => {
    let id = memoizationContext.enter({
      memoized,
      currentIndex: 0,
      blindingValue
    });
    try {
      return await prover(publicInputFields, MlArray.to(previousProofs));
    } catch (err) {
      console.error(`Error when proving ${ZkappClass.name}.${methodName}()`);
      throw err;
    } finally {
      memoizationContext.leave(id);
    }
  });
  let maxProofsVerified = ZkappClass._maxProofsVerified;
  const Proof3 = ZkappClass.Proof();
  return new Proof3({
    publicInput,
    publicOutput: void 0,
    proof,
    maxProofsVerified
  });
}
function getZkappProver({ methodName, ZkappClass }) {
  if (ZkappClass._provers === void 0)
    throw Error(`Cannot prove execution of ${methodName}(), no prover found. Try calling \`await ${ZkappClass.name}.compile()\` first, this will cache provers in the background.`);
  let provers = ZkappClass._provers;
  let methodError2 = `Error when computing proofs: Method ${methodName} not found. Make sure your environment supports decorators, and annotate with \`@method ${methodName}\`.`;
  if (ZkappClass._methods === void 0)
    throw Error(methodError2);
  let i2 = ZkappClass._methods.findIndex((m) => m.methodName === methodName);
  if (i2 === -1)
    throw Error(methodError2);
  return provers[i2];
}

// dist/node/lib/mina/errors.js
var ErrorHandlers = {
  Invalid_fee_excess({ transaction: { accountUpdates }, isFeePayer, accountCreationFee: accountCreationFee2 }) {
    if (isFeePayer)
      return;
    let balances = accountUpdates.map(({ body }) => {
      if (body.tokenId.equals(TokenId4.default).toBoolean()) {
        return Number(Int64.fromObject(body.balanceChange).toString()) * 1e-9;
      }
    });
    let sum2 = balances.reduce((a2 = 0, b2 = 0) => a2 + b2) ?? 0;
    return `Invalid fee excess.
This means that balance changes in your transaction do not sum up to the amount of fees needed.
Here's the list of balance changes:

${balances.map((balance, i2) => {
      return `Account update #${i2 + 1}) ${balance === void 0 ? "not a MINA account" : `${balance.toFixed(2)} MINA`}`;
    }).join(`
`)}

Total change: ${sum2.toFixed(2)} MINA

If there are no new accounts created in your transaction, then this sum should be equal to 0.00 MINA.
If you are creating new accounts -- by updating accounts that didn't exist yet --
then keep in mind the ${(Number(accountCreationFee2) * 1e-9).toFixed(2)} MINA account creation fee, and make sure that the sum equals
${(-Number(accountCreationFee2) * 1e-9).toFixed(2)} times the number of newly created accounts.`;
  }
};
function invalidTransactionError(transaction2, errors, additionalContext) {
  let errorMessages = [];
  let rawErrors = JSON.stringify(errors);
  let errorsForFeePayer = errors[0];
  for (let [error] of errorsForFeePayer) {
    let message = ErrorHandlers[error]?.({
      transaction: transaction2,
      accountUpdateIndex: NaN,
      isFeePayer: true,
      ...additionalContext
    });
    if (message)
      errorMessages.push(message);
  }
  let n = transaction2.accountUpdates.length;
  for (let i2 = 0; i2 < n; i2++) {
    let errorsForUpdate = errors[i2 + 1];
    for (let [error] of errorsForUpdate) {
      let message = ErrorHandlers[error]?.({
        transaction: transaction2,
        accountUpdateIndex: i2,
        isFeePayer: false,
        ...additionalContext
      });
      if (message)
        errorMessages.push(message);
    }
  }
  if (errorMessages.length > 1) {
    return [
      "There were multiple errors when applying your transaction:",
      ...errorMessages.map((msg, i2) => `${i2 + 1}.) ${msg}`),
      `Raw list of errors: ${rawErrors}`
    ].join("\n\n");
  }
  if (errorMessages.length === 1) {
    return `${errorMessages[0]}

Raw list of errors: ${rawErrors}`;
  }
  return rawErrors;
}

// dist/node/lib/mina/constants.js
var TransactionCost;
(function(TransactionCost2) {
  TransactionCost2.PROOF_COST = 10.26;
  TransactionCost2.SIGNED_PAIR_COST = 10.08;
  TransactionCost2.SIGNED_SINGLE_COST = 9.14;
  TransactionCost2.COST_LIMIT = 69.45;
})(TransactionCost || (TransactionCost = {}));
var TransactionLimits;
(function(TransactionLimits2) {
  TransactionLimits2.MAX_ACTION_ELEMENTS = 100;
  TransactionLimits2.MAX_EVENT_ELEMENTS = 100;
})(TransactionLimits || (TransactionLimits = {}));

// dist/node/lib/ml/conversion.js
var Ml = {
  constFromField,
  constToField,
  varFromField,
  varToField,
  fromScalar,
  toScalar,
  fromPrivateKey,
  toPrivateKey,
  fromPublicKey,
  toPublicKey,
  fromPublicKeyVar,
  toPublicKeyVar
};
function constFromField(x) {
  return x.toConstant().value[1];
}
function constToField(x) {
  return Field4(x);
}
function varFromField(x) {
  return x.value;
}
function varToField(x) {
  return Field4(x);
}
function fromScalar(s) {
  return s.toConstant().constantValue;
}
function toScalar(s) {
  return Scalar3.from(s);
}
function fromPrivateKey(sk) {
  return fromScalar(sk.s);
}
function toPrivateKey(sk) {
  return new PrivateKey2(Scalar3.from(sk));
}
function fromPublicKey(pk) {
  return MlPair(pk.x.toConstant().value[1], MlBool(pk.isOdd.toBoolean()));
}
function toPublicKey([, x, isOdd]) {
  return PublicKey2.from({
    x: Field4(x),
    isOdd: Bool4(MlBool.from(isOdd))
  });
}
function fromPublicKeyVar(pk) {
  return MlPair(pk.x.value, pk.isOdd.toField().value);
}
function toPublicKeyVar([, x, isOdd]) {
  return PublicKey2.from({ x: Field4(x), isOdd: Bool4(isOdd) });
}

// dist/node/lib/mina.js
var Transaction = {
  fromJSON(json) {
    let transaction2 = ZkappCommand3.fromJSON(json);
    return newTransaction(transaction2, activeInstance.proofsEnabled);
  }
};
var currentTransaction = Context.create();
function reportGetAccountError(publicKey, tokenId) {
  if (tokenId === TokenId4.toBase58(TokenId4.default)) {
    return `getAccount: Could not find account for public key ${publicKey}`;
  } else {
    return `getAccount: Could not find account for public key ${publicKey} with the tokenId ${tokenId}`;
  }
}
function createTransaction(feePayer, f, numberOfRuns, { fetchMode = "cached", isFinalRunOutsideCircuit = true, proofsEnabled = true } = {}) {
  if (currentTransaction.has()) {
    throw new Error("Cannot start new transaction within another transaction");
  }
  let feePayerSpec;
  if (feePayer === void 0) {
    feePayerSpec = {};
  } else if (feePayer instanceof PrivateKey2) {
    feePayerSpec = { feePayerKey: feePayer, sender: feePayer.toPublicKey() };
  } else if (feePayer instanceof PublicKey2) {
    feePayerSpec = { sender: feePayer };
  } else {
    feePayerSpec = feePayer;
    if (feePayerSpec.sender === void 0)
      feePayerSpec.sender = feePayerSpec.feePayerKey?.toPublicKey();
  }
  let { feePayerKey, sender: sender2, fee, memo = "", nonce } = feePayerSpec;
  let transactionId = currentTransaction.enter({
    sender: sender2,
    accountUpdates: [],
    fetchMode,
    isFinalRunOutsideCircuit,
    numberOfRuns
  });
  try {
    let err;
    while (true) {
      if (err !== void 0)
        err.bootstrap();
      try {
        if (fetchMode === "test") {
          Provable.runUnchecked(() => {
            f();
            Provable.asProver(() => {
              let tx = currentTransaction.get();
              tx.accountUpdates = CallForest.map(tx.accountUpdates, (a2) => toConstant2(AccountUpdate3, a2));
            });
          });
        } else {
          f();
        }
        break;
      } catch (err_) {
        if (err_?.bootstrap)
          err = err_;
        else
          throw err_;
      }
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let accountUpdates = currentTransaction.get().accountUpdates;
  accountUpdates = CallForest.toFlatList(accountUpdates);
  try {
    for (let accountUpdate of accountUpdates) {
      assertPreconditionInvariants(accountUpdate);
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let feePayerAccountUpdate;
  if (sender2 !== void 0) {
    let nonce_;
    let senderAccount = getAccount(sender2, TokenId4.default);
    if (nonce === void 0) {
      nonce_ = senderAccount.nonce;
    } else {
      nonce_ = UInt322.from(nonce);
      senderAccount.nonce = nonce_;
      addCachedAccount(senderAccount);
    }
    feePayerAccountUpdate = AccountUpdate3.defaultFeePayer(sender2, nonce_);
    if (feePayerKey !== void 0)
      feePayerAccountUpdate.lazyAuthorization.privateKey = feePayerKey;
    if (fee !== void 0) {
      feePayerAccountUpdate.body.fee = fee instanceof UInt642 ? fee : UInt642.from(String(fee));
    }
  } else {
    feePayerAccountUpdate = AccountUpdate3.dummyFeePayer();
  }
  let transaction2 = {
    accountUpdates,
    feePayer: feePayerAccountUpdate,
    memo
  };
  currentTransaction.leave(transactionId);
  return newTransaction(transaction2, proofsEnabled);
}
function newTransaction(transaction2, proofsEnabled) {
  let self = {
    transaction: transaction2,
    sign(additionalKeys) {
      self.transaction = addMissingSignatures(self.transaction, additionalKeys);
      return self;
    },
    async prove() {
      let { zkappCommand, proofs } = await addMissingProofs(self.transaction, {
        proofsEnabled
      });
      self.transaction = zkappCommand;
      return proofs;
    },
    toJSON() {
      let json = ZkappCommand3.toJSON(self.transaction);
      return JSON.stringify(json);
    },
    toPretty() {
      return ZkappCommand3.toPretty(self.transaction);
    },
    toGraphqlQuery() {
      return sendZkappQuery(self.toJSON());
    },
    async send() {
      try {
        return await sendTransaction(self);
      } catch (error) {
        throw prettifyStacktrace(error);
      }
    }
  };
  return self;
}
var defaultAccountCreationFee = 1e9;
var defaultNetworkConstants = {
  genesisTimestamp: UInt642.from(0),
  slotTime: UInt642.from(3 * 60 * 1e3),
  accountCreationFee: UInt642.from(defaultAccountCreationFee)
};
function LocalBlockchain({ proofsEnabled = true, enforceTransactionLimits = true, networkId = "testnet" } = {}) {
  const slotTime = 3 * 60 * 1e3;
  const startTime = Date.now();
  const genesisTimestamp = UInt642.from(startTime);
  const ledger = Ledger.create();
  let networkState = defaultNetworkState();
  let minaNetworkId = networkId;
  function addAccount(publicKey, balance) {
    ledger.addAccount(Ml.fromPublicKey(publicKey), balance);
  }
  let testAccounts = [];
  for (let i2 = 0; i2 < 10; ++i2) {
    let MINA = 10n ** 9n;
    const largeValue = 1000n * MINA;
    const k = PrivateKey2.random();
    const pk = k.toPublicKey();
    addAccount(pk, largeValue.toString());
    testAccounts.push({ privateKey: k, publicKey: pk });
  }
  const events = {};
  const actions = {};
  return {
    getNetworkId: () => minaNetworkId,
    proofsEnabled,
    /**
    * @deprecated use {@link Mina.getNetworkConstants}
    */
    accountCreationFee: () => defaultNetworkConstants.accountCreationFee,
    getNetworkConstants() {
      return {
        ...defaultNetworkConstants,
        genesisTimestamp
      };
    },
    currentSlot() {
      return UInt322.from(Math.ceil(((/* @__PURE__ */ new Date()).valueOf() - startTime) / slotTime));
    },
    hasAccount(publicKey, tokenId = TokenId4.default) {
      return !!ledger.getAccount(Ml.fromPublicKey(publicKey), Ml.constFromField(tokenId));
    },
    getAccount(publicKey, tokenId = TokenId4.default) {
      let accountJson = ledger.getAccount(Ml.fromPublicKey(publicKey), Ml.constFromField(tokenId));
      if (accountJson === void 0) {
        throw new Error(reportGetAccountError(publicKey.toBase58(), TokenId4.toBase58(tokenId)));
      }
      return transaction_exports.Account.fromJSON(accountJson);
    },
    getNetworkState() {
      return networkState;
    },
    async sendTransaction(txn) {
      txn.sign();
      let zkappCommandJson = ZkappCommand3.toJSON(txn.transaction);
      let commitments = transactionCommitments(transaction_bigint_exports.ZkappCommand.fromJSON(zkappCommandJson));
      if (enforceTransactionLimits)
        verifyTransactionLimits(txn.transaction);
      for (const update of txn.transaction.accountUpdates) {
        let accountJson = ledger.getAccount(Ml.fromPublicKey(update.body.publicKey), Ml.constFromField(update.body.tokenId));
        let authIsProof = !!update.authorization.proof;
        let kindIsProof = update.body.authorizationKind.isProved.toBoolean();
        if (kindIsProof && !authIsProof) {
          throw Error(`The actual authorization does not match the expected authorization kind. Did you forget to invoke \`await tx.prove();\`?`);
        }
        if (accountJson) {
          let account = Account4.fromJSON(accountJson);
          await verifyAccountUpdate(account, update, commitments, this.proofsEnabled, this.getNetworkId());
        }
      }
      try {
        ledger.applyJsonTransaction(JSON.stringify(zkappCommandJson), defaultNetworkConstants.accountCreationFee.toString(), JSON.stringify(networkState));
      } catch (err) {
        try {
          let errors = JSON.parse(err.message);
          err.message = invalidTransactionError(txn.transaction, errors, {
            accountCreationFee: defaultNetworkConstants.accountCreationFee.toString()
          });
        } finally {
          throw err;
        }
      }
      txn.transaction.accountUpdates.forEach((p3, i2) => {
        let pJson = zkappCommandJson.accountUpdates[i2];
        let addr = pJson.body.publicKey;
        let tokenId = pJson.body.tokenId;
        events[addr] ??= {};
        if (p3.body.events.data.length > 0) {
          events[addr][tokenId] ??= [];
          let updatedEvents = p3.body.events.data.map((data) => {
            return {
              data,
              transactionInfo: {
                transactionHash: "",
                transactionStatus: "",
                transactionMemo: ""
              }
            };
          });
          events[addr][tokenId].push({
            events: updatedEvents,
            blockHeight: networkState.blockchainLength,
            globalSlot: networkState.globalSlotSinceGenesis,
            // The following fields are fetched from the Mina network. For now, we mock these values out
            // since networkState does not contain these fields.
            blockHash: "",
            parentBlockHash: "",
            chainStatus: ""
          });
        }
        let storedActions = actions[addr]?.[tokenId];
        let latestActionState_ = storedActions?.[storedActions.length - 1]?.hash;
        let latestActionState = latestActionState_ !== void 0 ? Field4(latestActionState_) : Actions.emptyActionState();
        actions[addr] ??= {};
        if (p3.body.actions.data.length > 0) {
          let newActionState = Actions.updateSequenceState(latestActionState, p3.body.actions.hash);
          actions[addr][tokenId] ??= [];
          actions[addr][tokenId].push({
            actions: pJson.body.actions,
            hash: newActionState.toString()
          });
        }
      });
      return {
        isSuccess: true,
        wait: async (_options) => {
          console.log("Info: Waiting for inclusion in a block is not supported for LocalBlockchain.");
        },
        hash: () => {
          const message = "Info: Txn Hash retrieving is not supported for LocalBlockchain.";
          console.log(message);
          return message;
        }
      };
    },
    async transaction(sender2, f) {
      let tx = createTransaction(sender2, f, 0, {
        isFinalRunOutsideCircuit: false,
        proofsEnabled: this.proofsEnabled,
        fetchMode: "test"
      });
      let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
      return createTransaction(sender2, f, 1, {
        isFinalRunOutsideCircuit: !hasProofs,
        proofsEnabled: this.proofsEnabled
      });
    },
    applyJsonTransaction(json) {
      return ledger.applyJsonTransaction(json, defaultNetworkConstants.accountCreationFee.toString(), JSON.stringify(networkState));
    },
    async fetchEvents(publicKey, tokenId = TokenId4.default) {
      return events?.[publicKey.toBase58()]?.[TokenId4.toBase58(tokenId)] ?? [];
    },
    async fetchActions(publicKey, actionStates, tokenId = TokenId4.default) {
      return this.getActions(publicKey, actionStates, tokenId);
    },
    getActions(publicKey, actionStates, tokenId = TokenId4.default) {
      let currentActions = actions?.[publicKey.toBase58()]?.[TokenId4.toBase58(tokenId)] ?? [];
      let { fromActionState, endActionState } = actionStates ?? {};
      let emptyState = Actions.emptyActionState();
      if (endActionState?.equals(emptyState).toBoolean())
        return [];
      let start = fromActionState?.equals(emptyState).toBoolean() ? void 0 : fromActionState?.toString();
      let end = endActionState?.toString();
      let startIndex = 0;
      if (start) {
        let i2 = currentActions.findIndex((e) => e.hash === start);
        if (i2 === -1)
          throw Error(`getActions: fromActionState not found.`);
        startIndex = i2 + 1;
      }
      let endIndex;
      if (end) {
        let i2 = currentActions.findIndex((e) => e.hash === end);
        if (i2 === -1)
          throw Error(`getActions: endActionState not found.`);
        endIndex = i2 + 1;
      }
      return currentActions.slice(startIndex, endIndex);
    },
    addAccount,
    /**
     * An array of 10 test accounts that have been pre-filled with
     * 30000000000 units of currency.
     */
    testAccounts,
    setGlobalSlot(slot) {
      networkState.globalSlotSinceGenesis = UInt322.from(slot);
    },
    incrementGlobalSlot(increment) {
      networkState.globalSlotSinceGenesis = networkState.globalSlotSinceGenesis.add(increment);
    },
    setBlockchainLength(height) {
      networkState.blockchainLength = height;
    },
    setTotalCurrency(currency) {
      networkState.totalCurrency = currency;
    },
    setProofsEnabled(newProofsEnabled) {
      this.proofsEnabled = newProofsEnabled;
    }
  };
}
function Network2(options) {
  let minaNetworkId = "testnet";
  let minaGraphqlEndpoint;
  let archiveEndpoint;
  let lightnetAccountManagerEndpoint;
  if (options && typeof options === "string") {
    minaGraphqlEndpoint = options;
    setGraphqlEndpoint(minaGraphqlEndpoint);
  } else if (options && typeof options === "object") {
    if (options.networkId) {
      minaNetworkId = options.networkId;
    }
    if (!options.mina)
      throw new Error("Network: malformed input. Please provide an object with 'mina' endpoint.");
    if (Array.isArray(options.mina) && options.mina.length !== 0) {
      minaGraphqlEndpoint = options.mina[0];
      setGraphqlEndpoint(minaGraphqlEndpoint);
      setMinaGraphqlFallbackEndpoints(options.mina.slice(1));
    } else if (typeof options.mina === "string") {
      minaGraphqlEndpoint = options.mina;
      setGraphqlEndpoint(minaGraphqlEndpoint);
    }
    if (options.archive !== void 0) {
      if (Array.isArray(options.archive) && options.archive.length !== 0) {
        archiveEndpoint = options.archive[0];
        setArchiveGraphqlEndpoint(archiveEndpoint);
        setArchiveGraphqlFallbackEndpoints(options.archive.slice(1));
      } else if (typeof options.archive === "string") {
        archiveEndpoint = options.archive;
        setArchiveGraphqlEndpoint(archiveEndpoint);
      }
    }
    if (options.lightnetAccountManager !== void 0 && typeof options.lightnetAccountManager === "string") {
      lightnetAccountManagerEndpoint = options.lightnetAccountManager;
      setLightnetAccountManagerEndpoint(lightnetAccountManagerEndpoint);
    }
  } else {
    throw new Error("Network: malformed input. Please provide a string or an object with 'mina' and 'archive' endpoints.");
  }
  return {
    getNetworkId: () => minaNetworkId,
    /**
    * @deprecated use {@link Mina.getNetworkConstants}
    */
    accountCreationFee: () => defaultNetworkConstants.accountCreationFee,
    getNetworkConstants() {
      if (currentTransaction()?.fetchMode === "test") {
        markNetworkToBeFetched(minaGraphqlEndpoint);
        const genesisConstants = getCachedGenesisConstants(minaGraphqlEndpoint);
        return genesisConstants !== void 0 ? genesisToNetworkConstants(genesisConstants) : defaultNetworkConstants;
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        const genesisConstants = getCachedGenesisConstants(minaGraphqlEndpoint);
        if (genesisConstants !== void 0)
          return genesisToNetworkConstants(genesisConstants);
      }
      return defaultNetworkConstants;
    },
    currentSlot() {
      throw Error("currentSlot() is not implemented yet for remote blockchains.");
    },
    hasAccount(publicKey, tokenId = TokenId4.default) {
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        return !!getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);
      }
      return false;
    },
    getAccount(publicKey, tokenId = TokenId4.default) {
      if (currentTransaction()?.fetchMode === "test") {
        markAccountToBeFetched(publicKey, tokenId, minaGraphqlEndpoint);
        let account = getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);
        return account ?? dummyAccount(publicKey);
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let account = getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);
        if (account !== void 0)
          return account;
      }
      throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId4.toBase58(tokenId))}
Graphql endpoint: ${minaGraphqlEndpoint}`);
    },
    getNetworkState() {
      if (currentTransaction()?.fetchMode === "test") {
        markNetworkToBeFetched(minaGraphqlEndpoint);
        let network = getCachedNetwork(minaGraphqlEndpoint);
        return network ?? defaultNetworkState();
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let network = getCachedNetwork(minaGraphqlEndpoint);
        if (network !== void 0)
          return network;
      }
      throw Error(`getNetworkState: Could not fetch network state from graphql endpoint ${minaGraphqlEndpoint} outside of a transaction.`);
    },
    async sendTransaction(txn) {
      txn.sign();
      verifyTransactionLimits(txn.transaction);
      let [response, error] = await sendZkapp(txn.toJSON());
      let errors;
      if (response === void 0 && error !== void 0) {
        console.log("Error: Failed to send transaction", error);
        errors = [error];
      } else if (response && response.errors && response.errors.length > 0) {
        console.log("Error: Transaction returned with errors", JSON.stringify(response.errors, null, 2));
        errors = response.errors;
      }
      let isSuccess = errors === void 0;
      let maxAttempts;
      let attempts = 0;
      let interval;
      return {
        isSuccess,
        data: response?.data,
        errors,
        async wait(options2) {
          if (!isSuccess) {
            console.warn("Transaction.wait(): returning immediately because the transaction was not successful.");
            return;
          }
          maxAttempts = options2?.maxAttempts ?? 45;
          interval = options2?.interval ?? 2e4;
          const executePoll = async (resolve2, reject) => {
            let txId = response?.data?.sendZkapp?.zkapp?.hash;
            let res;
            try {
              res = await checkZkappTransaction(txId);
            } catch (error2) {
              isSuccess = false;
              return reject(error2);
            }
            attempts++;
            if (res.success) {
              isSuccess = true;
              return resolve2();
            } else if (res.failureReason) {
              isSuccess = false;
              return reject(new Error(`Transaction failed.
TransactionId: ${txId}
Attempts: ${attempts}
failureReason(s): ${res.failureReason}`));
            } else if (maxAttempts && attempts === maxAttempts) {
              isSuccess = false;
              return reject(new Error(`Exceeded max attempts.
TransactionId: ${txId}
Attempts: ${attempts}
Last received status: ${res}`));
            } else {
              setTimeout(executePoll, interval, resolve2, reject);
            }
          };
          return new Promise(executePoll);
        },
        hash() {
          return response?.data?.sendZkapp?.zkapp?.hash;
        }
      };
    },
    async transaction(sender2, f) {
      let tx = createTransaction(sender2, f, 0, {
        fetchMode: "test",
        isFinalRunOutsideCircuit: false
      });
      await fetchMissingData(minaGraphqlEndpoint, archiveEndpoint);
      let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
      return createTransaction(sender2, f, 1, {
        fetchMode: "cached",
        isFinalRunOutsideCircuit: !hasProofs
      });
    },
    async fetchEvents(publicKey, tokenId = TokenId4.default, filterOptions = {}) {
      let pubKey = publicKey.toBase58();
      let token = TokenId4.toBase58(tokenId);
      return fetchEvents({ publicKey: pubKey, tokenId: token }, archiveEndpoint, filterOptions);
    },
    async fetchActions(publicKey, actionStates, tokenId = TokenId4.default) {
      let pubKey = publicKey.toBase58();
      let token = TokenId4.toBase58(tokenId);
      let { fromActionState, endActionState } = actionStates ?? {};
      let fromActionStateBase58 = fromActionState ? fromActionState.toString() : void 0;
      let endActionStateBase58 = endActionState ? endActionState.toString() : void 0;
      return fetchActions({
        publicKey: pubKey,
        actionStates: {
          fromActionState: fromActionStateBase58,
          endActionState: endActionStateBase58
        },
        tokenId: token
      }, archiveEndpoint);
    },
    getActions(publicKey, actionStates, tokenId = TokenId4.default) {
      if (currentTransaction()?.fetchMode === "test") {
        markActionsToBeFetched(publicKey, tokenId, archiveEndpoint, actionStates);
        let actions = getCachedActions(publicKey, tokenId);
        return actions ?? [];
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let actions = getCachedActions(publicKey, tokenId);
        if (actions !== void 0)
          return actions;
      }
      throw Error(`getActions: Could not find actions for the public key ${publicKey}`);
    },
    proofsEnabled: true
  };
}
function BerkeleyQANet(graphqlEndpoint) {
  return Network2(graphqlEndpoint);
}
var activeInstance = {
  getNetworkId: () => "testnet",
  /**
   * @deprecated use {@link Mina.getNetworkConstants}
   */
  accountCreationFee: () => defaultNetworkConstants.accountCreationFee,
  getNetworkConstants() {
    return defaultNetworkConstants;
  },
  currentSlot: () => {
    throw new Error("must call Mina.setActiveInstance first");
  },
  hasAccount(publicKey, tokenId = TokenId4.default) {
    if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
      return !!getCachedAccount(publicKey, tokenId, networkConfig.minaEndpoint);
    }
    return false;
  },
  getAccount(publicKey, tokenId = TokenId4.default) {
    if (currentTransaction()?.fetchMode === "test") {
      markAccountToBeFetched(publicKey, tokenId, networkConfig.minaEndpoint);
      return dummyAccount(publicKey);
    }
    if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
      let account = getCachedAccount(publicKey, tokenId, networkConfig.minaEndpoint);
      if (account === void 0)
        throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId4.toBase58(tokenId))}

Either call Mina.setActiveInstance first or explicitly add the account with addCachedAccount`);
      return account;
    }
    throw new Error("must call Mina.setActiveInstance first");
  },
  getNetworkState() {
    throw new Error("must call Mina.setActiveInstance first");
  },
  sendTransaction() {
    throw new Error("must call Mina.setActiveInstance first");
  },
  async transaction(sender2, f) {
    return createTransaction(sender2, f, 0);
  },
  fetchEvents(_publicKey, _tokenId = TokenId4.default) {
    throw Error("must call Mina.setActiveInstance first");
  },
  fetchActions(_publicKey, _actionStates, _tokenId = TokenId4.default) {
    throw Error("must call Mina.setActiveInstance first");
  },
  getActions(_publicKey, _actionStates, _tokenId = TokenId4.default) {
    throw Error("must call Mina.setActiveInstance first");
  },
  proofsEnabled: true
};
function setActiveInstance(m) {
  activeInstance = m;
}
function transaction(senderOrF, fOrUndefined) {
  let sender2;
  let f;
  try {
    if (fOrUndefined !== void 0) {
      sender2 = senderOrF;
      f = fOrUndefined;
    } else {
      sender2 = void 0;
      f = senderOrF;
    }
    return activeInstance.transaction(sender2, f);
  } catch (error) {
    throw prettifyStacktrace(error);
  }
}
function sender() {
  let tx = currentTransaction();
  if (tx === void 0)
    throw Error(`The sender is not available outside a transaction. Make sure you only use it within \`Mina.transaction\` blocks or smart contract methods.`);
  let sender2 = currentTransaction()?.sender;
  if (sender2 === void 0)
    throw Error(`The sender is not available, because the transaction block was created without the optional \`sender\` argument.
Here's an example for how to pass in the sender and make it available:

Mina.transaction(sender, // <-- pass in sender's public key here
() => {
  // methods can use this.sender
});
`);
  return sender2;
}
function currentSlot() {
  return activeInstance.currentSlot();
}
function getAccount(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId);
}
function hasAccount(publicKey, tokenId) {
  return activeInstance.hasAccount(publicKey, tokenId);
}
function getNetworkId() {
  return activeInstance.getNetworkId();
}
function getNetworkConstants() {
  return activeInstance.getNetworkConstants();
}
function getNetworkState() {
  return activeInstance.getNetworkState();
}
function getBalance(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId).balance;
}
function accountCreationFee() {
  return activeInstance.accountCreationFee();
}
async function sendTransaction(txn) {
  return await activeInstance.sendTransaction(txn);
}
async function fetchEvents2(publicKey, tokenId, filterOptions = {}) {
  return await activeInstance.fetchEvents(publicKey, tokenId, filterOptions);
}
async function fetchActions2(publicKey, actionStates, tokenId) {
  return await activeInstance.fetchActions(publicKey, actionStates, tokenId);
}
function getActions(publicKey, actionStates, tokenId) {
  return activeInstance.getActions(publicKey, actionStates, tokenId);
}
function getProofsEnabled() {
  return activeInstance.proofsEnabled;
}
function dummyAccount(pubkey) {
  let dummy = transaction_exports.Account.empty();
  if (pubkey)
    dummy.publicKey = pubkey;
  return dummy;
}
function defaultNetworkState() {
  let epochData = {
    ledger: { hash: Field4(0), totalCurrency: UInt642.zero },
    seed: Field4(0),
    startCheckpoint: Field4(0),
    lockCheckpoint: Field4(0),
    epochLength: UInt322.zero
  };
  return {
    snarkedLedgerHash: Field4(0),
    blockchainLength: UInt322.zero,
    minWindowDensity: UInt322.zero,
    totalCurrency: UInt642.zero,
    globalSlotSinceGenesis: UInt322.zero,
    stakingEpochData: epochData,
    nextEpochData: cloneCircuitValue(epochData)
  };
}
async function verifyAccountUpdate(account, accountUpdate, transactionCommitments2, proofsEnabled, networkId) {
  if (accountUpdate.body.callDepth === 0 && !AccountUpdate3.MayUseToken.isNo(accountUpdate).toBoolean()) {
    throw Error("Top-level account update can not use or pass on token permissions. Make sure that\naccountUpdate.body.mayUseToken = AccountUpdate.MayUseToken.No;");
  }
  let perm = account.permissions;
  if (accountUpdate.authorization === dummySignature()) {
    let pk = PublicKey2.toBase58(accountUpdate.body.publicKey);
    throw Error(`verifyAccountUpdate: Detected a missing signature for (${pk}), private key was missing.`);
  }
  function includesChange(val) {
    if (Array.isArray(val)) {
      return !val.every((v) => v === null);
    } else {
      return val !== null;
    }
  }
  function permissionForUpdate(key) {
    switch (key) {
      case "appState":
        return perm.editState;
      case "delegate":
        return perm.setDelegate;
      case "verificationKey":
        return perm.setVerificationKey;
      case "permissions":
        return perm.setPermissions;
      case "zkappUri":
        return perm.setZkappUri;
      case "tokenSymbol":
        return perm.setTokenSymbol;
      case "timing":
        return perm.setTiming;
      case "votingFor":
        return perm.setVotingFor;
      case "actions":
        return perm.editActionState;
      case "incrementNonce":
        return perm.incrementNonce;
      case "send":
        return perm.send;
      case "receive":
        return perm.receive;
      default:
        throw Error(`Invalid permission for field ${key}: does not exist.`);
    }
  }
  let accountUpdateJson = accountUpdate.toJSON();
  const update = accountUpdateJson.body.update;
  let errorTrace = "";
  let isValidProof = false;
  let isValidSignature = false;
  if (!proofsEnabled)
    isValidProof = true;
  if (accountUpdate.authorization.proof && proofsEnabled) {
    try {
      let publicInput = accountUpdate.toPublicInput();
      let publicInputFields = ZkappPublicInput.toFields(publicInput);
      const proof = SmartContract.Proof().fromJSON({
        maxProofsVerified: 2,
        proof: accountUpdate.authorization.proof,
        publicInput: publicInputFields.map((f) => f.toString()),
        publicOutput: []
      });
      let verificationKey = account.zkapp?.verificationKey?.data;
      isValidProof = await verify(proof.toJSON(), verificationKey);
      if (!isValidProof) {
        throw Error(`Invalid proof for account update
${JSON.stringify(update)}`);
      }
    } catch (error) {
      errorTrace += "\n\n" + error.message;
      isValidProof = false;
    }
  }
  if (accountUpdate.authorization.signature) {
    try {
      isValidSignature = verifyAccountUpdateSignature(transaction_bigint_exports.AccountUpdate.fromJSON(accountUpdateJson), transactionCommitments2, networkId);
    } catch (error) {
      errorTrace += "\n\n" + error.message;
      isValidSignature = false;
    }
  }
  let verified = false;
  function checkPermission(p0, field) {
    let p3 = transaction_exports.AuthRequired.toJSON(p0);
    if (p3 === "None")
      return;
    if (p3 === "Impossible") {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p3}'`);
    }
    if (p3 === "Signature" || p3 === "Either") {
      verified ||= isValidSignature;
    }
    if (p3 === "Proof" || p3 === "Either") {
      verified ||= isValidProof;
    }
    if (!verified) {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p3}', but the required authorization was not provided or is invalid.
        ${errorTrace !== "" ? "Error trace: " + errorTrace : ""}`);
    }
  }
  Object.entries(update).forEach(([key, value]) => {
    if (includesChange(value)) {
      let p3 = permissionForUpdate(key);
      checkPermission(p3, key);
    }
  });
  if (accountUpdate.body.actions.data.length > 0) {
    let p3 = permissionForUpdate("actions");
    checkPermission(p3, "actions");
  }
  if (accountUpdate.body.incrementNonce.toBoolean()) {
    let p3 = permissionForUpdate("incrementNonce");
    checkPermission(p3, "incrementNonce");
  }
  if (errorTrace && !verified) {
    throw Error(`One or more proofs were invalid and no other form of authorization was provided.
${errorTrace}`);
  }
}
function verifyTransactionLimits({ accountUpdates }) {
  let eventElements = { events: 0, actions: 0 };
  let authKinds = accountUpdates.map((update) => {
    eventElements.events += countEventElements(update.body.events);
    eventElements.actions += countEventElements(update.body.actions);
    let { isSigned, isProved, verificationKeyHash } = update.body.authorizationKind;
    return {
      isSigned: isSigned.toBoolean(),
      isProved: isProved.toBoolean(),
      verificationKeyHash: verificationKeyHash.toString()
    };
  });
  authKinds.unshift({
    isSigned: true,
    isProved: false,
    verificationKeyHash: ""
  });
  let authTypes = filterGroups(authKinds);
  let totalTimeRequired = TransactionCost.PROOF_COST * authTypes.proof + TransactionCost.SIGNED_PAIR_COST * authTypes.signedPair + TransactionCost.SIGNED_SINGLE_COST * authTypes.signedSingle;
  let isWithinCostLimit = totalTimeRequired < TransactionCost.COST_LIMIT;
  let isWithinEventsLimit = eventElements.events <= TransactionLimits.MAX_EVENT_ELEMENTS;
  let isWithinActionsLimit = eventElements.actions <= TransactionLimits.MAX_ACTION_ELEMENTS;
  let error = "";
  if (!isWithinCostLimit) {
    error += `Error: The transaction is too expensive, try reducing the number of AccountUpdates that are attached to the transaction.
Each transaction needs to be processed by the snark workers on the network.
Certain layouts of AccountUpdates require more proving time than others, and therefore are too expensive.

${JSON.stringify(authTypes)}


`;
  }
  if (!isWithinEventsLimit) {
    error += `Error: The account updates in your transaction are trying to emit too much event data. The maximum allowed number of field elements in events is ${TransactionLimits.MAX_EVENT_ELEMENTS}, but you tried to emit ${eventElements.events}.

`;
  }
  if (!isWithinActionsLimit) {
    error += `Error: The account updates in your transaction are trying to emit too much action data. The maximum allowed number of field elements in actions is ${TransactionLimits.MAX_ACTION_ELEMENTS}, but you tried to emit ${eventElements.actions}.

`;
  }
  if (error)
    throw Error("Error during transaction sending:\n\n" + error);
}
function countEventElements({ data }) {
  return data.reduce((acc, ev) => acc + ev.length, 0);
}
var isPair = (a2, b2) => !a2.isProved && !b2.isProved;
function filterPairs(xs) {
  if (xs.length <= 1)
    return { xs, pairs: 0 };
  if (isPair(xs[0], xs[1])) {
    let rec = filterPairs(xs.slice(2));
    return { xs: rec.xs, pairs: rec.pairs + 1 };
  } else {
    let rec = filterPairs(xs.slice(1));
    return { xs: [xs[0]].concat(rec.xs), pairs: rec.pairs };
  }
}
function filterGroups(xs) {
  let pairs = filterPairs(xs);
  xs = pairs.xs;
  let singleCount = 0;
  let proofCount = 0;
  xs.forEach((t) => {
    if (t.isProved)
      proofCount++;
    else
      singleCount++;
  });
  return {
    signedPair: pairs.pairs,
    signedSingle: singleCount,
    proof: proofCount
  };
}
async function waitForFunding(address) {
  let attempts = 0;
  let maxAttempts = 30;
  let interval = 3e4;
  const executePoll = async (resolve2, reject) => {
    let { account } = await fetchAccount({ publicKey: address });
    attempts++;
    if (account) {
      return resolve2();
    } else if (maxAttempts && attempts === maxAttempts) {
      return reject(new Error(`Exceeded max attempts`));
    } else {
      setTimeout(executePoll, interval, resolve2, reject);
    }
  };
  return new Promise(executePoll);
}
async function faucet(pub, network = "berkeley-qanet") {
  let address = pub.toBase58();
  let response = await fetch("https://faucet.minaprotocol.com/api/v1/faucet", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      network,
      address
    })
  });
  response = await response.json();
  if (response.status.toString() !== "success") {
    throw new Error(`Error funding account ${address}, got response status: ${response.status}, text: ${response.statusText}`);
  }
  await waitForFunding(address);
}
function genesisToNetworkConstants(genesisConstants) {
  return {
    genesisTimestamp: UInt642.from(Date.parse(genesisConstants.genesisTimestamp)),
    slotTime: UInt642.from(genesisConstants.slotDuration),
    accountCreationFee: UInt642.from(genesisConstants.accountCreationFee)
  };
}

// dist/node/lib/encryption.js
var encryption_exports = {};
__export(encryption_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
function encrypt(message, otherPublicKey) {
  let privateKey = Provable.witness(Scalar3, () => Scalar3.random());
  let publicKey = Group3.generator.scale(privateKey);
  let sharedSecret = otherPublicKey.toGroup().scale(privateKey);
  let sponge2 = new Poseidon2.Sponge();
  sponge2.absorb(sharedSecret.x);
  let cipherText = [];
  for (let i2 = 0; i2 < message.length; i2++) {
    let keyStream = sponge2.squeeze();
    let encryptedChunk = message[i2].add(keyStream);
    cipherText.push(encryptedChunk);
    if (i2 % 2 === 1)
      sponge2.absorb(cipherText[i2 - 1]);
    if (i2 % 2 === 1 || i2 === message.length - 1)
      sponge2.absorb(cipherText[i2]);
  }
  let authenticationTag = sponge2.squeeze();
  cipherText.push(authenticationTag);
  return { publicKey, cipherText };
}
function decrypt({ publicKey, cipherText }, privateKey) {
  let sharedSecret = publicKey.scale(privateKey.s);
  let sponge2 = new Poseidon2.Sponge();
  sponge2.absorb(sharedSecret.x);
  let authenticationTag = cipherText.pop();
  let message = [];
  for (let i2 = 0; i2 < cipherText.length; i2++) {
    let keyStream = sponge2.squeeze();
    let messageChunk = cipherText[i2].sub(keyStream);
    message.push(messageChunk);
    if (i2 % 2 === 1)
      sponge2.absorb(cipherText[i2 - 1]);
    if (i2 % 2 === 1 || i2 === cipherText.length - 1)
      sponge2.absorb(cipherText[i2]);
  }
  sponge2.squeeze().assertEquals(authenticationTag);
  return message;
}

// dist/node/lib/string.js
var import_tslib6 = require("tslib");
var DEFAULT_STRING_LENGTH = 128;
var Character = class _Character extends CircuitValue {
  isNull() {
    return this.equals(NullCharacter());
  }
  toField() {
    return this.value;
  }
  toString() {
    const charCode = Number(this.value.toString());
    return String.fromCharCode(charCode);
  }
  static fromString(str) {
    const char = Field4(str.charCodeAt(0));
    return new _Character(char);
  }
  // TODO: Add support for more character sets
  // right now it's 16 bits because 8 not supported :/
  static check(c) {
    Gadgets.rangeCheckN(16, c.value);
  }
};
(0, import_tslib6.__decorate)([
  prop,
  (0, import_tslib6.__metadata)("design:type", Field4)
], Character.prototype, "value", void 0);
var CircuitString = class _CircuitString extends CircuitValue {
  // constructor is private because
  // * we do not want extra logic inside CircuitValue constructors, as a general pattern (to be able to create them generically)
  // * here, not running extra logic to fill up the characters would be wrong
  constructor(values) {
    super(values);
  }
  // this is the publicly accessible constructor
  static fromCharacters(chars) {
    return new _CircuitString(fillWithNull(chars, this.maxLength));
  }
  maxLength() {
    return this.constructor.maxLength;
  }
  // some O(n) computation that should be only done once in the circuit
  computeLengthAndMask() {
    let n = this.values.length;
    let length = Field4(0);
    let mask = [];
    let wasntNullAlready = Bool4(true);
    for (let i2 = 0; i2 < n; i2++) {
      let isNull = this.values[i2].isNull();
      mask[i2] = isNull.and(wasntNullAlready);
      wasntNullAlready = isNull.not().and(wasntNullAlready);
      length.add(wasntNullAlready.toField());
    }
    mask[n] = wasntNullAlready;
    this._length = length;
    this._mask = mask;
    return { mask, length };
  }
  lengthMask() {
    return this._mask ?? this.computeLengthAndMask().mask;
  }
  length() {
    return this._length ?? this.computeLengthAndMask().length;
  }
  /**
   * appends another string to this one, returns the result and proves that it fits
   * within the `maxLength` of this string (the other string can have a different maxLength)
   */
  append(str) {
    let n = this.maxLength();
    this.length().add(str.length()).assertLessThan(n);
    let chars = this.values;
    let otherChars = fillWithNull(str.values, n);
    let possibleResults = [];
    for (let length = 0; length < n + 1; length++) {
      possibleResults[length] = chars.slice(0, length).concat(otherChars.slice(0, n - length));
    }
    let result = [];
    let mask = this.lengthMask();
    for (let i2 = 0; i2 < n; i2++) {
      let possibleCharsAtI = possibleResults.map((r) => r[i2]);
      result[i2] = Provable.switch(mask, Character, possibleCharsAtI);
    }
    return _CircuitString.fromCharacters(result);
  }
  // TODO
  /**
   * returns true if `str` is found in this `CircuitString`
   */
  // contains(str: CircuitString): Bool {
  //   // only succeed if the dynamic length is smaller
  //   let otherLength = str.length();
  //   otherLength.assertLessThan(this.length());
  // }
  hash() {
    return Poseidon2.hash(this.values.map((x) => x.value));
  }
  substring(start, end) {
    return _CircuitString.fromCharacters(this.values.slice(start, end));
  }
  toString() {
    return this.values.map((x) => x.toString()).join("").replace(/[^ -~]+/g, "");
  }
  static fromString(str) {
    if (str.length > this.maxLength) {
      throw Error("CircuitString.fromString: input string exceeds max length!");
    }
    let characters = str.split("").map((x) => Character.fromString(x));
    return _CircuitString.fromCharacters(characters);
  }
};
CircuitString.maxLength = DEFAULT_STRING_LENGTH;
(0, import_tslib6.__decorate)([
  arrayProp(Character, DEFAULT_STRING_LENGTH),
  (0, import_tslib6.__metadata)("design:type", Array)
], CircuitString.prototype, "values", void 0);
var NullCharacter = () => new Character(Field4(0));
function fillWithNull([...values], length) {
  let nullChar = NullCharacter();
  for (let i2 = values.length; i2 < length; i2++) {
    values[i2] = nullChar;
  }
  return values;
}

// dist/node/lib/merkle_tree.js
var MerkleTree = class {
  /**
   * Creates a new, empty [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
   * @param height The height of Merkle Tree.
   * @returns A new MerkleTree
   */
  constructor(height) {
    this.height = height;
    this.nodes = {};
    this.zeroes = new Array(height);
    this.zeroes[0] = Field4(0);
    for (let i2 = 1; i2 < height; i2 += 1) {
      this.zeroes[i2] = Poseidon2.hash([this.zeroes[i2 - 1], this.zeroes[i2 - 1]]);
    }
  }
  /**
   * Returns a node which lives at a given index and level.
   * @param level Level of the node.
   * @param index Index of the node.
   * @returns The data of the node.
   */
  getNode(level, index) {
    return this.nodes[level]?.[index.toString()] ?? this.zeroes[level];
  }
  /**
   * Returns the root of the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
   * @returns The root of the Merkle Tree.
   */
  getRoot() {
    return this.getNode(this.height - 1, 0n);
  }
  // TODO: this allows to set a node at an index larger than the size. OK?
  setNode(level, index, value) {
    (this.nodes[level] ??= {})[index.toString()] = value;
  }
  // TODO: if this is passed an index bigger than the max, it will set a couple of out-of-bounds nodes but not affect the real Merkle root. OK?
  /**
   * Sets the value of a leaf node at a given index to a given value.
   * @param index Position of the leaf node.
   * @param leaf New value.
   */
  setLeaf(index, leaf) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    this.setNode(0, index, leaf);
    let currIndex = index;
    for (let level = 1; level < this.height; level++) {
      currIndex /= 2n;
      const left = this.getNode(level - 1, currIndex * 2n);
      const right = this.getNode(level - 1, currIndex * 2n + 1n);
      this.setNode(level, currIndex, Poseidon2.hash([left, right]));
    }
  }
  /**
   * Returns the witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the leaf at the given index.
   * @param index Position of the leaf node.
   * @returns The witness that belongs to the leaf.
   */
  getWitness(index) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    const witness2 = [];
    for (let level = 0; level < this.height - 1; level++) {
      const isLeft = index % 2n === 0n;
      const sibling = this.getNode(level, isLeft ? index + 1n : index - 1n);
      witness2.push({ isLeft, sibling });
      index /= 2n;
    }
    return witness2;
  }
  // TODO: this will always return true if the merkle tree was constructed normally; seems to be only useful for testing. remove?
  /**
   * Checks if the witness that belongs to the leaf at the given index is a valid witness.
   * @param index Position of the leaf node.
   * @returns True if the witness for the leaf node is valid.
   */
  validate(index) {
    const path = this.getWitness(index);
    let hash3 = this.getNode(0, index);
    for (const node of path) {
      hash3 = Poseidon2.hash(node.isLeft ? [hash3, node.sibling] : [node.sibling, hash3]);
    }
    return hash3.toString() === this.getRoot().toString();
  }
  // TODO: should this take an optional offset? should it fail if the array is too long?
  /**
   * Fills all leaves of the tree.
   * @param leaves Values to fill the leaves with.
   */
  fill(leaves) {
    leaves.forEach((value, index) => {
      this.setLeaf(BigInt(index), value);
    });
  }
  /**
   * Returns the amount of leaf nodes.
   * @returns Amount of leaf nodes.
   */
  get leafCount() {
    return 2n ** BigInt(this.height - 1);
  }
};
var BaseMerkleWitness = class extends CircuitValue {
  height() {
    return this.constructor.height;
  }
  /**
   * Takes a {@link Witness} and turns it into a circuit-compatible Witness.
   * @param witness Witness.
   * @returns A circuit-compatible Witness.
   */
  constructor(witness2) {
    super();
    let height = witness2.length + 1;
    if (height !== this.height()) {
      throw Error(`Length of witness ${height}-1 doesn't match static tree height ${this.height()}.`);
    }
    this.path = witness2.map((item) => item.sibling);
    this.isLeft = witness2.map((item) => Bool4(item.isLeft));
  }
  /**
   * Calculates a root depending on the leaf value.
   * @param leaf Value of the leaf node that belongs to this Witness.
   * @returns The calculated root.
   */
  calculateRoot(leaf) {
    let hash3 = leaf;
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      let isLeft = this.isLeft[i2 - 1];
      const [left, right] = maybeSwap(isLeft, hash3, this.path[i2 - 1]);
      hash3 = Poseidon2.hash([left, right]);
    }
    return hash3;
  }
  /**
   * Calculates a root depending on the leaf value.
   * @deprecated This is a less efficient version of {@link calculateRoot} which was added for compatibility with existing deployed contracts
   */
  calculateRootSlow(leaf) {
    let hash3 = leaf;
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      let isLeft = this.isLeft[i2 - 1];
      const [left, right] = maybeSwapBad(isLeft, hash3, this.path[i2 - 1]);
      hash3 = Poseidon2.hash([left, right]);
    }
    return hash3;
  }
  /**
   * Calculates the index of the leaf node that belongs to this Witness.
   * @returns Index of the leaf.
   */
  calculateIndex() {
    let powerOfTwo = Field4(1);
    let index = Field4(0);
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      index = Provable.if(this.isLeft[i2 - 1], index, index.add(powerOfTwo));
      powerOfTwo = powerOfTwo.mul(2);
    }
    return index;
  }
};
function MerkleWitness(height) {
  class MerkleWitness_ extends BaseMerkleWitness {
  }
  MerkleWitness_.height = height;
  arrayProp(Field4, height - 1)(MerkleWitness_.prototype, "path");
  arrayProp(Bool4, height - 1)(MerkleWitness_.prototype, "isLeft");
  return MerkleWitness_;
}
function maybeSwapBad(b2, x, y) {
  const x_ = Provable.if(b2, x, y);
  const y_ = Provable.if(b2, y, x);
  return [x_, y_];
}
function maybeSwap(b2, x, y) {
  let m = b2.toField().mul(x.sub(y));
  const x_ = y.add(m);
  const y_ = x.sub(m);
  return [x_, y_];
}

// dist/node/lib/merkle_map.js
var import_tslib7 = require("tslib");
var bits = 255;
var printDebugs = false;
var MerkleMap = class {
  // ------------------------------------------------
  /**
   * Creates a new, empty Merkle Map.
   * @returns A new MerkleMap
   */
  constructor() {
    if (bits > 255) {
      throw Error("bits must be <= 255");
    }
    if (bits !== 255) {
      console.warn("bits set to", bits + ". Should be set to 255 in production to avoid collisions");
    }
    this.tree = new MerkleTree(bits + 1);
  }
  // ------------------------------------------------
  _keyToIndex(key) {
    let keyBits = key.toBits().slice(0, bits).reverse().map((b2) => b2.toBoolean());
    let n = 0n;
    for (let i2 = 0; i2 < keyBits.length; i2++) {
      const b2 = keyBits[i2] ? 1 : 0;
      n += 2n ** BigInt(i2) * BigInt(b2);
    }
    return n;
  }
  // ------------------------------------------------
  /**
   * Sets a key of the merkle map to a given value.
   * @param key The key to set in the map.
   * @param key The value to set.
   */
  set(key, value) {
    const index = this._keyToIndex(key);
    this.tree.setLeaf(index, value);
  }
  // ------------------------------------------------
  /**
   * Returns a value given a key. Values are by default Field(0).
   * @param key The key to get the value from.
   * @returns The value stored at the key.
   */
  get(key) {
    const index = this._keyToIndex(key);
    return this.tree.getNode(0, index);
  }
  // ------------------------------------------------
  /**
   * Returns the root of the Merkle Map.
   * @returns The root of the Merkle Map.
   */
  getRoot() {
    return this.tree.getRoot();
  }
  /**
   * Returns a circuit-compatible witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the given key.
   * @param key The key to make a witness for.
   * @returns A MerkleMapWitness, which can be used to assert changes to the MerkleMap, and the witness's key.
   */
  getWitness(key) {
    const index = this._keyToIndex(key);
    class MyMerkleWitness extends MerkleWitness(bits + 1) {
    }
    const witness2 = new MyMerkleWitness(this.tree.getWitness(index));
    if (printDebugs) {
      console.log("witness bits", witness2.isLeft.map((l4) => l4.toBoolean() ? "0" : "1").join(", "));
      console.log("key bits", key.toBits().slice(0, bits).map((l4) => l4.toBoolean() ? "1" : "0").join(", "));
    }
    return new MerkleMapWitness(witness2.isLeft, witness2.path);
  }
};
var MerkleMapWitness = class extends CircuitValue {
  constructor(isLefts, siblings) {
    super();
    this.isLefts = isLefts;
    this.siblings = siblings;
  }
  /**
   * computes the merkle tree root for a given value and the key for this witness
   * @param value The value to compute the root for.
   * @returns A tuple of the computed merkle root, and the key that is connected to the path updated by this witness.
   */
  computeRootAndKey(value) {
    let hash3 = value;
    const isLeft = this.isLefts;
    const siblings = this.siblings;
    let key = Field4(0);
    for (let i2 = 0; i2 < bits; i2++) {
      const left = Provable.if(isLeft[i2], hash3, siblings[i2]);
      const right = Provable.if(isLeft[i2], siblings[i2], hash3);
      hash3 = Poseidon2.hash([left, right]);
      const bit = Provable.if(isLeft[i2], Field4(0), Field4(1));
      key = key.mul(2).add(bit);
    }
    return [hash3, key];
  }
};
(0, import_tslib7.__decorate)([
  arrayProp(Bool4, bits),
  (0, import_tslib7.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "isLefts", void 0);
(0, import_tslib7.__decorate)([
  arrayProp(Field4, bits),
  (0, import_tslib7.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "siblings", void 0);

// dist/node/lib/nullifier.js
var Nullifier = class extends Struct({
  publicKey: Group3,
  public: {
    nullifier: Group3,
    s: Scalar3
  },
  private: {
    c: Field4,
    g_r: Group3,
    h_m_pk_r: Group3
  }
}) {
  static fromJSON(json) {
    return super.fromJSON(json);
  }
  /**
   * Verifies that the Nullifier belongs to a specific message. Throws an error if the Nullifier is incorrect.
   *
   * @example
   *
   * ```ts
   * let nullifierMessage = [voteId, ...otherData];
   * // throws an error if the nullifier is invalid or doesn't belong to this specific message
   * nullifier.verify(nullifierMessage);
   * ```
   */
  verify(message) {
    let { publicKey, public: { nullifier, s }, private: { c } } = this;
    let G = Group3.generator;
    let pk_fields = Group3.toFields(publicKey);
    let { x, y: { x0 } } = Poseidon2.hashToGroup([...message, ...pk_fields]);
    x0.isEven().assertTrue();
    let h_m_pk = Group3.fromFields([x, x0]);
    let pk_c = scaleShifted(this.publicKey, Scalar3.fromBits(c.toBits()));
    let g_r = G.scale(s).sub(pk_c);
    let h_m_pk_s = Group3.scale(h_m_pk, s);
    let h_m_pk_s_div_nullifier_s = h_m_pk_s.sub(scaleShifted(nullifier, Scalar3.fromBits(c.toBits())));
    Poseidon2.hash([
      ...Group3.toFields(G),
      ...pk_fields,
      x,
      x0,
      ...Group3.toFields(nullifier),
      ...Group3.toFields(g_r),
      ...Group3.toFields(h_m_pk_s_div_nullifier_s)
    ]).assertEquals(c, "Nullifier does not match private input!");
  }
  /**
   * The key of the nullifier, which belongs to a unique message and a public key.
   * Used as an index in Merkle trees.
   *
   * @example
   * ```ts
   * // returns the key of the nullifier which can be used as index in a Merkle tree/map
   * let key = nullifier.key();
   * ```
   */
  key() {
    return Poseidon2.hash(Group3.toFields(this.public.nullifier));
  }
  /**
   * Returns the state of the Nullifier.
   *
   * @example
   * ```ts
   * // returns a Bool based on whether or not the nullifier has been used before
   * let isUnused = nullifier.isUnused();
   * ```
   */
  isUnused(witness2, root) {
    let [newRoot, key] = witness2.computeRootAndKey(Field4(0));
    key.assertEquals(this.key());
    let isUnused = newRoot.equals(root);
    let isUsed = witness2.computeRootAndKey(Field4(1))[0].equals(root);
    isUsed.or(isUnused).assertTrue();
    return isUnused;
  }
  /**
   * Checks if the Nullifier has been used before.
   *
   * @example
   * ```ts
   * // asserts that the nullifier has not been used before, throws an error otherwise
   * nullifier.assertUnused();
   * ```
   */
  assertUnused(witness2, root) {
    let [impliedRoot, key] = witness2.computeRootAndKey(Field4(0));
    this.key().assertEquals(key);
    impliedRoot.assertEquals(root);
  }
  /**
   * Sets the Nullifier, returns the new Merkle root.
   *
   * @example
   * ```ts
   * // calculates the new root of the Merkle tree in which the nullifier is set to used
   * let newRoot = nullifier.setUsed(witness);
   * ```
   */
  setUsed(witness2) {
    let [newRoot, key] = witness2.computeRootAndKey(Field4(1));
    key.assertEquals(this.key());
    return newRoot;
  }
  /**
   * Returns the {@link PublicKey} that is associated with this Nullifier.
   *
   * @example
   * ```ts
   * let pk = nullifier.getPublicKey();
   * ```
   */
  getPublicKey() {
    return PublicKey2.fromGroup(this.publicKey);
  }
  /**
   *
   * _Note_: This is *not* the recommended way to create a Nullifier in production. Please use mina-signer to create Nullifiers.
   * Also, this function cannot be run within provable code to avoid unintended creations of Nullifiers - a Nullifier should never be created inside proveable code (e.g. a smart contract) directly, but rather created inside the users wallet (or other secure enclaves, so the private key never leaves that enclave).
   *
   * PLUME: An ECDSA Nullifier Scheme for Unique
   * Pseudonymity within Zero Knowledge Proofs
   * https://eprint.iacr.org/2022/1255.pdf chapter 3 page 14
   */
  static createTestNullifier(message, sk) {
    if (Provable.inCheckedComputation()) {
      throw Error("This function cannot not be run within provable code. If you want to create a Nullifier, run this method outside provable code or use mina-signer to do so.");
    }
    const Hash2 = Poseidon2.hash;
    const Hash3 = Poseidon2.hashToGroup;
    const pk = sk.toPublicKey().toGroup();
    const G = Group3.generator;
    const r = Scalar3.random();
    const gm = Hash3([...message, ...Group3.toFields(pk)]);
    const h_m_pk = Group3({ x: gm.x, y: gm.y.x0 });
    const nullifier = h_m_pk.scale(sk.toBigInt());
    const h_m_pk_r = h_m_pk.scale(r.toBigInt());
    const g_r = G.scale(r.toBigInt());
    const c = Hash2([
      ...Group3.toFields(G),
      ...Group3.toFields(pk),
      ...Group3.toFields(h_m_pk),
      ...Group3.toFields(nullifier),
      ...Group3.toFields(g_r),
      ...Group3.toFields(h_m_pk_r)
    ]);
    const s = r.add(sk.s.mul(Scalar3.from(c.toBigInt())));
    return {
      publicKey: pk.toJSON(),
      private: {
        c: c.toString(),
        g_r: g_r.toJSON(),
        h_m_pk_r: h_m_pk_r.toJSON()
      },
      public: {
        nullifier: nullifier.toJSON(),
        s: s.toJSON()
      }
    };
  }
};

// dist/node/bindings/crypto/finite-field-examples.js
var pSmall = 101n;
var pBabybear = (1n << 31n) - 1n;
var pGoldilocks = (1n << 64n) - (1n << 32n) + 1n;
var p25519 = (1n << 255n) - 19n;
var pSecp256k1 = (1n << 256n) - (1n << 32n) - 977n;
var pSecq256k1 = (1n << 256n) - 0x14551231950b75fc4402da1732fc9bebfn;
var pBls12_381 = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001n;
var qBls12_381 = 0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001n;
var exampleFields = {
  Fp,
  Fq,
  small: createField(pSmall),
  babybear: createField(pBabybear),
  goldilocks: createField(pGoldilocks),
  f25519: createField(p25519),
  secp256k1: createField(pSecp256k1),
  secq256k1: createField(pSecq256k1),
  bls12_381_base: createField(pBls12_381),
  bls12_381_scalar: createField(qBls12_381)
};

// dist/node/bindings/crypto/elliptic-curve-examples.js
var secp256k1Params = {
  name: "secp256k1",
  modulus: exampleFields.secp256k1.modulus,
  order: exampleFields.secq256k1.modulus,
  a: 0n,
  b: 7n,
  generator: {
    x: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
    y: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
  }
};
var pallasParams = {
  name: "Pallas",
  modulus: Pallas.modulus,
  order: Pallas.order,
  a: Pallas.a,
  b: Pallas.b,
  generator: Pallas.one,
  endoBase: Pallas.endoBase,
  endoScalar: Pallas.endoScalar
};
var vestaParams = {
  name: "Vesta",
  modulus: Vesta.modulus,
  order: Vesta.order,
  a: Vesta.a,
  b: Vesta.b,
  generator: Vesta.one,
  endoBase: Vesta.endoBase,
  endoScalar: Vesta.endoScalar
};
var CurveParams = {
  Secp256k1: secp256k1Params,
  Pallas: pallasParams,
  Vesta: vestaParams
};

// dist/node/lib/crypto.js
var Crypto = {
  /**
   * Create elliptic curve arithmetic methods.
   */
  createCurve(params) {
    return createCurveAffine(params);
  },
  /**
   * Parameters defining an elliptic curve in short Weierstraß form
   * y^2 = x^3 + ax + b
   */
  CurveParams
};

// dist/node/index.js
var Experimental_ = {
  Callback,
  createChildAccountUpdate,
  memoizeWitness
};
var Experimental;
(function(Experimental2) {
  Experimental2.ZkProgram = ExperimentalZkProgram;
  Experimental2.createChildAccountUpdate = Experimental_.createChildAccountUpdate;
  Experimental2.memoizeWitness = Experimental_.memoizeWitness;
  Experimental2.Callback = Experimental_.Callback;
})(Experimental || (Experimental = {}));
Error.stackTraceLimit = 1e5;
var isReady = Promise.resolve();
function shutdown() {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  AccountUpdate,
  Bool,
  Bytes,
  Cache,
  Character,
  Circuit,
  CircuitString,
  CircuitValue,
  Crypto,
  EcdsaSignature,
  Empty,
  Encoding,
  Encryption,
  Experimental,
  Field,
  ForeignCurve,
  Gadgets,
  Group,
  Hash,
  Int64,
  Keccak,
  Keypair,
  Ledger,
  Lightnet,
  MerkleMap,
  MerkleMapWitness,
  MerkleTree,
  MerkleWitness,
  Mina,
  Nullifier,
  Permissions,
  Poseidon,
  PrivateKey,
  Proof,
  Provable,
  PublicKey,
  Reducer,
  Scalar,
  SelfProof,
  Sign,
  Signature,
  SmartContract,
  State,
  Struct,
  Token,
  TokenId,
  TokenSymbol,
  Types,
  UInt32,
  UInt64,
  UInt8,
  Undefined,
  VerificationKey,
  Void,
  ZkProgram,
  ZkappPublicInput,
  addCachedAccount,
  arrayProp,
  assert,
  checkZkappTransaction,
  circuitMain,
  createEcdsa,
  createForeignCurve,
  createForeignField,
  declareMethods,
  declareState,
  fetchAccount,
  fetchEvents,
  fetchLastBlock,
  fetchTransactionStatus,
  isReady,
  matrixProp,
  method,
  prop,
  provable,
  provablePure,
  public_,
  scaleShifted,
  sendZkapp,
  setArchiveGraphqlEndpoint,
  setGraphqlEndpoint,
  setGraphqlEndpoints,
  shutdown,
  state,
  verify
});
